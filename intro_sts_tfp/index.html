<!DOCTYPE html>
<html lang="en-us">
  <head>
    <script defer src="https://use.fontawesome.com/releases/v5.13.0/js/all.js"></script>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-5NM5EDH834"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-5NM5EDH834');
</script>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Hugo 0.79.1" />


<title>Exploring TensorFlow Probability STS Forecasting - Dr. Juan Camilo Orduz</title>
<meta property="og:title" content="Exploring TensorFlow Probability STS Forecasting - Dr. Juan Camilo Orduz">


  <link href='../images/favicon.ico' rel='icon' type='image/x-icon'/>



  








<link href='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css' rel='stylesheet' type='text/css' />



<link rel="stylesheet" href="../css/fonts.css" media="all">
<link rel="stylesheet" href="../css/main.css" media="all">



  </head>
  <body>
    <div class="wrapper">
      <header class="header">
        <nav class="nav">
  <a href="../" class="nav-logo">
    <img src="../images/tattoo_logo.jpg"
         width="50"
         height="50"
         alt="Logo">
  </a>

  <ul class="nav-links">
    
    <li><a href="../about/"> About</a></li>
    
    <li><a href="https://github.com/juanitorduz"><i class='fab fa-github fa-2x'></i>  </a></li>
    
    <li><a href="https://www.linkedin.com/in/juanitorduz/"><i class='fab fa-linkedin fa-2x' style='color:#0a66c2;'></i>  </a></li>
    
    <li><a href="https://bayes.club/@juanitorduz"><i class='fab fa-mastodon fa-2x' style='color:#6364FF;'></i>  </a></li>
    
    <li><a href="https://twitter.com/juanitorduz"><i class='fab fa-twitter fa-2x' style='color:#1DA1F2;'></i>  </a></li>
    
  </ul>
</nav>

      </header>


<main class="content" role="main">

  <article class="article">
    
    <span class="article-duration">18 min read</span>
    

    <h1 class="article-title">Exploring TensorFlow Probability STS Forecasting</h1>

    
    <span class="article-date">2020-02-11</span>
    

    <div class="article-content">
      


<dl>
<dt>In this notebook we explore the <a href="https://www.tensorflow.org/probability/api_docs/python/tfp/sts">Structural Time Series (STS) Module</a> of <a href="https://www.tensorflow.org/probability/">TensorFlow Probability</a>. We follow closely the <a href="https://medium.com/tensorflow/structural-time-series-modeling-in-tensorflow-probability-344edac24083">use cases</a> presented in their <a href="https://medium.com/tensorflow">Medium blog</a>. As described there: <em>An STS model expresses an observed time series as the sum of simpler components</em> <a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>:</dt>
<dd>

</dd>
</dl>
<p><span class="math display">\[
f(t) = \sum_{k=1}^{N}f_{k}(t) + \varepsilon, \quad \text{where}\quad \varepsilon \sim N(0, \sigma^2).
\]</span></p>
<p>Each summand <span class="math inline">\(f_{k}(t)\)</span> has a particular structure, e.g.Â specific seasonality, trend, autoregressive terms, etc.</p>
<p>In this notebook we generate a time series sample and then present some techniques to recover its component structure. This is indeed a crucial step since in real applications we are not given the components separately. We then show how to fit and generate predictions using <a href="https://en.wikipedia.org/wiki/Variational_Bayesian_methods">variational inference</a>. Finally we run some diagnostics of the errors on the test set.</p>
<div id="prepare-notebook" class="section level2">
<h2>Prepare Notebook</h2>
<pre class="python"><code>from scipy import signal
from scipy.ndimage import gaussian_filter
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from statsmodels.tsa.seasonal import seasonal_decompose

import arviz as az
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import statsmodels.formula.api as smf
import tensorflow as tf
import tensorflow_probability as tfp

az.style.use(&quot;arviz-darkgrid&quot;)
plt.rcParams[&quot;figure.figsize&quot;] = [12, 7]
plt.rcParams[&quot;figure.dpi&quot;] = 100
plt.rcParams[&quot;figure.facecolor&quot;] = &quot;white&quot;

%load_ext autoreload
%autoreload 2
%config InlineBackend.figure_format = &quot;retina&quot;</code></pre>
<pre class="python"><code>seed: int = 0
rng: np.random.Generator = np.random.default_rng(seed=seed)</code></pre>
<pre class="python"><code>print(tf.__version__)
print(tfp.__version__)</code></pre>
<pre><code>2.14.0
0.22.1</code></pre>
</div>
<div id="generate-data" class="section level2">
<h2>Generate Data</h2>
<p>We are going to generate daily data on the range <code>2017-01-01</code> to <code>2020-12-31</code>.</p>
<pre class="python"><code># Create dataframe with a date range (4 years).
date_range = pd.date_range(start=&quot;2017-01-01&quot;, end=&quot;2020-12-31&quot;, freq=&quot;D&quot;)
# Create data frame.
df = pd.DataFrame(data={&quot;date&quot;: date_range})
# Extract number of points.
n = df.shape[0]</code></pre>
<p>We begin with Gaussian noise.</p>
<pre class="python"><code>df[&quot;y&quot;] = rng.normal(loc=0.0, scale=0.5, size=n)</code></pre>
<p>Next we define an external regressor <code>x</code>.</p>
<pre class="python"><code># External regressor:
df[&quot;x&quot;] = rng.uniform(low=0.0, high=1.0, size=n)
df[&quot;x&quot;] = df[&quot;x&quot;].apply(lambda x: x if abs(x) &gt; 0.95 else 0.0)

df[&quot;y&quot;] = df[&quot;y&quot;] + 6 * df[&quot;x&quot;]</code></pre>
<pre class="python"><code>df[&quot;x&quot;] = df[&quot;x&quot;].astype(np.float32)
df[&quot;y&quot;] = df[&quot;y&quot;].astype(np.float32)

df.info()</code></pre>
<pre><code>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
RangeIndex: 1461 entries, 0 to 1460
Data columns (total 3 columns):
 #   Column  Non-Null Count  Dtype         
---  ------  --------------  -----         
 0   date    1461 non-null   datetime64[ns]
 1   y       1461 non-null   float32       
 2   x       1461 non-null   float32       
dtypes: datetime64[ns](1), float32(2)
memory usage: 23.0 KB</code></pre>
<pre class="python"><code>plt.rcParams[&quot;figure.figsize&quot;] = [12, 7]

fig, ax = plt.subplots()
sns.lineplot(x=&quot;date&quot;, y=&quot;x&quot;, label=&quot;x&quot;, data=df, ax=ax)
ax.legend(loc=&quot;upper left&quot;)
ax.set(title=r&quot;External Regressor $x$&quot;)</code></pre>
<center>
<img src="../images/intro_sts_tfp_files/intro_sts_tfp_13_1.png" style="width: 900px;"/>
</center>
<p>Now, let us add a non-linear trend component of the form <span class="math inline">\(t\longmapsto t^{1/3}\)</span>.</p>
<pre class="python"><code>df[&quot;y&quot;] = df[&quot;y&quot;] + np.power(df.index.values, 1 / 3)</code></pre>
<p>Finally, we add some seasonal variables, which we encode as cyclic variables using <span class="math inline">\(\sin(z)\)</span> and <span class="math inline">\(\cos(z)\)</span> functions.</p>
<pre class="python"><code># Seasonal features:
df[&quot;day_of_month&quot;] = df[&quot;date&quot;].dt.day
df[&quot;month&quot;] = df[&quot;date&quot;].dt.month
df[&quot;day_of_week&quot;] = df[&quot;date&quot;].dt.dayofweek
df[&quot;daysinmonth&quot;] = df[&quot;date&quot;].dt.daysinmonth


df[&quot;y&quot;] = (
    df[&quot;y&quot;]
    + 2 * np.cos(2 * np.pi * df[&quot;month&quot;] / 12)
    + 0.5 * np.sin(2 * np.pi * df[&quot;month&quot;] / 12)
    + 1.5 * np.cos(2 * np.pi * df[&quot;day_of_week&quot;] / 7)
    + 2 * np.sin(2 * np.pi * df[&quot;day_of_month&quot;] / df[&quot;daysinmonth&quot;])
)

df[&quot;y&quot;] = df[&quot;y&quot;].bfill().astype(np.float32)

df.head(10)</code></pre>
<center>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
date
</th>
<th>
y
</th>
<th>
x
</th>
<th>
day_of_month
</th>
<th>
month
</th>
<th>
day_of_week
</th>
<th>
daysinmonth
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
0
</th>
<td>
2017-01-01
</td>
<td>
3.382748
</td>
<td>
0.000000
</td>
<td>
1
</td>
<td>
1
</td>
<td>
6
</td>
<td>
31
</td>
</tr>
<tr>
<th>
1
</th>
<td>
2017-01-02
</td>
<td>
5.204710
</td>
<td>
0.000000
</td>
<td>
2
</td>
<td>
1
</td>
<td>
0
</td>
<td>
31
</td>
</tr>
<tr>
<th>
2
</th>
<td>
2017-01-03
</td>
<td>
5.639954
</td>
<td>
0.000000
</td>
<td>
3
</td>
<td>
1
</td>
<td>
1
</td>
<td>
31
</td>
</tr>
<tr>
<th>
3
</th>
<td>
2017-01-04
</td>
<td>
10.412126
</td>
<td>
0.969928
</td>
<td>
4
</td>
<td>
1
</td>
<td>
2
</td>
<td>
31
</td>
</tr>
<tr>
<th>
4
</th>
<td>
2017-01-05
</td>
<td>
3.647452
</td>
<td>
0.000000
</td>
<td>
5
</td>
<td>
1
</td>
<td>
3
</td>
<td>
31
</td>
</tr>
<tr>
<th>
5
</th>
<td>
2017-01-06
</td>
<td>
4.396875
</td>
<td>
0.000000
</td>
<td>
6
</td>
<td>
1
</td>
<td>
4
</td>
<td>
31
</td>
</tr>
<tr>
<th>
6
</th>
<td>
2017-01-07
</td>
<td>
6.094326
</td>
<td>
0.000000
</td>
<td>
7
</td>
<td>
1
</td>
<td>
5
</td>
<td>
31
</td>
</tr>
<tr>
<th>
7
</th>
<td>
2017-01-08
</td>
<td>
7.301190
</td>
<td>
0.000000
</td>
<td>
8
</td>
<td>
1
</td>
<td>
6
</td>
<td>
31
</td>
</tr>
<tr>
<th>
8
</th>
<td>
2017-01-09
</td>
<td>
7.066338
</td>
<td>
0.000000
</td>
<td>
9
</td>
<td>
1
</td>
<td>
0
</td>
<td>
31
</td>
</tr>
<tr>
<th>
9
</th>
<td>
2017-01-10
</td>
<td>
6.160268
</td>
<td>
0.000000
</td>
<td>
10
</td>
<td>
1
</td>
<td>
1
</td>
<td>
31
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p>Let us plot the generated data:</p>
<pre class="python"><code>fig, ax = plt.subplots()
sns.lineplot(x=&quot;date&quot;, y=&quot;y&quot;, label=&quot;y&quot;, data=df, ax=ax)
ax.legend(loc=&quot;upper left&quot;)
ax.set(title=&quot;Dependent Variable&quot;)</code></pre>
<center>
<img src="../images/intro_sts_tfp_files/intro_sts_tfp_19_1.png" style="width: 900px;"/>
</center>
</div>
<div id="train---test-split" class="section level2">
<h2>Train - Test Split</h2>
<p>We assume we have data until <code>2020-06-30</code> and we will predict six months ahead. We assume we have access to the <code>x</code> variable in advance (e.g.Â media spend plan).</p>
<pre class="python"><code>threshold_date = pd.to_datetime(&quot;2020-07-01&quot;)
mask = df[&quot;date&quot;] &lt; threshold_date

df_train = df[mask]
df_test = df[~mask]</code></pre>
<pre class="python"><code>fig, ax = plt.subplots()
sns.lineplot(x=&quot;date&quot;, y=&quot;y&quot;, label=&quot;y_train&quot;, data=df_train, ax=ax)
sns.lineplot(x=&quot;date&quot;, y=&quot;y&quot;, label=&quot;y_test&quot;, data=df_test, ax=ax)
ax.axvline(threshold_date, color=&quot;C3&quot;, linestyle=&quot;--&quot;, label=&quot;train test split&quot;)
ax.legend(loc=&quot;upper left&quot;)
ax.set(title=&quot;Dependent Variable&quot;)</code></pre>
<center>
<img src="../images/intro_sts_tfp_files/intro_sts_tfp_22_1.png" style="width: 900px;"/>
</center>
</div>
<div id="time-series-exploratory-analysis" class="section level2">
<h2>Time Series Exploratory Analysis</h2>
<p>We are going to assume we do not know how the data was generated. We present a sample of techniques to extract the seasonality and estimate the effect of the <code>x</code> variable on <code>y</code>. There is no unique way to do this and we focus on using the intuition and common sense to extract the relevant features. Time series forecasting can be a very challenging problem. Spending time on exploring the data is always a good investment in order to generate meaningful models.</p>
<p><strong>Warning:</strong> We just use the training data in this step so that we do not leak information from the test set.</p>
<div id="smoothing" class="section level3">
<h3>Smoothing</h3>
<p>We begin the analysis by studying and visualize various level of smoothness using a <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.gaussian_filter.html"><code>gaussian_filter</code></a>. You can think of it as a weighted centered moving average based on a normal distribution. In particular, the level of smoothness is controlled by the parameter <code>sigma</code> which represents the standard deviation.</p>
<pre class="python"><code>df_smooth = df_train.assign(
    y_smooth_1=lambda x: gaussian_filter(input=x[&quot;y&quot;], sigma=3.5)
).assign(y_smooth_2=lambda x: gaussian_filter(input=x[&quot;y&quot;], sigma=15))
fig, ax = plt.subplots()
sns.lineplot(x=&quot;date&quot;, y=&quot;y&quot;, label=&quot;y_train&quot;, data=df_smooth, alpha=0.5, ax=ax)
sns.lineplot(
    x=&quot;date&quot;, y=&quot;y_smooth_1&quot;, label=&quot;y_train_smooth monthly&quot;, data=df_smooth, ax=ax
)
sns.lineplot(
    x=&quot;date&quot;, y=&quot;y_smooth_2&quot;, label=&quot;y_train_smooth yearly&quot;, data=df_smooth, ax=ax
)
ax.legend(loc=&quot;upper left&quot;)
ax.set(title=&quot;Dependent Variable - Smoothing&quot;, ylabel=&quot;y&quot;)</code></pre>
<center>
<img src="../images/intro_sts_tfp_files/intro_sts_tfp_25_1.png" style="width: 900px;"/>
</center>
<p>From this plot we see two clear seasonalities: yearly and monthly. The variable <code>y_train_smooth yearly</code> also includes a positive trend component, which does not look linear.</p>
<p>To understand how to model the monthly seasonality we plot the mean of <code>y</code> over the day of the month.</p>
<pre class="python"><code>fig, ax = plt.subplots()
df_train.groupby(&quot;day_of_month&quot;).agg({&quot;y&quot;: np.mean}).plot(ax=ax)
ax.set(title=&quot;Day of the month mean&quot;)</code></pre>
<center>
<img src="../images/intro_sts_tfp_files/intro_sts_tfp_27_2.png" style="width: 900px;"/>
</center>
<p>This shows a good first approximation is to model this component via a cyclic variable of the form <span class="math inline">\(z\longmapsto \sin(z)\)</span>.</p>
</div>
<div id="remove-yearly-and-monthly-seasonality" class="section level3">
<h3>Remove yearly and monthly seasonality</h3>
<p>Let us remove these two seasonal components:</p>
<pre class="python"><code># Remove yearly seasonality.
y_no_year_season = df_smooth[&quot;y&quot;] - df_smooth[&quot;y_smooth_2&quot;]
# Remove monthly seasonality.
y_no_year_month_season = y_no_year_season - gaussian_filter(
    input=y_no_year_season, sigma=3.5
)

# Plot components.
fig, ax = plt.subplots(
    nrows=3, ncols=1, figsize=(12, 16), sharex=True, sharey=False, layout=&quot;constrained&quot;
)
sns.lineplot(x=&quot;date&quot;, y=&quot;y&quot;, label=&quot;y_train&quot;, data=df_smooth, alpha=0.5, ax=ax[0])
sns.lineplot(
    x=&quot;date&quot;, y=&quot;y_smooth_1&quot;, label=&quot;y_train_smooth monthly&quot;, data=df_smooth, ax=ax[0]
)
sns.lineplot(
    x=&quot;date&quot;, y=&quot;y_smooth_2&quot;, label=&quot;y_train_smooth yearly&quot;, data=df_smooth, ax=ax[0]
)
ax[0].set(title=&quot;y&quot;)

ax[1].plot(df_smooth[&quot;date&quot;], y_no_year_season, c=&quot;C2&quot;)
ax[1].axhline(y_no_year_season.mean(), color=&quot;C3&quot;, linestyle=&quot;--&quot;, label=&quot;mean&quot;)
ax[1].legend()
ax[1].set(title=&quot;y no year seasonality&quot;)

ax[2].plot(df_smooth[&quot;date&quot;], y_no_year_month_season, c=&quot;C1&quot;)
ax[2].axhline(y_no_year_month_season.mean(), color=&quot;C3&quot;, linestyle=&quot;--&quot;, label=&quot;mean&quot;)
ax[2].legend()
ax[2].set(title=&quot;y no year &amp; month seasonality&quot;)</code></pre>
<center>
<img src="../images/intro_sts_tfp_files/intro_sts_tfp_30_1.png" style="width: 900px;"/>
</center>
</div>
<div id="ac-and-pac" class="section level3">
<h3>AC and PAC</h3>
<p>Let us now compute the autocorrelation and partial-autocorrelation of the remainder component.</p>
<pre class="python"><code>fig, ax = plt.subplots(2, 1)
_ = plot_acf(x=y_no_year_month_season, ax=ax[0])
_ = plot_pacf(x=y_no_year_month_season, ax=ax[1])</code></pre>
<center>
<img src="../images/intro_sts_tfp_files/intro_sts_tfp_32_0.png" style="width: 900px;"/>
</center>
<p>From the autocorrelation plot we observe a clear seasonality component at lag 7. Moreover, looking into the shape of the plot we can also see that the encoding is cyclical.</p>
</div>
<div id="correlations" class="section level3">
<h3>Correlations</h3>
<p>We want to see whether there is a linear effect of <code>x</code> on <code>y</code>. A first good indication can be obtained by looking into correlations. Naively, one would simply compute:</p>
<pre class="python"><code>np.corrcoef(df_train[&quot;y&quot;], df_train[&quot;x&quot;])[0, 1]</code></pre>
<pre><code>0.34364604482253697</code></pre>
<p>However, this correlation does not reflect the potential relation of <code>x</code> on <code>y</code> since we have a clear positive trend and seasonality components. A more meaningful indication is the correlation:</p>
<pre class="python"><code>np.corrcoef(y_no_year_month_season, df_train[&quot;x&quot;])[0, 1]</code></pre>
<pre><code>0.6635134779159232</code></pre>
<p>Note that we still have not removed the 7-day (weekly) seasonality. This of course has an effect on this correlation. To see this let us consider the scatter plot:</p>
<pre class="python"><code>fig, ax = plt.subplots()
sns.scatterplot(
    x=y_no_year_month_season,
    y=df_train[&quot;x&quot;],
    hue=df[&quot;day_of_week&quot;],
    palette=&quot;viridis&quot;,
    ax=ax,
)

ax.set(title=&quot;y_no_year_month_season vs x&quot;, xlabel=&quot;x&quot;, ylabel=&quot;y_no_year_month_season&quot;)</code></pre>
<center>
<img src="../images/intro_sts_tfp_files/intro_sts_tfp_39_1.png" style="width: 900px;"/>
</center>
<p>We indeed see we have clear clusters on each level of <code>x</code> corresponding to each day of the week.</p>
<p>One way of removing this seasonality is via a linear regression model. We use a one-hot encoding for the day of the week variable.</p>
<p><strong>Remark:</strong> As we have seen before a cyclical encoding might be a better choice. Nevertheless, given how the data was generated, we want to test the one-hot encoding approach.</p>
<pre class="python"><code># Prepare model data frame.
dow_df = df_train[[&quot;day_of_week&quot;]].copy()
dow_df[&quot;y_no_year_month_season&quot;] = y_no_year_month_season
# One-hot encoding of the day of the week.
dow_dummies = pd.get_dummies(dow_df[&quot;day_of_week&quot;], drop_first=True)
dow_dummies.columns = [&quot;d&quot; + str(i) for i in dow_dummies.columns]
dow_df = pd.concat([dow_df, dow_dummies], axis=1)
dow_df.head()</code></pre>
<center>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
day_of_week
</th>
<th>
y_no_year_month_season
</th>
<th>
d1
</th>
<th>
d2
</th>
<th>
d3
</th>
<th>
d4
</th>
<th>
d5
</th>
<th>
d6
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
0
</th>
<td>
6
</td>
<td>
-2.120053
</td>
<td>
False
</td>
<td>
False
</td>
<td>
False
</td>
<td>
False
</td>
<td>
False
</td>
<td>
True
</td>
</tr>
<tr>
<th>
1
</th>
<td>
0
</td>
<td>
-0.341049
</td>
<td>
False
</td>
<td>
False
</td>
<td>
False
</td>
<td>
False
</td>
<td>
False
</td>
<td>
False
</td>
</tr>
<tr>
<th>
2
</th>
<td>
1
</td>
<td>
0.020675
</td>
<td>
True
</td>
<td>
False
</td>
<td>
False
</td>
<td>
False
</td>
<td>
False
</td>
<td>
False
</td>
</tr>
<tr>
<th>
3
</th>
<td>
2
</td>
<td>
4.709669
</td>
<td>
False
</td>
<td>
True
</td>
<td>
False
</td>
<td>
False
</td>
<td>
False
</td>
<td>
False
</td>
</tr>
<tr>
<th>
4
</th>
<td>
3
</td>
<td>
-2.124617
</td>
<td>
False
</td>
<td>
False
</td>
<td>
True
</td>
<td>
False
</td>
<td>
False
</td>
<td>
False
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p>Next, we fit the linear model.</p>
<pre class="python"><code>dow_mod = smf.ols(
    formula=&quot;y_no_year_month_season ~  d1 + d2 + d3 + d4 + d5 + d6&quot;, data=dow_df
)

dow_res = dow_mod.fit()

print(dow_res.summary())</code></pre>
<pre><code>                              OLS Regression Results                              
==================================================================================
Dep. Variable:     y_no_year_month_season   R-squared:                       0.425
Model:                                OLS   Adj. R-squared:                  0.423
Method:                     Least Squares   F-statistic:                     156.6
Date:                    Thu, 09 Nov 2023   Prob (F-statistic):          6.44e-149
Time:                            11:05:19   Log-Likelihood:                -2103.6
No. Observations:                    1277   AIC:                             4221.
Df Residuals:                        1270   BIC:                             4257.
Df Model:                               6                                         
Covariance Type:                nonrobust                                         
==============================================================================
                 coef    std err          t      P&gt;|t|      [0.025      0.975]
------------------------------------------------------------------------------
Intercept      1.4894      0.093     15.991      0.000       1.307       1.672
d1[T.True]    -0.5122      0.132     -3.888      0.000      -0.771      -0.254
d2[T.True]    -1.5880      0.132    -12.039      0.000      -1.847      -1.329
d3[T.True]    -2.9809      0.132    -22.599      0.000      -3.240      -2.722
d4[T.True]    -2.9059      0.132    -22.030      0.000      -3.165      -2.647
d5[T.True]    -1.7887      0.132    -13.561      0.000      -2.047      -1.530
d6[T.True]    -0.6685      0.132     -5.075      0.000      -0.927      -0.410
==============================================================================
Omnibus:                      752.611   Durbin-Watson:                   2.159
Prob(Omnibus):                  0.000   Jarque-Bera (JB):             6163.206
Skew:                           2.694   Prob(JB):                         0.00
Kurtosis:                      12.317   Cond. No.                         7.86
==============================================================================

Notes:
[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.</code></pre>
<p>We now compute the correlation of the regressor <code>x</code> with the model residuals:</p>
<pre class="python"><code>np.corrcoef(dow_res.resid, df_train[&quot;x&quot;])[0, 1]</code></pre>
<pre><code>0.8502148605418938</code></pre>
<p>The correlation increased significantly.</p>
</div>
<div id="regressor-effect" class="section level3">
<h3>Regressor Effect</h3>
<p>A common question in time series analysis is to estimate the effect (ROI) of a specific external regressor (e.g.Â what is the ROI of media spend on sales?) For this specific case, given the correlation above, we can estimate this for <code>x</code> running a linear model on the residuals of the <code>dow_model</code>.</p>
<pre class="python"><code>x_df = df_train[[&quot;x&quot;]].copy()
x_df[&quot;dow_model_resid&quot;] = dow_res.resid

x_mod = smf.ols(formula=&quot;dow_model_resid ~ x&quot;, data=x_df)

x_res = x_mod.fit()

print(x_res.summary())</code></pre>
<pre><code>                            OLS Regression Results                            
==============================================================================
Dep. Variable:        dow_model_resid   R-squared:                       0.723
Model:                            OLS   Adj. R-squared:                  0.723
Method:                 Least Squares   F-statistic:                     3326.
Date:                Thu, 09 Nov 2023   Prob (F-statistic):               0.00
Time:                        11:05:19   Log-Likelihood:                -1284.2
No. Observations:                1277   AIC:                             2572.
Df Residuals:                    1275   BIC:                             2583.
Df Model:                           1                                         
Covariance Type:            nonrobust                                         
==============================================================================
                 coef    std err          t      P&gt;|t|      [0.025      0.975]
------------------------------------------------------------------------------
Intercept     -0.2309      0.019    -12.182      0.000      -0.268      -0.194
x              5.3018      0.092     57.668      0.000       5.121       5.482
==============================================================================
Omnibus:                        9.800   Durbin-Watson:                   1.280
Prob(Omnibus):                  0.007   Jarque-Bera (JB):                9.950
Skew:                          -0.215   Prob(JB):                      0.00691
Kurtosis:                       2.960   Cond. No.                         4.97
==============================================================================

Notes:
[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.</code></pre>
<p>The estimates effect is then:</p>
<pre class="python"><code>x_res.params[&quot;x&quot;]</code></pre>
<pre><code>5.301793890986457</code></pre>
<p>Recall that the <em>true</em> effect is 5.0.</p>
</div>
<div id="periodogram" class="section level3">
<h3>Periodogram</h3>
<p>There is another way to extract seasonality patterns: using a <a href="https://en.wikipedia.org/wiki/Periodogram">periodogram</a> to estimate the <a href="https://en.wikipedia.org/wiki/Spectral_density">spectral density</a> of a signal.</p>
<pre class="python"><code>f, Pxx_den = signal.periodogram(x=df_train[&quot;y&quot;], detrend=&quot;linear&quot;, nfft=int(7e2))

fig, ax = plt.subplots()
sns.lineplot(x=f, y=Pxx_den, ax=ax)
ax.set(title=&quot;Power Spectral Density&quot;)</code></pre>
<center>
<img src="../images/intro_sts_tfp_files/intro_sts_tfp_53_1.png" style="width: 900px;"/>
</center>
<p>Each of these peaks represent the seasonal components. To compute the associated frequency wee need to compute their multiplicative inverse.</p>
<pre class="python"><code># Sort to get the peak values.
sort_freq_index = np.argsort(a=Pxx_den)[::-1]

periodogram_df = pd.DataFrame(
    {&quot;sort_freq&quot;: f[sort_freq_index], &quot;Pxx_den&quot;: Pxx_den[sort_freq_index]}
)

periodogram_df.assign(days=lambda x: 1 / x[&quot;sort_freq&quot;]).head(5)</code></pre>
<center>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
sort_freq
</th>
<th>
Pxx_den
</th>
<th>
days
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
0
</th>
<td>
0.032857
</td>
<td>
1171.129150
</td>
<td>
30.434783
</td>
</tr>
<tr>
<th>
1
</th>
<td>
0.002857
</td>
<td>
1145.587036
</td>
<td>
350.000000
</td>
</tr>
<tr>
<th>
2
</th>
<td>
0.142857
</td>
<td>
765.873230
</td>
<td>
7.000000
</td>
</tr>
<tr>
<th>
3
</th>
<td>
0.001429
</td>
<td>
178.147018
</td>
<td>
700.000000
</td>
</tr>
<tr>
<th>
4
</th>
<td>
0.171429
</td>
<td>
22.012793
</td>
<td>
5.833333
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p>The first three values correspond to <code>days</code> = 30, 350 and 7. Which correspond to monthly, yearly and weekly seasonality.</p>
</div>
<div id="time-series-decomposition" class="section level3">
<h3>Time Series Decomposition</h3>
<p><a href="https://www.statsmodels.org/stable/index.html"><code>statsmodels</code></a> has an inbuilt decomposition function using moving averages. Let us use it to estimate the effect of the external regressor (which we already know it should the residual component).</p>
<pre class="python"><code>decomposition_obj = seasonal_decompose(
    x=df_train[[&quot;date&quot;, &quot;y&quot;]].set_index(&quot;date&quot;), model=&quot;additive&quot;
)

fig, ax = plt.subplots(4, 1, figsize=(12, 12))

decomposition_obj.observed.plot(ax=ax[0])
ax[0].set(title=&quot;observed&quot;)
decomposition_obj.trend.plot(ax=ax[1])
ax[1].set(title=&quot;trend&quot;)
decomposition_obj.seasonal.plot(ax=ax[2])
ax[2].set(title=&quot;seasonal&quot;)
decomposition_obj.resid.plot(ax=ax[3])
ax[3].set(title=&quot;residual&quot;)
plt.tight_layout()</code></pre>
<center>
<img src="../images/intro_sts_tfp_files/intro_sts_tfp_58_1.png" style="width: 900px;"/>
</center>
<p>Note that the trend component also includes the monthly and yearly seasonality. This might not always be desired. You can of course use the smoothing technique presented above or keep decomposing the resulting trend by specifying the <code>period</code> parameter in the <code>seasonal_decompose</code> function.</p>
<ul>
<li>Correlation</li>
</ul>
<pre class="python"><code># We remove the first and last 3 entries as they are np.nan coming
# from the moving average method.
np.corrcoef(decomposition_obj.resid[3:-3], df_train[&quot;x&quot;][3:-3])[0, 1]</code></pre>
<pre><code>0.8533497914653861</code></pre>
<ul>
<li>Effect Estimation</li>
</ul>
<pre class="python"><code>x_df[&quot;decomposition_resid&quot;] = decomposition_obj.resid.values

x_mod2 = smf.ols(formula=&quot;decomposition_resid ~ x&quot;, data=x_df[3:-3])

x_res2 = x_mod2.fit()

print(x_res2.summary())</code></pre>
<pre><code>                             OLS Regression Results                            
===============================================================================
Dep. Variable:     decomposition_resid   R-squared:                       0.728
Model:                             OLS   Adj. R-squared:                  0.728
Method:                  Least Squares   F-statistic:                     3400.
Date:                 Thu, 09 Nov 2023   Prob (F-statistic):               0.00
Time:                         11:05:23   Log-Likelihood:                -1242.5
No. Observations:                 1271   AIC:                             2489.
Df Residuals:                     1269   BIC:                             2499.
Df Model:                            1                                         
Covariance Type:             nonrobust                                         
==============================================================================
                 coef    std err          t      P&gt;|t|      [0.025      0.975]
------------------------------------------------------------------------------
Intercept     -0.2265      0.018    -12.259      0.000      -0.263      -0.190
x              5.2128      0.089     58.309      0.000       5.037       5.388
==============================================================================
Omnibus:                       37.931   Durbin-Watson:                   1.562
Prob(Omnibus):                  0.000   Jarque-Bera (JB):               40.589
Skew:                          -0.432   Prob(JB):                     1.54e-09
Kurtosis:                       3.139   Cond. No.                         4.96
==============================================================================

Notes:
[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.</code></pre>
<p>We get similar results as above.</p>
<p><strong>Remarks:</strong></p>
<ul>
<li><p>In real life applications the effects of external regressors might include lags. A correlation analysis with lags needs to be done before modeling.</p></li>
<li><p>Also, linear relations might serve as a good first approximation. Nevertheless, going into non-linear relations might improve the model significantly. Two concrete methods which appear often is to model via <a href="https://en.wikipedia.org/wiki/Advertising_adstock">adstock effect</a> and <a href="https://en.wikipedia.org/wiki/Generalized_additive_model">generalized additive models</a>.</p></li>
</ul>
</div>
</div>
<div id="define-model" class="section level2">
<h2>Define Model</h2>
<p>Based on the previous analysis we have identified the main components of our time series:</p>
<ul>
<li><p>A <code>local_linear_trend</code></p></li>
<li><p>Seasonality:</p>
<ul>
<li><code>month_of_year</code></li>
<li><code>day_of_week</code></li>
<li><code>day_of_month</code></li>
</ul></li>
<li><p>External regressor <code>x_var</code>.</p></li>
</ul>
<p>We define each of these components separately in order to build the sts-model using TensorFlow Probability.</p>
<pre class="python"><code># Local linear trend.
local_linear_trend = tfp.sts.LocalLinearTrend(
    observed_time_series=df_train[&quot;y&quot;],
    name=&quot;local_linear_trend&quot;,
)

# We need to pre-define the number of days in each month.
num_days_per_month = np.array(
    [
        [31, 28, 31, 30, 30, 31, 31, 31, 30, 31, 30, 31],
        [31, 28, 31, 30, 30, 31, 31, 31, 30, 31, 30, 31],
        [31, 28, 31, 30, 30, 31, 31, 31, 30, 31, 30, 31],
        [31, 29, 31, 30, 30, 31, 31, 31, 30, 31, 30, 31],  # year with leap day.
    ]
)

# Define month of year seasonal variable.
month_of_year = tfp.sts.Seasonal(
    num_seasons=12, num_steps_per_season=num_days_per_month, name=&quot;month_of_year&quot;
)

# Define day of week as seasonal variable.
day_of_week = tfp.sts.Seasonal(
    num_seasons=7,
    num_steps_per_season=1,
    observed_time_series=df_train[&quot;y&quot;],
    name=&quot;day_of_week&quot;,
)

# Create cyclic variable for day of the month.
design_matrix_day_of_month = tf.reshape(
    np.sin(2 * np.pi * df[&quot;day_of_month&quot;] / df[&quot;daysinmonth&quot;]).values.astype(
        np.float32
    ),
    (-1, 1),
)

# Define day of the month as an external regressor.
# We do not encode it as seasonal as the number of steps is not uniform.
day_of_month = tfp.sts.LinearRegression(
    design_matrix=design_matrix_day_of_month, name=&quot;day_of_month&quot;
)

# Define external regressor component.
# We use the whole data set (df) as we expect to have these values in the future.
design_matrix_x_var = tf.reshape(df[&quot;x&quot;].values, (-1, 1))

x_var = tfp.sts.LinearRegression(design_matrix=design_matrix_x_var, name=&quot;x_var&quot;)</code></pre>
<p>Now we build the model:</p>
<pre class="python"><code>model_components = [
    local_linear_trend,
    month_of_year,
    day_of_week,
    day_of_month,
    x_var,
]

toy_model = tfp.sts.Sum(components=model_components, observed_time_series=df_train[&quot;y&quot;])</code></pre>
<p>Let us see the model parameters and their priors:</p>
<pre class="python"><code>for p in toy_model.parameters:
    print(&quot;-&quot; * 140)
    print(f&quot;Parameter: {p.name}&quot;)
    print(f&quot;Prior: {str(p.prior)}&quot;)</code></pre>
<pre><code>--------------------------------------------------------------------------------------------------------
Parameter: observation_noise_scale
Prior: tfp.distributions.LogNormal(&quot;LogNormal&quot;, batch_shape=[], event_shape=[], dtype=float32)
--------------------------------------------------------------------------------------------------------
Parameter: local_linear_trend/_level_scale
Prior: tfp.distributions.LogNormal(&quot;level_scale_prior&quot;, batch_shape=[], event_shape=[], dtype=float32)
--------------------------------------------------------------------------------------------------------
Parameter: local_linear_trend/_slope_scale
Prior: tfp.distributions.LogNormal(&quot;slope_scale_prior&quot;, batch_shape=[], event_shape=[], dtype=float32)
--------------------------------------------------------------------------------------------------------
Parameter: month_of_year/_drift_scale
Prior: tfp.distributions.LogNormal(&quot;LogNormal&quot;, batch_shape=[], event_shape=[], dtype=float32)
--------------------------------------------------------------------------------------------------------
Parameter: day_of_week/_drift_scale
Prior: tfp.distributions.LogNormal(&quot;LogNormal&quot;, batch_shape=[], event_shape=[], dtype=float32)
--------------------------------------------------------------------------------------------------------
Parameter: day_of_month/_weights
Prior: tfp.distributions.Sample(&quot;SampleStudentT&quot;, batch_shape=[], event_shape=[1], dtype=float32)
--------------------------------------------------------------------------------------------------------
Parameter: x_var/_weights
Prior: tfp.distributions.Sample(&quot;SampleStudentT&quot;, batch_shape=[], event_shape=[1], dtype=float32)</code></pre>
</div>
<div id="model-fit" class="section level2">
<h2>Model Fit</h2>
<div id="variational-inference-short-intro" class="section level3">
<h3>Variational Inference (Short Intro)</h3>
<p>We follow the strategy of the TensorFlow Probability <a href="https://medium.com/tensorflow/structural-time-series-modeling-in-tensorflow-probability-344edac24083">use cases</a> and fit the model using variational inference. I find the article <a href="https://arxiv.org/pdf/1601.00670.pdf">Variational Inference: A Review for Statisticians</a> very good for an introduction to the subject. The main idea of variational inference is to use optimization methods to minimize the <a href="https://en.wikipedia.org/wiki/KullbackâLeibler_divergence">Kullback-Leibler</a> divergence in order to approximate a conditional density within a family of specified parameter densities <span class="math inline">\(\mathfrak{D}\)</span>. Specifically, assume we are given observed variables <span class="math inline">\(x\)</span> (i.e.Â data) and let <span class="math inline">\(z\)</span> be a set of latent variables with joint density <span class="math inline">\(p(x, z)\)</span>. We are interested in computing the conditional density</p>
<p><span class="math display">\[
p(z|x) = \frac{p(x, z)}{p(x)}, \quad\text{where} \quad p(x)=\int p(x, z) dz.
\]</span></p>
<p>This last integral (known as the <em>evidence</em>) is in general very hard to compute. The main idea of variational inference is to solve the optimization problem</p>
<p><span class="math display">\[
q^{*}(z)=\min_{q \in \mathfrak{D}} \text{KL}(q(z)||p(z|x)),
\]</span></p>
<p>where</p>
<p><span class="math display">\[
\begin{align}
\text{KL}(q(z)||p(z|x)) =&amp; \text{E}[\log(q(z))] - \text{E}[\log(p(z|x))] \\
=&amp; \text{E}[\log(q(z))] - \text{E}[\log(p(z,x))] - \text{E}[\log(p(x))] \\
=&amp; \text{E}[\log(q(z))] - \text{E}[\log(p(z,x))] - \log(p(x)
\end{align}
\]</span></p>
<p>is the Kullback-Leibler (KL) divergence (the expected values are taken with respect to <span class="math inline">\(q(z)\)</span>). Note that this quantity contains a term <span class="math inline">\(\text{E}[\log(p(x))]\)</span>, which is hard to compute. <em>Because we cannot compute the KL, we optimize an alternative objective that is equivalent
to the KL up to an added constant </em><a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>,</p>
<p><span class="math display">\[
\text{ELBO}(q) = \text{E}[\log(p(z, x))] - \text{E}[\log(q(z))]
\]</span></p>
<p>ELBO stands for <em>evidence lower bound</em>.</p>
<p><strong>Remark:</strong> Note that</p>
<p><span class="math display">\[
\text{ELBO}(q)= -\text{KL}(q(z)||p(z|x)) + \log(p(x))
\]</span></p>
<p>Moreover, it is easy to see that</p>
<p><span class="math display">\[
\text{ELBO}(q)= \text{E}[\log(p(x|z)]-\text{KL}(q(z)||p(x))
\]</span></p>
<p>The first term is the expected likelihood and the second term is the negative divergence between the variational density and the prior.</p>
<p>For more details and enlightening comments, please refer to the article mentioned above (from which this short introduction was taken from).</p>
</div>
<div id="variational-inference-in-tensorflow-probability" class="section level3">
<h3>Variational Inference in TensorFlow Probability</h3>
<p>First we build the variational surrogate posteriors, which consist of independent normal distributions with two trainable hyper-parameters <code>loc</code> and <code>scale</code> for each parameter in the model. That is, <span class="math inline">\(\mathfrak{D}\)</span> above consists of normal distributions.</p>
<pre class="python"><code>variational_posteriors = tfp.sts.build_factored_surrogate_posterior(
    model=toy_model, seed=seed
)</code></pre>
<p>Let us sample from the prior distributions and plot the corresponding densities:</p>
<pre class="python"><code>q_prior_samples = variational_posteriors.sample(1000)</code></pre>
<pre class="python"><code>num_parameters = len(toy_model.parameters)

fig, ax = plt.subplots(
    nrows=num_parameters,
    ncols=1,
    figsize=(12, 21),
    sharex=False,
    sharey=False,
    layout=&quot;constrained&quot;,
)

for i, param in enumerate(toy_model.parameters):
    param_mean = np.mean(q_prior_samples[param.name], axis=0)
    param_median = np.median(q_prior_samples[param.name], axis=0)
    param_std = np.std(q_prior_samples[param.name], axis=0)

    sns.histplot(x=q_prior_samples[param.name].numpy().flatten(), kde=True, ax=ax[i])
    ax[i].set(title=param.name)
    ax[i].axvline(x=param_median, color=&quot;C1&quot;, linestyle=&quot;--&quot;, label=&quot;median&quot;)
    ax[i].axvline(x=param_mean, color=&quot;C2&quot;, linestyle=&quot;--&quot;, label=&quot;mean&quot;)
    ax[i].axvline(
        x=param_mean + 2 * param_std,
        color=&quot;C3&quot;,
        linestyle=&quot;--&quot;,
        label=r&quot;$\mu \pm 2\sigma$&quot;,
    )
    ax[i].axvline(x=param_mean - param_std, color=&quot;C3&quot;, linestyle=&quot;--&quot;)
    ax[i].legend()

fig.suptitle(&quot;PRIOR DISTRIBUTIONS&quot;, fontweight=&quot;bold&quot;, fontsize=16, y=1.02)</code></pre>
<center>
<img src="../images/intro_sts_tfp_files/intro_sts_tfp_78_1.png" style="width: 900px;"/>
</center>
<p>Next we run the optimization procedure.</p>
<pre class="python"><code>num_variational_steps = 500

# Set optimizer.
optimizer = tf.optimizers.Adam(learning_rate=0.1)


# Using fit_surrogate_posterior to build and optimize
# the variational loss function.
@tf.function(experimental_compile=True)
def train():
    # Build the joint density.
    target_log_prob_fn = toy_model.joint_distribution(
        observed_time_series=df_train[&quot;y&quot;]
    ).log_prob

    return tfp.vi.fit_surrogate_posterior(
        target_log_prob_fn=target_log_prob_fn,
        surrogate_posterior=variational_posteriors,
        optimizer=optimizer,
        num_steps=num_variational_steps,
        seed=seed,
    )


# Run optimization.
elbo_loss_curve = train()</code></pre>
<p>Let us plot the <code>elbo_loss_curve</code>.</p>
<pre class="python"><code>fig, ax = plt.subplots()
ax.plot(elbo_loss_curve, marker=&quot;.&quot;)
ax.set(title=&quot;ELBO Loss Curve&quot;, xlabel=&quot;iteration&quot;)</code></pre>
<center>
<img src="../images/intro_sts_tfp_files/intro_sts_tfp_82_1.png" style="width: 900px;"/>
</center>
<p>We see that a minimum has been reached.</p>
<p>Now we sample from the variational posteriors obtained:</p>
<pre class="python"><code>q_samples = variational_posteriors.sample(2_000)</code></pre>
<p>Let us plot the parameter posterior distributions:</p>
<pre class="python"><code>num_parameters = len(toy_model.parameters)

fig, ax = plt.subplots(
    nrows=num_parameters,
    ncols=1,
    figsize=(12, 21),
    sharex=False,
    sharey=False,
    layout=&quot;constrained&quot;,
)

for i, param in enumerate(toy_model.parameters):
    param_mean = np.mean(q_samples[param.name], axis=0)
    param_median = np.median(q_samples[param.name], axis=0)
    param_std = np.std(q_samples[param.name], axis=0)

    sns.histplot(x=q_samples[param.name].numpy().flatten(), kde=True, ax=ax[i])
    ax[i].set(title=param.name)
    ax[i].axvline(x=param_median, color=&quot;C1&quot;, linestyle=&quot;--&quot;, label=&quot;median&quot;)
    ax[i].axvline(x=param_mean, color=&quot;C2&quot;, linestyle=&quot;--&quot;, label=&quot;mean&quot;)
    ax[i].axvline(
        x=param_mean + 2 * param_std,
        color=&quot;C3&quot;,
        linestyle=&quot;--&quot;,
        label=r&quot;$\mu \pm 2\sigma$&quot;,
    )
    ax[i].axvline(x=param_mean - param_std, color=&quot;C3&quot;, linestyle=&quot;--&quot;)
    ax[i].legend()

fig.suptitle(&quot;POSTERIOR DISTRIBUTIONS&quot;, fontweight=&quot;bold&quot;, fontsize=16, y=1.02)</code></pre>
<center>
<img src="../images/intro_sts_tfp_files/intro_sts_tfp_87_1.png" style="width: 900px;"/>
</center>
<pre class="python"><code># Get mean and std for each parameter.
print(&quot;Inferred parameters:&quot;)
for param in toy_model.parameters:
    print(
        &quot;{}: {} +- {}&quot;.format(
            param.name,
            np.mean(q_samples[param.name], axis=0),
            np.std(q_samples[param.name], axis=0),
        )
    )</code></pre>
<pre><code>Inferred parameters:
observation_noise_scale: 0.484006404876709 +- 0.010281678289175034
local_linear_trend/_level_scale: 0.019886409863829613 +- 0.012175584211945534
local_linear_trend/_slope_scale: 0.0008743585785850883 +- 0.0002825716510415077
month_of_year/_drift_scale: 0.014278052374720573 +- 0.04950084537267685
day_of_week/_drift_scale: 0.004724537953734398 +- 0.0029768438544124365
day_of_month/_weights: [1.9374084] +- [0.02063216]
x_var/_weights: [6.03262] +- [0.0631116]</code></pre>
<p><strong>Remark:</strong> Observe that the estimated effect of the regressor <code>x</code> is around 6.</p>
</div>
</div>
<div id="model-predictions" class="section level2">
<h2>Model Predictions</h2>
<p>We now generate the forecast six months ahead.</p>
<pre class="python"><code># Compute number of days in the last 6 months of 2020.
forecast_window = num_days_per_month[-1][6:13].sum().astype(np.int32)

# Get forecast distribution.
forecast_dist = tfp.sts.forecast(
    model=toy_model,
    observed_time_series=df_train[&quot;y&quot;],
    parameter_samples=q_samples,
    num_steps_forecast=forecast_window,
)</code></pre>
<pre class="python"><code># Sample and compute mean and std.
num_samples = 1_000

forecast_mean, forecast_scale, forecast_samples = (
    forecast_dist.mean().numpy().flatten(),
    forecast_dist.stddev().numpy().flatten(),
    forecast_dist.sample(num_samples).numpy().flatten(),
)</code></pre>
<p>Next, we store the predictions on the <code>df_test</code> data frame.</p>
<pre class="python"><code>df_test = df_test.assign(
    y_pred=forecast_mean,
    y_pred_std=forecast_scale,
    errors=lambda x: x[&quot;y&quot;] - x[&quot;y_pred&quot;],
)</code></pre>
<p>Let us plot the predictions:</p>
<pre class="python"><code>fig, ax = plt.subplots()

ax.fill_between(
    x=df_test[&quot;date&quot;],
    y1=df_test[&quot;y_pred&quot;] - 2 * df_test[&quot;y_pred_std&quot;],
    y2=df_test[&quot;y_pred&quot;] + 2 * df_test[&quot;y_pred_std&quot;],
    color=&quot;C2&quot;,
    alpha=0.25,
    label=r&quot;credible_interval ($\mu \pm 2\sigma$)&quot;,
)

sns.lineplot(x=&quot;date&quot;, y=&quot;y&quot;, label=&quot;train&quot;, data=df_train, ax=ax)
sns.lineplot(x=&quot;date&quot;, y=&quot;y&quot;, label=&quot;test&quot;, data=df_test, ax=ax)
sns.lineplot(x=&quot;date&quot;, y=&quot;y_pred&quot;, label=&quot;prediction&quot;, data=df_test, ax=ax)
ax.axvline(x=threshold_date, color=&quot;C3&quot;, linestyle=&quot;--&quot;, label=&quot;train-test split&quot;)
ax.legend(loc=&quot;upper left&quot;)
ax.set(title=&quot;STS Forecast&quot;)</code></pre>
<center>
<img src="../images/intro_sts_tfp_files/intro_sts_tfp_96_1.png" style="width: 900px;"/>
</center>
<p>Zooming in:</p>
<pre class="python"><code>fig, ax = plt.subplots()

ax.fill_between(
    x=df_test[&quot;date&quot;],
    y1=df_test[&quot;y_pred&quot;] - 2 * df_test[&quot;y_pred_std&quot;],
    y2=df_test[&quot;y_pred&quot;] + 2 * df_test[&quot;y_pred_std&quot;],
    color=&quot;C2&quot;,
    alpha=0.25,
    label=r&quot;credible_interval ($\mu \pm 2\sigma$)&quot;,
)
sns.lineplot(x=&quot;date&quot;, y=&quot;y&quot;, label=&quot;test&quot;, data=df_test, ax=ax)
sns.lineplot(x=&quot;date&quot;, y=&quot;y_pred&quot;, label=&quot;prediction&quot;, data=df_test, ax=ax)
ax.legend(loc=&quot;upper left&quot;)
ax.set(title=&quot;STS Forecast&quot;)</code></pre>
<center>
<img src="../images/intro_sts_tfp_files/intro_sts_tfp_98_1.png" style="width: 900px;"/>
</center>
<p>Let us see it as a scatter plot.</p>
<pre class="python"><code>fig, ax = plt.subplots(figsize=(8, 8))
sns.regplot(x=&quot;y&quot;, y=&quot;y_pred&quot;, data=df_test, ax=ax)
ax.axline(xy1=(10, 10), slope=1, color=&quot;C3&quot;, linestyle=&quot;--&quot;, label=&quot;diagonal&quot;)
ax.legend()</code></pre>
<center>
<img src="../images/intro_sts_tfp_files/intro_sts_tfp_100_1.png" style="width: 900px;"/>
</center>
</div>
<div id="error-analysis" class="section level2">
<h2>Error Analysis</h2>
<p>It is important to emphasize that, for any modeling problem, getting the predictions is not the end of the story. It is very important to analyze the errors to understand where is the model not working as expected.</p>
<ul>
<li>Distribution</li>
</ul>
<pre class="python"><code>errors_mean = df_test[&quot;errors&quot;].mean()
errors_std = df_test[&quot;errors&quot;].std()

fig, ax = plt.subplots()

sns.histplot(x=df_test[&quot;errors&quot;], bins=20, kde=True, ax=ax)
ax.axvline(x=errors_mean, color=&quot;C2&quot;, linestyle=&quot;--&quot;, label=r&quot;$\mu$&quot;)
ax.axvline(
    x=errors_mean + 2 * errors_std,
    color=&quot;C3&quot;,
    linestyle=&quot;--&quot;,
    label=r&quot;$\mu \pm 2\sigma$&quot;,
)
ax.axvline(x=errors_mean - 2 * errors_std, color=&quot;C3&quot;, linestyle=&quot;--&quot;)
ax.legend()
ax.set(title=&quot;Model Errors (Test Set)&quot;)</code></pre>
<center>
<img src="../images/intro_sts_tfp_files/intro_sts_tfp_103_1.png" style="width: 900px;"/>
</center>
<p>The errors look normally distributed and centered around zero.</p>
<ul>
<li>Autocorrelation</li>
</ul>
<pre class="python"><code>fig, ax = plt.subplots()

sns.scatterplot(x=&quot;index&quot;, y=&quot;errors&quot;, data=df_test.reset_index(), ax=ax)
ax.axhline(y=errors_mean, color=&quot;C2&quot;, linestyle=&quot;--&quot;, label=r&quot;$\mu$ &quot;)
ax.axhline(
    y=errors_mean + 2 * errors_std,
    color=&quot;C3&quot;,
    linestyle=&quot;--&quot;,
    label=r&quot;$\mu \pm 2\sigma$&quot;,
)
ax.axhline(y=errors_mean - 2 * errors_std, color=&quot;C3&quot;, linestyle=&quot;--&quot;)
ax.legend()
ax.set(title=&quot;Model Errors (Test Set)&quot;)</code></pre>
<center>
<img src="../images/intro_sts_tfp_files/intro_sts_tfp_106_1.png" style="width: 900px;"/>
</center>
<pre class="python"><code>fig, ax = plt.subplots(2, 1)
_ = plot_acf(x=df_test[&quot;errors&quot;], ax=ax[0])
_ = plot_pacf(x=df_test[&quot;errors&quot;], ax=ax[1])</code></pre>
<center>
<img src="../images/intro_sts_tfp_files/intro_sts_tfp_107_0.png" style="width: 900px;"/>
</center>
<p>We do not see any significant (partial) autocorrelation nor patterns on the errors. They look independent and normally distributed around zero.</p>
</div>
<div id="model-fit-decomposition" class="section level2">
<h2>Model Fit Decomposition</h2>
<p>Finally, let us see the individual model components.</p>
<pre class="python"><code>component_dists = tfp.sts.decompose_by_component(
    model=toy_model, observed_time_series=df_train[&quot;y&quot;], parameter_samples=q_samples
)</code></pre>
<pre class="python"><code>component_means, component_stddevs = (
    {k.name: c.mean() for k, c in component_dists.items()},
    {k.name: c.stddev() for k, c in component_dists.items()},
)</code></pre>
<pre class="python"><code>num_components = len(component_means)

fig, ax = plt.subplots(
    nrows=num_components,
    ncols=1,
    figsize=(12, 15),
    sharex=True,
    sharey=False,
    layout=&quot;constrained&quot;,
)

for i, component_name in enumerate(component_means.keys()):
    component_mean = component_means[component_name]
    component_stddev = component_stddevs[component_name]

    sns.lineplot(x=df_train[&quot;date&quot;], y=component_mean, color=&quot;C0&quot;, ax=ax[i])

    ax[i].fill_between(
        x=df_train[&quot;date&quot;],
        y1=component_mean - 2 * component_stddev,
        y2=component_mean + 2 * component_stddev,
        alpha=0.4,
        color=&quot;C1&quot;,
    )

    ax[i].set(title=component_name)

fig.suptitle(&quot;Model Components&quot;, fontweight=&quot;bold&quot;, fontsize=16, y=1.02)</code></pre>
<center>
<img src="../images/intro_sts_tfp_files/intro_sts_tfp_112_1.png" style="width: 900px;"/>
</center>
<hr />
<p>This was a first exploration of the <a href="https://www.tensorflow.org/probability/api_docs/python/tfp/sts">STS TensorFlow Probability</a> module. We emphasized on the time series exploratory analysis since, in real applications, we are never given the time series structure prior modeling (that would be quite boring). I really want to keep exploring the tools and techniques implemented in this probabilistic programming framework.</p>
</div>
<div class="footnotes footnotes-end-of-document">
<hr />
<ol>
<li id="fn1"><p><a href="https://medium.com/tensorflow/structural-time-series-modeling-in-tensorflow-probability-344edac24083">Structural Time Series modeling in TensorFlow Probability</a><a href="#fnref1" class="footnote-back">â©ï¸</a></p></li>
<li id="fn2"><p><a href="https://arxiv.org/pdf/1601.00670.pdf">Variational Inference: A Review for Statisticians</a><a href="#fnref2" class="footnote-back">â©ï¸</a></p></li>
</ol>
</div>

    </div>
  </article>

  


</main>

      <footer class="footer">
        <ul class="footer-links">
          <li>
            <a href="../index.xml" type="application/rss+xml" target="_blank">RSS feed</a>
          </li>
          <li>
            <a href="https://gohugo.io/" class="footer-links-kudos">Made with <img src="../images/hugo-logo.png" alt="Img link to Hugo website" width="22" height="22"></a>
          </li>
        </ul>
      </footer>

    </div>
    



<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>



<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/r.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/python.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/dockerfile.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/bash.min.js"></script>
<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



    
<script src="../js/math-code.js"></script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'G-5NM5EDH834', 'auto');
	
	ga('send', 'pageview');
}
</script>

  </body>
</html>

