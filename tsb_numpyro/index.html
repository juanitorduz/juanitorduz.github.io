<!DOCTYPE html>
<html lang="en-us">
  <head>
    <script defer src="https://use.fontawesome.com/releases/v6.5.1/js/all.js"></script>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-5NM5EDH834"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-5NM5EDH834');
</script>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Hugo 0.79.1" />


<title>TSB Method for Intermittent Time Series Forecasting in NumPyro - Dr. Juan Camilo Orduz</title>
<meta property="og:title" content="TSB Method for Intermittent Time Series Forecasting in NumPyro - Dr. Juan Camilo Orduz">


  <link href='../images/favicon.ico' rel='icon' type='image/x-icon'/>



  








<link href='//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css' rel='stylesheet' type='text/css' />



<link rel="stylesheet" href="../css/fonts.css" media="all">
<link rel="stylesheet" href="../css/main.css" media="all">



  </head>
  <body>
    <div class="wrapper">
      <header class="header">
        <nav class="nav">
  <a href="../" class="nav-logo">
    <img src="../images/tattoo_logo.jpg"
         width="50"
         height="50"
         alt="Logo">
  </a>

  <ul class="nav-links">
    
    <li><a href="../about/"> About</a></li>
    
    <li><a href="https://github.com/juanitorduz"><i class='fab fa-github fa-2x'></i>  </a></li>
    
    <li><a href="https://www.linkedin.com/in/juanitorduz/"><i class='fab fa-linkedin fa-2x' style='color:#0a66c2;'></i>  </a></li>
    
    <li><a href="https://twitter.com/juanitorduz"><i class='fab fa-twitter fa-2x' style='color:#1DA1F2;'></i>  </a></li>
    
    <li><a href="https://bayes.club/@juanitorduz"><i class='fab fa-mastodon fa-2x' style='color:#6364FF;'></i>  </a></li>
    
    <li><a href="https://ko-fi.com/juanitorduz"><i class='fa-solid fa-mug-hot fa-2x' style='color:#FF5E5B;'></i>  </a></li>
    
  </ul>
</nav>

      </header>


<main class="content" role="main">

  <article class="article">
    
    <span class="article-duration">9 min read</span>
    

    <h1 class="article-title">TSB Method for Intermittent Time Series Forecasting in NumPyro</h1>

    
    <span class="article-date">2024-02-17</span>
    

    <div class="article-content">
      


<p>In this notebook we provide a <a href="http://num.pyro.ai"><code>NumPyro</code></a> implementation of the TSB (Teunter, Syntetos and Babai) method for forecasting intermittent time series. The TSB method is similar to the <a href="https://juanitorduz.github.io/croston_numpyro/">Crostonâ€™s method</a> in the sense that is constructs two different time series out of the original one and then forecast each of them separately, so that the final forecast is generated by combining the forecasts of the two time series. The main difference between the two methods is that the TSB method uses the demand probability instead of the demand periods. Consequently,let <span class="math inline">\(y_{t}\)</span> denote the input time series then the TSB method is specified by the following equations:</p>
<p>If <span class="math inline">\(y_{t} &gt; 0\)</span>, then</p>
<p><span class="math display">\[
\begin{align*}
z_{t + 1} &amp; = \alpha y_{t} + (1 - \alpha) z_{t} \\
p_{t + 1} &amp; = \beta + (1 - \beta) p_{t}
\end{align*}
\]</span></p>
<p>If <span class="math inline">\(y_{t} = 0\)</span>, then</p>
<p><span class="math display">\[
\begin{align*}
z_{t + 1} &amp; = z_{t} \\
p_{t + 1} &amp; = (1 - \beta) p_{t}
\end{align*}
\]</span></p>
<p>where <span class="math inline">\(z_{t}\)</span> is the demand (level) of the time series at time <span class="math inline">\(t\)</span>, <span class="math inline">\(p_{t}\)</span> is the probability of observing a non-zero demand at time <span class="math inline">\(t\)</span>, and <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> are the smoothing parameters. The forecast is then given by the product.</p>
<p><span class="math display">\[
\hat{y}_{t + 1} = z_{t} p_{t}
\]</span></p>
<p>For many applications, the TSB method is more appropriate than the Crostonâ€™s method, sine the predictions will be updated at eah each time period, even if the demand is zero. Recall that in the Crostonâ€™s method, the forecast is only updated when the demand is non-zero. We will illustrate this at the end of the notebook.</p>
<p>For more details and model comparison, see these two nice references:</p>
<ul>
<li><p><a href="https://www.pmorgan.com.au/tutorials/adaptations-of-crostons-method/">Adaptations of Crostonâ€™s Method</a></p></li>
<li><p><a href="https://nixtlaverse.nixtla.io/statsforecast/docs/models/tsb.html">StatsForecast documentation on the TSB model</a></p></li>
</ul>
<hr />
<div id="prepare-notebook" class="section level2">
<h2>Prepare Notebook</h2>
<pre class="python"><code>from collections.abc import Callable

import arviz as az
import jax.numpy as jnp
import matplotlib.pyplot as plt
import numpyro
import numpyro.distributions as dist
import pandas as pd
import preliz as pz
import xarray as xr
from jax import random
from jaxlib.xla_extension import ArrayImpl
from numpyro.contrib.control_flow import scan
from numpyro.infer import MCMC, NUTS, Predictive
from pydantic import BaseModel, Field
from statsforecast import StatsForecast
from statsforecast.models import TSB
from statsforecast.utils import ConformalIntervals
from tqdm.notebook import tqdm

az.style.use(&quot;arviz-darkgrid&quot;)
plt.rcParams[&quot;figure.figsize&quot;] = [12, 7]
plt.rcParams[&quot;figure.dpi&quot;] = 100
plt.rcParams[&quot;figure.facecolor&quot;] = &quot;white&quot;

numpyro.set_host_device_count(n=4)

rng_key = random.PRNGKey(seed=42)

%load_ext autoreload
%autoreload 2
%config InlineBackend.figure_format = &quot;retina&quot;</code></pre>
<hr />
</div>
<div id="generate-synthetic-data" class="section level2">
<h2>Generate Synthetic Data</h2>
<p>We consider thee same synthetic data as in the previous post <a href="https://juanitorduz.github.io/croston_numpyro/">Crostonâ€™s Method for Intermittent Time Series Forecasting in NumPyro</a>:</p>
<pre class="python"><code>n = 80
lam = 0.3

y = random.poisson(key=rng_key, lam=lam, shape=(n,)).astype(jnp.float32)
t = jnp.arange(y.size)

fig, ax = plt.subplots()
ax.plot(t, y)
ax.set(xlabel=&quot;time&quot;, ylabel=&quot;y&quot;, title=&quot;Time Series Data&quot;)</code></pre>
<center>
<img src="../images/tsb_numpyro_files/tsb_numpyro_4_1.png" style="width: 900px;"/>
</center>
<hr />
</div>
<div id="train-test-split" class="section level2">
<h2>Train-Test Split</h2>
<p>Similarly as before we do a simple train-test split.</p>
<pre class="python"><code>n = y.size

prop_train = 0.85
n_train = round(prop_train * n)

y_train = y[:n_train]
t_train = t[:n_train]

y_test = y[n_train:]
t_test = t[n_train:]

fig, ax = plt.subplots()
ax.plot(t_train, y_train, color=&quot;C0&quot;, label=&quot;train&quot;)
ax.plot(t_test, y_test, color=&quot;C1&quot;, label=&quot;test&quot;)
ax.axvline(x=t_train[-1], c=&quot;black&quot;, linestyle=&quot;--&quot;)
ax.legend()
ax.set(xlabel=&quot;time&quot;, ylabel=&quot;y&quot;, title=&quot;Time Series Data Split&quot;)</code></pre>
<center>
<img src="../images/tsb_numpyro_files/tsb_numpyro_6_1.png" style="width: 900px;"/>
</center>
<hr />
</div>
<div id="tsb-model-with-statsforecast" class="section level2">
<h2>TSB Model with StatsForecast</h2>
<p>Again, we first generate forecasts for the TSB model using the <a href="https://nixtlaverse.nixtla.io/statsforecast/index.html"><code>statsforecast</code></a> package. The model requires the the user to provide the smoothing parameters <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> (which could be estimated via time-slice cross-validation). We choose certain values which will be explained later. For now, just take them as given.</p>
<pre class="python"><code>sf = StatsForecast(
    models=[TSB(alpha_d=0.311, alpha_p=0.57)],
    freq=1,
    n_jobs=-1,
)

train_df = pd.DataFrame({&quot;unique_id&quot;: &quot;a&quot;, &quot;ds&quot;: t_train, &quot;y&quot;: y_train})

sf_forecast = sf.forecast(
    h=y_test.size,
    df=train_df,
    level=[94],
    prediction_intervals=ConformalIntervals(n_windows=5),
)


fig, ax = plt.subplots()
ax.plot(t_train, y_train, color=&quot;C0&quot;, label=&quot;train&quot;)
ax.plot(t_test, y_test, color=&quot;C1&quot;, label=&quot;test&quot;)
ax.fill_between(
    t_test,
    sf_forecast[&quot;TSB-lo-94&quot;],
    sf_forecast[&quot;TSB-hi-94&quot;],
    color=&quot;C2&quot;,
    alpha=0.3,
    label=&quot;$94\\%$ Conformal Interval&quot;,
)
ax.plot(t_test, sf_forecast[&quot;TSB&quot;], color=&quot;C2&quot;, label=&quot;sf_forecast&quot;)
ax.axvline(x=t_train[-1], c=&quot;black&quot;, linestyle=&quot;--&quot;)
ax.legend()
ax.set(xlabel=&quot;time&quot;, ylabel=&quot;y&quot;, title=&quot;Time Series Data Split&quot;)</code></pre>
<center>
<img src="../images/tsb_numpyro_files/tsb_numpyro_8_2.png" style="width: 900px;"/>
</center>
<p>For this specific smoothing parameters the forecast in significantly higher then the Crostonâ€™s method. The reason is that at the end of the training set we have a big spike. As we will see at the end, this forecast will decay as the training set increases with zero values.</p>
<hr />
</div>
<div id="tsb-model-with-numpyro" class="section level2">
<h2>TSB Model with NumPyro</h2>
<p>The NumPyro implementation of the TSB model follows very closely the mathematical specification of the model. As in many other time series model, we rely on the <a href="https://num.pyro.ai/en/stable/primitives.html#scan"><code>scan</code></a> primitive to implement the recursive formulas. For an introduction to the <code>scan</code> primitive, see the first part of the notebook <a href="https://juanitorduz.github.io/exponential_smoothing_numpyro/">Notes on Exponential Smoothing with NumPyro</a>.</p>
<div id="prior-specification" class="section level3">
<h3>Prior Specification</h3>
<p>One key component of the model is the prior distribution for the smoothing parameters. In principle, <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> could be any value between 0 and 1. However, in practice, it is common to restrict the values to be between <span class="math inline">\([0.05, 0.4]\)</span>. I have seen this helps the sampling considerably. For this example, we take the following prior distribution:</p>
<pre class="python"><code>fig, ax = plt.subplots()
pz.Beta(10, 40).plot_pdf(ax=ax)
ax.axvline(x=(10 / (40 + 10)), c=&quot;black&quot;, linestyle=&quot;--&quot;)  # mean
ax.axvline(x=0.05, c=&quot;C3&quot;, linestyle=&quot;:&quot;)  # lower bound
ax.axvline(x=0.4, c=&quot;C3&quot;, linestyle=&quot;:&quot;)  # upper bound
ax.axvspan(xmin=0.05, xmax=0.4, color=&quot;C3&quot;, alpha=0.2)
ax.set(title=&quot;Beta(10, 40) PDF&quot;, xlabel=&quot;$\\alpha$&quot;)</code></pre>
<center>
<img src="../images/tsb_numpyro_files/tsb_numpyro_13_1.png" style="width: 900px;"/>
</center>
</div>
<div id="model-specification" class="section level3">
<h3>Model Specification</h3>
<p>The model is specified is very close to the mathematical formulation. The key component is to implement the transition functions. We follow the description given in the blog post <a href="https://www.pmorgan.com.au/tutorials/adaptations-of-crostons-method/">Adaptations of Crostonâ€™s Method</a>. Note that for the model we trim the zero values at the beginning at the time series. We also need to provide the initial points fot the demand and the probability. We take the first non-zero value for the demand and the mean of the non-zero values for the probability. For the demand is first non-zero demand value while for the probability is the inverse of thee mean of all demand intervals.</p>
<pre class="python"><code>def get_model_args(y_train: ArrayImpl) -&gt; tuple[ArrayImpl, float, float]:
    y_train_trim = jnp.trim_zeros(y_train, trim=&quot;f&quot;)
    p_idx = jnp.flatnonzero(y_train)
    p_diff = jnp.diff(p_idx, prepend=-1)
    z0 = y_train[p_idx[0]]
    p0 = 1 / p_diff.mean()
    return y_train_trim, z0, p0


y_train_trim, z0, p0 = get_model_args(y_train)</code></pre>
<p>Next, we specify the NumPyro model:</p>
<pre class="python"><code>def tsb_model(ts_trim: ArrayImpl, z0: float, p0: float, future: int = 0) -&gt; None:
    t_max_trim = ts_trim.size

    # --- Priors ---

    z_smoothing = numpyro.sample(
        &quot;z_smoothing&quot;, dist.Beta(concentration1=10, concentration0=40)
    )
    p_smoothing = numpyro.sample(
        &quot;p_smoothing&quot;, dist.Beta(concentration1=10, concentration0=40)
    )
    noise = numpyro.sample(&quot;noise&quot;, dist.HalfNormal(scale=1))

    # --- Transition Function ---

    def transition_fn(carry, t):
        z_prev, p_prev = carry

        z_next = jnp.where(
            t &lt; t_max_trim,
            jnp.where(
                ts_trim[t] &gt; 0,
                z_smoothing * ts_trim[t] + (1 - z_smoothing) * z_prev,
                z_prev,
            ),
            z_prev,
        )

        p_next = jnp.where(
            t &lt; t_max_trim,
            jnp.where(
                ts_trim[t] &gt; 0,
                p_smoothing + (1 - p_smoothing) * p_prev,
                (1 - p_smoothing) * p_prev,
            ),
            p_prev,
        )

        mu = z_next * p_next
        pred = numpyro.sample(&quot;pred&quot;, dist.Normal(loc=mu, scale=noise))

        return (z_next, p_next), pred

    # --- Run Scan ---

    with numpyro.handlers.condition(data={&quot;pred&quot;: ts_trim}):
        _, preds = scan(
            transition_fn,
            (z0, p0),
            jnp.arange(t_max_trim + future),
        )

    # --- Forecast ---

    if future &gt; 0:
        return numpyro.deterministic(&quot;ts_forecast&quot;, preds[-future:])
    return None</code></pre>
</div>
<div id="inference" class="section level3">
<h3>Inference</h3>
<p>We now fit the model:</p>
<pre class="python"><code>class InferenceParams(BaseModel):
    num_warmup: int = Field(2_000, ge=1)
    num_samples: int = Field(2_000, ge=1)
    num_chains: int = Field(4, ge=1)


def run_inference(
    rng_key: ArrayImpl,
    model: Callable,
    args: InferenceParams,
    *model_args,
    **nuts_kwargs,
) -&gt; MCMC:
    sampler = NUTS(model, **nuts_kwargs)
    mcmc = MCMC(
        sampler=sampler,
        num_warmup=args.num_warmup,
        num_samples=args.num_samples,
        num_chains=args.num_chains,
    )
    mcmc.run(rng_key, *model_args)
    return mcmc</code></pre>
<pre class="python"><code>inference_params = InferenceParams()

rng_key, rng_subkey = random.split(key=rng_key)
mcmc = run_inference(rng_subkey, tsb_model, inference_params, y_train_trim, z0, p0)

idata = az.from_numpyro(posterior=mcmc)
az.summary(data=idata)</code></pre>
<center>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
mean
</th>
<th>
sd
</th>
<th>
hdi_3%
</th>
<th>
hdi_97%
</th>
<th>
mcse_mean
</th>
<th>
mcse_sd
</th>
<th>
ess_bulk
</th>
<th>
ess_tail
</th>
<th>
r_hat
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
noise
</th>
<td>
0.357
</td>
<td>
0.051
</td>
<td>
0.261
</td>
<td>
0.451
</td>
<td>
0.001
</td>
<td>
0.001
</td>
<td>
3162.0
</td>
<td>
3374.0
</td>
<td>
1.0
</td>
</tr>
<tr>
<th>
p_smoothing
</th>
<td>
0.570
</td>
<td>
0.079
</td>
<td>
0.416
</td>
<td>
0.710
</td>
<td>
0.001
</td>
<td>
0.001
</td>
<td>
3302.0
</td>
<td>
3883.0
</td>
<td>
1.0
</td>
</tr>
<tr>
<th>
z_smoothing
</th>
<td>
0.311
</td>
<td>
0.080
</td>
<td>
0.165
</td>
<td>
0.462
</td>
<td>
0.001
</td>
<td>
0.001
</td>
<td>
3483.0
</td>
<td>
4086.0
</td>
<td>
1.0
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p>All diagnostics look good:</p>
<pre class="python"><code>print(f&quot;&quot;&quot;Divergences: {idata[&quot;sample_stats&quot;][&quot;diverging&quot;].sum().item()}&quot;&quot;&quot;)</code></pre>
<pre><code>Divergences: 0</code></pre>
<pre class="python"><code>axes = az.plot_trace(
    data=idata,
    compact=True,
    kind=&quot;rank_bars&quot;,
    backend_kwargs={&quot;figsize&quot;: (12, 7), &quot;layout&quot;: &quot;constrained&quot;},
)
plt.gcf().suptitle(&quot;TSB Model Trace&quot;, fontsize=16)</code></pre>
<center>
<img src="../images/tsb_numpyro_files/tsb_numpyro_23_1.png" style="width: 1000px;"/>
</center>
<p>It is worth noting that the posterior distribution of the smoothing parameters between the demand size and the probabilities are different.</p>
<p><strong>Remark:</strong> Note that the smoothing parameters chosen in the <code>statsforecast</code> model are precisely the posterior means of the NumPyro model. This is just for the sake of comparison.</p>
</div>
<div id="forecast" class="section level3">
<h3>Forecast</h3>
<p>We now generate the forecast:</p>
<pre class="python"><code>def forecast(
    rng_key: ArrayImpl, model: Callable, samples: dict[str, ArrayImpl], *model_args
) -&gt; dict[str, ArrayImpl]:
    predictive = Predictive(
        model=model,
        posterior_samples=samples,
        return_sites=[&quot;ts_forecast&quot;],
    )
    return predictive(rng_key, *model_args)</code></pre>
<pre class="python"><code>rng_key, rng_subkey = random.split(key=rng_key)
tsb_forecast = forecast(
    rng_subkey, tsb_model, mcmc.get_samples(), y_train_trim, z0, p0, y_test.size
)

posterior_predictive = az.from_numpyro(
    posterior_predictive=tsb_forecast,
    coords={&quot;t&quot;: t_test},
    dims={&quot;ts_forecast&quot;: [&quot;t&quot;]},
)</code></pre>
<p>Letâ€™s see the result and compare it with the <code>statsforecast</code> model:</p>
<pre class="python"><code>fig, ax = plt.subplots()
ax.plot(t_train, y_train, color=&quot;C0&quot;, label=&quot;train&quot;)
ax.plot(t_test, y_test, color=&quot;C1&quot;, label=&quot;test&quot;)
ax.axvline(x=t_train[-1], c=&quot;black&quot;, linestyle=&quot;--&quot;)
az.plot_hdi(
    x=t_test,
    y=posterior_predictive[&quot;posterior_predictive&quot;][&quot;ts_forecast&quot;],
    hdi_prob=0.94,
    color=&quot;C3&quot;,
    fill_kwargs={&quot;alpha&quot;: 0.2, &quot;label&quot;: &quot;$94\\%$ HDI&quot;},
    ax=ax,
)
az.plot_hdi(
    x=t_test,
    y=posterior_predictive[&quot;posterior_predictive&quot;][&quot;ts_forecast&quot;],
    hdi_prob=0.50,
    color=&quot;C3&quot;,
    fill_kwargs={&quot;alpha&quot;: 0.4, &quot;label&quot;: &quot;$50\\%$ HDI&quot;},
    ax=ax,
)
ax.plot(
    t_test,
    posterior_predictive[&quot;posterior_predictive&quot;][&quot;ts_forecast&quot;].mean(
        dim=(&quot;chain&quot;, &quot;draw&quot;)
    ),
    color=&quot;C3&quot;,
    label=&quot;mean forecast&quot;,
)
ax.plot(t_test, sf_forecast[&quot;TSB&quot;], color=&quot;C2&quot;, label=&quot;sf_forecast&quot;)
ax.legend(loc=&quot;upper center&quot;, bbox_to_anchor=(0.5, -0.1), ncol=6)
ax.set(xlabel=&quot;time&quot;, ylabel=&quot;y&quot;, title=&quot;TSB Model Forecast&quot;)</code></pre>
<center>
<img src="../images/tsb_numpyro_files/tsb_numpyro_30_1.png" style="width: 1000px;"/>
</center>
<p>The point forecast matches the <code>statsforecast</code> model. The uncertainty is also very similar of the NumPyro model is narrower than the confidence intervals generated by the <code>statsforecast</code> model using conformal prediction. Once concerning aspect is that the <span class="math inline">\(94\%\)</span> HDI does not contain zero ðŸ¤”.</p>
<hr />
</div>
</div>
<div id="time-slice-cross-validation" class="section level2">
<h2>Time Slice Cross Validation</h2>
<p>Now we deep dive into the TSB property of updating the forecast even when the demand is zero. We write a custom time-slice cross validation to generate one step ahead forecasts.</p>
<pre class="python"><code>def tsb_time_slice_cross_validation(
    rng_key: ArrayImpl, y: ArrayImpl, n_splits: int, inference_params: InferenceParams
) -&gt; xr.Dataset:
    forecast_list = []
    for i in tqdm(range(n_splits)):
        # Prepare data
        y_train = y[: -(n_splits - i)]
        y_train_trim, z0, p0 = get_model_args(y_train)
        # Inference
        rng_key, rng_subkey = random.split(key=rng_key)
        mcmc = run_inference(
            rng_subkey, tsb_model, inference_params, y_train_trim, z0, p0
        )
        # Forecast
        rng_key, rng_subkey = random.split(key=rng_key)
        tsb_forecast = forecast(
            rng_subkey, tsb_model, mcmc.get_samples(), y_train_trim, z0, p0, 1
        )
        forecast_list.append(
            az.from_numpyro(
                posterior_predictive=tsb_forecast,
                coords={&quot;t&quot;: [y_train_trim.size]},
                dims={&quot;ts_forecast&quot;: [&quot;t&quot;]},
            )
        )
    # Concatenate forecasts
    return xr.concat(
        [x[&quot;posterior_predictive&quot;] for x in forecast_list],
        dim=(&quot;t&quot;),
    )</code></pre>
<pre class="python"><code>rng_key, rng_subkey = random.split(key=rng_key)
forecast_cv = tsb_time_slice_cross_validation(
    rng_key=rng_subkey, y=y, n_splits=y_test.size, inference_params=inference_params
)</code></pre>
<p>Letâ€™s see the results:</p>
<pre class="python"><code>fig, ax = plt.subplots()
ax.plot(t_train, y_train, color=&quot;C0&quot;, label=&quot;train&quot;)
ax.plot(t_test, y_test, marker=&quot;o&quot;, markersize=4, color=&quot;C1&quot;, label=&quot;test (cv)&quot;)
ax.axvline(x=t_train[-1], c=&quot;black&quot;, linestyle=&quot;--&quot;)
az.plot_hdi(
    x=t_test,
    y=forecast_cv[&quot;ts_forecast&quot;],
    hdi_prob=0.94,
    color=&quot;C3&quot;,
    fill_kwargs={&quot;alpha&quot;: 0.2, &quot;label&quot;: &quot;$94\\%$ HDI&quot;},
    ax=ax,
)
az.plot_hdi(
    x=t_test,
    y=forecast_cv[&quot;ts_forecast&quot;],
    hdi_prob=0.50,
    color=&quot;C3&quot;,
    fill_kwargs={&quot;alpha&quot;: 0.4, &quot;label&quot;: &quot;$50\\%$ HDI&quot;},
    ax=ax,
)
ax.plot(
    t_test,
    forecast_cv[&quot;ts_forecast&quot;].mean(dim=(&quot;chain&quot;, &quot;draw&quot;)),
    marker=&quot;o&quot;,
    markersize=4,
    color=&quot;C3&quot;,
    label=&quot;mean forecast&quot;,
)
ax.legend(loc=&quot;upper center&quot;, bbox_to_anchor=(0.5, -0.1), ncol=5)
ax.set(
    xlabel=&quot;time&quot;,
    ylabel=&quot;y&quot;,
    title=&quot;TSB Model Forecast - 1 Step Ahead Cross-Validation&quot;,
)</code></pre>
<center>
<img src="../images/tsb_numpyro_files/tsb_numpyro_36_1.png" style="width: 1000px;"/>
</center>
<p>We clearly see the decaying forecast as the training set increases with zero values. We also see how the forecast jumps as we have a non-zero demand. This is a clear advantage of the TSB method over the Crostonâ€™s method for many applications as we do not want to forecast a non-zero for ever in the future even if we see an unreasonable amount of zeros.</p>
</div>

    </div>
  </article>

  


</main>

      <footer class="footer">
        <ul class="footer-links">
          <li>
            <a href="../index.xml" type="application/rss+xml" target="_blank">RSS feed</a>
          </li>
          <li>
            <a href="https://gohugo.io/" class="footer-links-kudos">Made with <img src="../images/hugo-logo.png" alt="Img link to Hugo website" width="22" height="22"></a>
          </li>
        </ul>
      </footer>

    </div>
    



<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>



<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/r.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/yaml.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/dockerfile.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>
<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



    
<script src="../js/math-code.js"></script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'G-5NM5EDH834', 'auto');
	
	ga('send', 'pageview');
}
</script>

  </body>
</html>

