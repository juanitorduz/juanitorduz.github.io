<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python, Numpyro, Forecasting on Dr. Juan Camilo Orduz</title>
    <link>/tags/python-numpyro-forecasting/</link>
    <description>Recent content in Python, Numpyro, Forecasting on Dr. Juan Camilo Orduz</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 03 Oct 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="/tags/python-numpyro-forecasting/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Bayesian Vector Autoregressive Models in NumPyro</title>
      <link>/var_numpyro/</link>
      <pubDate>Fri, 03 Oct 2025 00:00:00 +0000</pubDate>
      <guid>/var_numpyro/</guid>
      <description>&lt;p&gt;In this notebook, we present how to implement and fit Bayesian Vector Autoregressive (VAR) models using &lt;a href=&#34;https://num.pyro.ai/en/stable/&#34;&gt;NumPyro&lt;/a&gt;. We work out three components:&lt;/p&gt;&#xA;&lt;ol style=&#34;list-style-type: decimal&#34;&gt;&#xA;&lt;li&gt;Specifying and fitting the model in NumPyro&lt;/li&gt;&#xA;&lt;li&gt;Using the model to generate forecasts&lt;/li&gt;&#xA;&lt;li&gt;Computing the Impulse Response Functions (IRFs)&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;We compare these three components with the ones obtained using the &lt;code&gt;statsmodels&lt;/code&gt; implementation from the &lt;a href=&#34;https://www.statsmodels.org/stable/vector_ar.html&#34;&gt;Vector Autoregressions tsa.vector_ar&lt;/a&gt; tutorial.&lt;/p&gt;&#xA;&lt;div id=&#34;prepare-notebook&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Prepare Notebook&lt;/h2&gt;&#xA;&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;from functools import partial&#xA;&#xA;import arviz as az&#xA;import jax.numpy as jnp&#xA;import matplotlib.pyplot as plt&#xA;import numpy as np&#xA;import numpyro&#xA;import numpyro.distributions as dist&#xA;import pandas as pd&#xA;import statsmodels.api as sm&#xA;import xarray as xr&#xA;from jax import jit, lax, random, vmap&#xA;from jaxtyping import Array, Float&#xA;from numpyro.contrib.control_flow import scan&#xA;from numpyro.handlers import condition&#xA;from numpyro.infer import MCMC, NUTS&#xA;from statsmodels.tsa.api import VAR&#xA;from statsmodels.tsa.base.datetools import dates_from_str&#xA;&#xA;numpyro.set_host_device_count(n=10)&#xA;&#xA;rng_key = random.PRNGKey(seed=42)&#xA;&#xA;az.style.use(&amp;quot;arviz-darkgrid&amp;quot;)&#xA;plt.rcParams[&amp;quot;figure.figsize&amp;quot;] = [12, 7]&#xA;plt.rcParams[&amp;quot;figure.dpi&amp;quot;] = 100&#xA;plt.rcParams[&amp;quot;figure.facecolor&amp;quot;] = &amp;quot;white&amp;quot;&#xA;&#xA;%load_ext autoreload&#xA;%autoreload 2&#xA;%load_ext jaxtyping&#xA;%jaxtyping.typechecker beartype.beartype&#xA;%config InlineBackend.figure_format = &amp;quot;retina&amp;quot;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;div id=&#34;load-data&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Load Data&lt;/h2&gt;&#xA;&lt;p&gt;We are going to use a dataset from the &lt;a href=&#34;https://www.statsmodels.org/stable/datasets/index.html&#34;&gt;&lt;code&gt;statsmodels&lt;/code&gt; package&lt;/a&gt;. Specifically, we will use the &lt;code&gt;macrodata&lt;/code&gt; dataset from &lt;a href=&#34;https://www.statsmodels.org/stable/vector_ar.html&#34;&gt;Vector Autoregressions tsa.vector_ar&lt;/a&gt; tutorial. For the sake of reproducibility, we will keep the exact same code as in the tutorial.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Electricity Demand Forecast: Dynamic Time-Series Model with Prior Calibration</title>
      <link>/electricity_forecast_with_priors/</link>
      <pubDate>Mon, 07 Oct 2024 00:00:00 +0000</pubDate>
      <guid>/electricity_forecast_with_priors/</guid>
      <description>&lt;p&gt;We present an example of a dynamic forecasting time-series model that incorporates a prior calibration process to estimate the temperature effect on electricity demand. The model is based on the previous example &lt;a href=&#34;https://juanitorduz.github.io/electricity_forecast/&#34;&gt;Electricity Demand Forecast: Dynamic Time-Series Model&lt;/a&gt;. In this second iteration, we borrow the ideas from the Pyro great example &lt;a href=&#34;https://pyro.ai/examples/forecasting_dlm.html&#34;&gt;Forecasting with Dynamic Linear Model (DLM)&lt;/a&gt; where they use a prior calibration process on a local level forecasting model. In our case, we use the same technique with a Hilbert Space Gaussian Process latent component model.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Electricity Demand Forecast: Dynamic Time-Series Model</title>
      <link>/electricity_forecast/</link>
      <pubDate>Sun, 06 Oct 2024 00:00:00 +0000</pubDate>
      <guid>/electricity_forecast/</guid>
      <description>&lt;p&gt;We work out a classical electricity demand forecasting model form the case study &lt;a href=&#34;https://www.tensorflow.org/probability/examples/Structural_Time_Series_Modeling_Case_Studies_Atmospheric_CO2_and_Electricity_Demand&#34;&gt;Structural Time Series Modeling Case Studies: Atmospheric CO2 and Electricity Demand&lt;/a&gt; from the TensorFlow Probability documentation. The idea of this example is to use temperature as a linear covariate to model the electricity demand. In this example, we show how to use a (Hilbert Space Approximation) Gaussian process to model the non-linear relationship between temperature and electricity demand (for an introduction to the topic see &lt;a href=&#34;https://juanitorduz.github.io/hsgp_intro/&#34;&gt;A Conceptual and Practical Introduction to Hilbert Space GPs Approximation Methods&lt;/a&gt;). This technique improves the simple linear model in and out of sample predictions as we aro not using the Gaussian process to extrapolate over time, but rather to model the non-linear relationship between temperature and electricity demand, similarly as how it has done in the example &lt;a href=&#34;https://juanitorduz.github.io/bikes_gp/&#34;&gt;Time-Varying Regression Coefficients via Hilbert Space Gaussian Process Approximation&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>From Pyro to NumPyro: Forecasting Hierarchical Models - Part II</title>
      <link>/numpyro_hierarchical_forecasting_2/</link>
      <pubDate>Sat, 05 Oct 2024 00:00:00 +0000</pubDate>
      <guid>/numpyro_hierarchical_forecasting_2/</guid>
      <description>&lt;p&gt;In this second notebook, we continue working on the NumPyro implementation of the hierarchical forecasting models presented in Pyro‚Äôs forecasting documentation: &lt;a href=&#34;https://pyro.ai/examples/forecasting_iii.html&#34;&gt;Forecasting III: hierarchical models&lt;/a&gt;. In this second part, we extend the model described in the first part &lt;a href=&#34;https://juanitorduz.github.io/numpyro_hierarchical_forecasting_1/&#34;&gt;From Pyro to NumPyro: Forecasting Hierarchical Models - Part I&lt;/a&gt; by adding all stations to the model.&lt;/p&gt;&#xA;&lt;div id=&#34;prepare-notebook&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Prepare Notebook&lt;/h2&gt;&#xA;&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;import arviz as az&#xA;import jax&#xA;import jax.numpy as jnp&#xA;import matplotlib.pyplot as plt&#xA;import numpyro&#xA;import numpyro.distributions as dist&#xA;from jax import random&#xA;from jaxtyping import Array, Float&#xA;from numpyro.contrib.control_flow import scan&#xA;from numpyro.infer import SVI, Predictive, Trace_ELBO&#xA;from numpyro.infer.autoguide import AutoNormal&#xA;from numpyro.infer.reparam import LocScaleReparam&#xA;from pyro.contrib.examples.bart import load_bart_od&#xA;&#xA;az.style.use(&amp;quot;arviz-darkgrid&amp;quot;)&#xA;plt.rcParams[&amp;quot;figure.figsize&amp;quot;] = [12, 7]&#xA;plt.rcParams[&amp;quot;figure.dpi&amp;quot;] = 100&#xA;plt.rcParams[&amp;quot;figure.facecolor&amp;quot;] = &amp;quot;white&amp;quot;&#xA;&#xA;numpyro.set_host_device_count(n=4)&#xA;&#xA;rng_key = random.PRNGKey(seed=42)&#xA;&#xA;%load_ext autoreload&#xA;%autoreload 2&#xA;%load_ext jaxtyping&#xA;%jaxtyping.typechecker beartype.beartype&#xA;%config InlineBackend.figure_format = &amp;quot;retina&amp;quot;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;The autoreload extension is already loaded. To reload it, use:&#xA;  %reload_ext autoreload&#xA;The jaxtyping extension is already loaded. To reload it, use:&#xA;  %reload_ext jaxtyping&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;div id=&#34;read-data&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Read Data&lt;/h2&gt;&#xA;&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;dataset = load_bart_od()&#xA;print(dataset.keys())&#xA;print(dataset[&amp;quot;counts&amp;quot;].shape)&#xA;print(&amp;quot; &amp;quot;.join(dataset[&amp;quot;stations&amp;quot;]))&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;dict_keys([&amp;#39;stations&amp;#39;, &amp;#39;start_date&amp;#39;, &amp;#39;counts&amp;#39;])&#xA;torch.Size([78888, 50, 50])&#xA;12TH 16TH 19TH 24TH ANTC ASHB BALB BAYF BERY CAST CIVC COLM COLS CONC DALY DBRK DELN DUBL EMBR FRMT FTVL GLEN HAYW LAFY LAKE MCAR MLBR MLPT MONT NBRK NCON OAKL ORIN PCTR PHIL PITT PLZA POWL RICH ROCK SANL SBRN SFIA SHAY SSAN UCTY WARM WCRK WDUB WOAK&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;In this second example, we model all the rides from all stations to all other stations.&lt;/p&gt;</description>
    </item>
    <item>
      <title>From Pyro to NumPyro: Forecasting Hierarchical Models - Part I</title>
      <link>/numpyro_hierarchical_forecasting_1/</link>
      <pubDate>Thu, 03 Oct 2024 00:00:00 +0000</pubDate>
      <guid>/numpyro_hierarchical_forecasting_1/</guid>
      <description>&lt;p&gt;In this notebook we provide a NumPyro implementation of the first model presented in the Pyro forecasting documentation: &lt;a href=&#34;https://pyro.ai/examples/forecasting_iii.html&#34;&gt;Forecasting III: hierarchical models&lt;/a&gt;. This model generalizes the local level model with seasonality presented in the univariate example &lt;a href=&#34;https://pyro.ai/examples/forecasting_i.html&#34;&gt;Forecasting I: univariate, heavy tailed&lt;/a&gt; (see &lt;a href=&#34;https://juanitorduz.github.io/numpyro_forecasting-univariate/&#34;&gt;From Pyro to NumPyro: Forecasting a univariate, heavy tailed time series&lt;/a&gt; for the corresponding NumPyro implementation).&lt;/p&gt;&#xA;&lt;p&gt;In this example, we continue working with the BART train ridership &lt;a href=&#34;https://www.bart.gov/about/reports/ridership&#34;&gt;dataset&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;div id=&#34;prepare-notebook&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Prepare Notebook&lt;/h2&gt;&#xA;&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;import arviz as az&#xA;import jax&#xA;import jax.numpy as jnp&#xA;import matplotlib.pyplot as plt&#xA;import numpyro&#xA;import numpyro.distributions as dist&#xA;import torch&#xA;from jax import random&#xA;from jaxtyping import Array, Float&#xA;from numpyro.contrib.control_flow import scan&#xA;from numpyro.infer import SVI, Predictive, Trace_ELBO&#xA;from numpyro.infer.autoguide import AutoNormal&#xA;from numpyro.infer.reparam import LocScaleReparam&#xA;from pyro.contrib.examples.bart import load_bart_od&#xA;from pyro.ops.tensor_utils import periodic_repeat&#xA;&#xA;az.style.use(&amp;quot;arviz-darkgrid&amp;quot;)&#xA;plt.rcParams[&amp;quot;figure.figsize&amp;quot;] = [12, 7]&#xA;plt.rcParams[&amp;quot;figure.dpi&amp;quot;] = 100&#xA;plt.rcParams[&amp;quot;figure.facecolor&amp;quot;] = &amp;quot;white&amp;quot;&#xA;&#xA;numpyro.set_host_device_count(n=4)&#xA;&#xA;rng_key = random.PRNGKey(seed=42)&#xA;&#xA;%load_ext autoreload&#xA;%autoreload 2&#xA;%load_ext jaxtyping&#xA;%jaxtyping.typechecker beartype.beartype&#xA;%config InlineBackend.figure_format = &amp;quot;retina&amp;quot;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;The autoreload extension is already loaded. To reload it, use:&#xA;  %reload_ext autoreload&#xA;The jaxtyping extension is already loaded. To reload it, use:&#xA;  %reload_ext jaxtyping&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;div id=&#34;read-data&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Read Data&lt;/h2&gt;&#xA;&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;dataset = load_bart_od()&#xA;print(dataset.keys())&#xA;print(dataset[&amp;quot;counts&amp;quot;].shape)&#xA;print(&amp;quot; &amp;quot;.join(dataset[&amp;quot;stations&amp;quot;]))&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;dict_keys([&amp;#39;stations&amp;#39;, &amp;#39;start_date&amp;#39;, &amp;#39;counts&amp;#39;])&#xA;torch.Size([78888, 50, 50])&#xA;12TH 16TH 19TH 24TH ANTC ASHB BALB BAYF BERY CAST CIVC COLM COLS CONC DALY DBRK DELN DUBL EMBR FRMT FTVL GLEN HAYW LAFY LAKE MCAR MLBR MLPT MONT NBRK NCON OAKL ORIN PCTR PHIL PITT PLZA POWL RICH ROCK SANL SBRN SFIA SHAY SSAN UCTY WARM WCRK WDUB WOAK&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;For this first model, we just model the rides to Embarcadero station, from each of the other &lt;span class=&#34;math inline&#34;&gt;\(50\)&lt;/span&gt; stations.&lt;/p&gt;</description>
    </item>
    <item>
      <title>From Pyro to NumPyro: Forecasting a univariate, heavy tailed time series</title>
      <link>/numpyro_forecasting-univariate/</link>
      <pubDate>Tue, 01 Oct 2024 00:00:00 +0000</pubDate>
      <guid>/numpyro_forecasting-univariate/</guid>
      <description>&lt;p&gt;In this notebooks we port the &lt;a href=&#34;https://github.com/pyro-ppl/pyro&#34;&gt;&lt;code&gt;Pyro&lt;/code&gt;&lt;/a&gt; forecasting example &lt;a href=&#34;https://pyro.ai/examples/forecasting_i.html&#34;&gt;Forecasting I: univariate, heavy tailed&lt;/a&gt; to &lt;a href=&#34;https://github.com/pyro-ppl/numpyro&#34;&gt;&lt;code&gt;NumPyro&lt;/code&gt;&lt;/a&gt;. The forecasting module in Pyro is fantastic as it provides an easy interface to develop custom forecasting models. It has also many helpful utility functions to generate features and for model evaluation. The purpose of this translation is to dig deeper into the some forecasting components and to show that translating Pyro code to NumPyro is not that hard, even though there are come caveats.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Zero-Inflated TSB Model</title>
      <link>/zi_tsb_numpyro/</link>
      <pubDate>Tue, 20 Feb 2024 00:00:00 +0000</pubDate>
      <guid>/zi_tsb_numpyro/</guid>
      <description>&lt;p&gt;After going through the fundamentals of the &lt;a href=&#34;https://juanitorduz.github.io/tsb_numpyro/&#34;&gt;TSB Method for Intermittent Time Series Forecasting in NumPyro&lt;/a&gt; in the previous notebook, we explore a variation of it that might be useful for certain applications. In a nutshell, we keep the same model structure of the TSB model, but we modify the likelihood function to account for the sparsity of the time series. Concretely, we replace the classic Gaussian likelihood function with a zero-inflated Negative Binomial likelihood function. One clear conceptual advantage of this approach that all our prediction and credible intervals will be non-negative.&lt;/p&gt;</description>
    </item>
    <item>
      <title>TSB Method for Intermittent Time Series Forecasting in NumPyro</title>
      <link>/tsb_numpyro/</link>
      <pubDate>Sat, 17 Feb 2024 00:00:00 +0000</pubDate>
      <guid>/tsb_numpyro/</guid>
      <description>&lt;p&gt;In this notebook we provide a &lt;a href=&#34;http://num.pyro.ai&#34;&gt;&lt;code&gt;NumPyro&lt;/code&gt;&lt;/a&gt; implementation of the TSB (Teunter, Syntetos and Babai) method for forecasting intermittent time series. The TSB method is similar to the &lt;a href=&#34;https://juanitorduz.github.io/croston_numpyro/&#34;&gt;Croston‚Äôs method&lt;/a&gt; in the sense that is constructs two different time series out of the original one and then forecast each of them separately, so that the final forecast is generated by combining the forecasts of the two time series. The main difference between the two methods is that the TSB method uses the demand probability instead of the demand periods. Consequently, let &lt;span class=&#34;math inline&#34;&gt;\(y_{t}\)&lt;/span&gt; denote the input time series then the TSB method is specified by the following equations:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Croston&#39;s Method for Intermittent Time Series Forecasting in NumPyro</title>
      <link>/croston_numpyro/</link>
      <pubDate>Thu, 15 Feb 2024 00:00:00 +0000</pubDate>
      <guid>/croston_numpyro/</guid>
      <description>&lt;p&gt;In this notebook, we will implement Croston‚Äôs method for intermittent demand forecasting using &lt;a href=&#34;https://github.com/pyro-ppl/numpyro&#34;&gt;&lt;code&gt;NumPyro&lt;/code&gt;&lt;/a&gt;. Croston‚Äôs method is a popular forecasting method for intermittent demand data, which is characterized by a large number of zero values. The method is based on the idea of separating the demand size and the demand interval, and then forecasting them separately using simple exponential smoothing. We therefore can leverage on top of the previous post &lt;a href=&#34;https://juanitorduz.github.io/exponential_smoothing_numpyro/&#34;&gt;Notes on Exponential Smoothing with NumPyro&lt;/a&gt;. Once we have the forecasts for the demand size and the demand interval, we can combine them to get the final forecast. For a succinct explanation of Croston‚Äôs method, I recommend the following blog post: &lt;a href=&#34;https://www.pmorgan.com.au/tutorials/crostons-method/&#34; class=&#34;uri&#34;&gt;https://www.pmorgan.com.au/tutorials/crostons-method/&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Notes on an ARMA(1, 1) Model with NumPyro</title>
      <link>/arma_numpyro/</link>
      <pubDate>Tue, 13 Feb 2024 00:00:00 +0000</pubDate>
      <guid>/arma_numpyro/</guid>
      <description>&lt;p&gt;This are some notes on how to implement an ARMA(1, 1) model using &lt;a href=&#34;https://github.com/pyro-ppl/numpyro&#34;&gt;&lt;code&gt;NumPyro&lt;/code&gt;&lt;/a&gt; for time series forecasting. The ARMA(1, 1) model is given by&lt;/p&gt;&#xA;&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[y_t = \mu + \phi y_{t-1} + \theta \varepsilon_{t-1} + \varepsilon_t\]&lt;/span&gt;&lt;/p&gt;&#xA;&lt;p&gt;where &lt;span class=&#34;math inline&#34;&gt;\(y_t\)&lt;/span&gt; is the time series, &lt;span class=&#34;math inline&#34;&gt;\(\mu\)&lt;/span&gt; is the mean, &lt;span class=&#34;math inline&#34;&gt;\(\phi\)&lt;/span&gt; is the autoregressive parameter, &lt;span class=&#34;math inline&#34;&gt;\(\theta\)&lt;/span&gt; is the moving average parameter, and &lt;span class=&#34;math inline&#34;&gt;\(\varepsilon_t\)&lt;/span&gt; is a white noise process with mean zero and variance &lt;span class=&#34;math inline&#34;&gt;\(\sigma^2\)&lt;/span&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Notes on Exponential Smoothing with NumPyro</title>
      <link>/exponential_smoothing_numpyro/</link>
      <pubDate>Sun, 11 Feb 2024 00:00:00 +0000</pubDate>
      <guid>/exponential_smoothing_numpyro/</guid>
      <description>&lt;p&gt;This notebook serves as personal notes on &lt;a href=&#34;https://num.pyro.ai/en/stable/index.html&#34;&gt;&lt;code&gt;NumPyro&lt;/code&gt;&lt;/a&gt;‚Äôs implementation of the classic &lt;a href=&#34;https://en.wikipedia.org/wiki/Exponential_smoothing&#34;&gt;exponential smoothing&lt;/a&gt; forecasting method. I use &lt;a href=&#34;https://num.pyro.ai/en/stable/examples/holt_winters.html&#34;&gt;Example: Holt-Winters Exponential Smoothing&lt;/a&gt;. The strategy is to go into the nitty-gritty details of the code presented in the example from the documentation: &lt;a href=&#34;https://num.pyro.ai/en/stable/examples/holt_winters.html&#34;&gt;‚ÄúExample: Holt-Winters Exponential Smoothing‚Äù&lt;/a&gt;. In particular, I want to understand the auto-regressive components using the &lt;a href=&#34;https://num.pyro.ai/en/stable/primitives.html#scan&#34;&gt;&lt;code&gt;scan&lt;/code&gt;&lt;/a&gt; function, which always confuses me üòÖ. After reproducing the example from the documentation, we go a step further and extend the algorithm to include a damped trend.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
