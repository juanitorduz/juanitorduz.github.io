<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>python, numpyro, forecasting on Dr. Juan Camilo Orduz</title>
    <link>/tags/python-numpyro-forecasting/</link>
    <description>Recent content in python, numpyro, forecasting on Dr. Juan Camilo Orduz</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 06 Oct 2024 00:00:00 +0000</lastBuildDate><atom:link href="/tags/python-numpyro-forecasting/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Electricity Demand Forecast: Dynamic Time-Series Model</title>
      <link>/electricity_forecast/</link>
      <pubDate>Sun, 06 Oct 2024 00:00:00 +0000</pubDate>
      
      <guid>/electricity_forecast/</guid>
      <description>We work out a classical electricity demand forecasting model form the case study Structural Time Series Modeling Case Studies: Atmospheric CO2 and Electricity Demand from the TensorFlow Probability documentation. The idea of this example is to use temperature as a linear covariate to model the electricity demand. In this example, we show how to use a (Hilbert Space Approximation) Gaussian process to model the non-linear relationship between temperature and electricity demand (for an introduction to the topic see A Conceptual and Practical Introduction to Hilbert Space GPs Approximation Methods).</description>
    </item>
    
    <item>
      <title>From Pyro to NumPyro: Forecasting Hierarchical Models - Part II</title>
      <link>/numpyro_hierarchical_forecasting_2/</link>
      <pubDate>Sat, 05 Oct 2024 00:00:00 +0000</pubDate>
      
      <guid>/numpyro_hierarchical_forecasting_2/</guid>
      <description>In this second notebook, we continue working on the NumPyro implementation of the hierarchical forecasting models presented in Pyro‚Äôs forecasting documentation: Forecasting III: hierarchical models. In this second part, we extend the model described in the first part From Pyro to NumPyro: Forecasting Hierarchical Models - Part I by adding all stations to the model.
Prepare Notebook import arviz as az import jax import jax.numpy as jnp import matplotlib.pyplot as plt import numpyro import numpyro.</description>
    </item>
    
    <item>
      <title>From Pyro to NumPyro: Forecasting Hierarchical Models - Part I</title>
      <link>/numpyro_hierarchical_forecasting_1/</link>
      <pubDate>Thu, 03 Oct 2024 00:00:00 +0000</pubDate>
      
      <guid>/numpyro_hierarchical_forecasting_1/</guid>
      <description>In this notebook we provide a NumPyro implementation of the first model presented in the Pyro forecasting documentation: Forecasting III: hierarchical models. This model generalizes the local level model with seasonality presented in the univariate example Forecasting I: univariate, heavy tailed (see From Pyro to NumPyro: Forecasting a univariate, heavy tailed time series for the corresponding NumPyro implementation).
In this example, we continue working with the BART train ridership dataset.</description>
    </item>
    
    <item>
      <title>From Pyro to NumPyro: Forecasting a univariate, heavy tailed time series</title>
      <link>/numpyro_forecasting-univariate/</link>
      <pubDate>Tue, 01 Oct 2024 00:00:00 +0000</pubDate>
      
      <guid>/numpyro_forecasting-univariate/</guid>
      <description>In this notebooks we port the Pyro forecasting example Forecasting I: univariate, heavy tailed to NumPyro. The forecasting module in Pyro is fantastic as it provides an easy interface to develop custom forecasting models. It has also many helpful utility functions to generate features and for model evaluation. The purpose of this translation is to dig deeper into the some forecasting components and to show that translating Pyro code to NumPyro is not that hard, even though there are come caveats.</description>
    </item>
    
    <item>
      <title>Zero-Inflated TSB Model</title>
      <link>/zi_tsb_numpyro/</link>
      <pubDate>Tue, 20 Feb 2024 00:00:00 +0000</pubDate>
      
      <guid>/zi_tsb_numpyro/</guid>
      <description>After going through the fundamentals of the TSB Method for Intermittent Time Series Forecasting in NumPyro in the previous notebook, we explore a variation of it that might be useful for certain applications. In a nutshell, we keep the same model structure of the TSB model, but we modify the likelihood function to account for the sparsity of the time series. Concretely, we replace the classic Gaussian likelihood function with a zero-inflated Negative Binomial likelihood function.</description>
    </item>
    
    <item>
      <title>TSB Method for Intermittent Time Series Forecasting in NumPyro</title>
      <link>/tsb_numpyro/</link>
      <pubDate>Sat, 17 Feb 2024 00:00:00 +0000</pubDate>
      
      <guid>/tsb_numpyro/</guid>
      <description>In this notebook we provide a NumPyro implementation of the TSB (Teunter, Syntetos and Babai) method for forecasting intermittent time series. The TSB method is similar to the Croston‚Äôs method in the sense that is constructs two different time series out of the original one and then forecast each of them separately, so that the final forecast is generated by combining the forecasts of the two time series. The main difference between the two methods is that the TSB method uses the demand probability instead of the demand periods.</description>
    </item>
    
    <item>
      <title>Croston&#39;s Method for Intermittent Time Series Forecasting in NumPyro</title>
      <link>/croston_numpyro/</link>
      <pubDate>Thu, 15 Feb 2024 00:00:00 +0000</pubDate>
      
      <guid>/croston_numpyro/</guid>
      <description>In this notebook, we will implement Croston‚Äôs method for intermittent demand forecasting using NumPyro. Croston‚Äôs method is a popular forecasting method for intermittent demand data, which is characterized by a large number of zero values. The method is based on the idea of separating the demand size and the demand interval, and then forecasting them separately using simple exponential smoothing. We therefore can leverage on top of the previous post Notes on Exponential Smoothing with NumPyro.</description>
    </item>
    
    <item>
      <title>Notes on an ARMA(1, 1) Model with NumPyro</title>
      <link>/arma_numpyro/</link>
      <pubDate>Tue, 13 Feb 2024 00:00:00 +0000</pubDate>
      
      <guid>/arma_numpyro/</guid>
      <description>This are some notes on how to implement an ARMA(1, 1) model using NumPyro for time series forecasting. The ARMA(1, 1) model is given by
\[y_t = \mu + \phi y_{t-1} + \theta \varepsilon_{t-1} + \varepsilon_t\]
where \(y_t\) is the time series, \(\mu\) is the mean, \(\phi\) is the autoregressive parameter, \(\theta\) is the moving average parameter, and \(\varepsilon_t\) is a white noise process with mean zero and variance \(\sigma^2\).</description>
    </item>
    
    <item>
      <title>Notes on Exponential Smoothing with NumPyro</title>
      <link>/exponential_smoothing_numpyro/</link>
      <pubDate>Sun, 11 Feb 2024 00:00:00 +0000</pubDate>
      
      <guid>/exponential_smoothing_numpyro/</guid>
      <description>This notebook serves as personal notes on NumPyro‚Äôs implementation of the classic exponential smoothing forecasting method. I use Example: Holt-Winters Exponential Smoothing. The strategy is to go into the nitty-gritty details of the code presented in the example from the documentation: ‚ÄúExample: Holt-Winters Exponential Smoothing‚Äù. In particular, I want to understand the auto-regressive components using the scan function, which always confuses me üòÖ. After reproducing the example from the documentation, we go a step further and extend the algorithm to include a damped trend.</description>
    </item>
    
  </channel>
</rss>
