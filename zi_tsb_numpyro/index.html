<!DOCTYPE html>
<html lang="en-us">
  <head>
    <script defer src="https://use.fontawesome.com/releases/v6.5.1/js/all.js"></script>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-5NM5EDH834"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-5NM5EDH834');
</script>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Hugo 0.152.2">


<title>Zero-Inflated TSB Model - Dr. Juan Camilo Orduz</title>
<meta property="og:title" content="Zero-Inflated TSB Model - Dr. Juan Camilo Orduz">


  <link href='../images/favicon.ico' rel='icon' type='image/x-icon'/>



  








<link href='//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css' rel='stylesheet' type='text/css' />



<link rel="stylesheet" href="../css/fonts.css" media="all">
<link rel="stylesheet" href="../css/main.css" media="all">



  </head>
  <body>
    <div class="wrapper">
      <header class="header">
        <nav class="nav">
  <a href="../" class="nav-logo">
    <img src="../images/tattoo_logo.jpg"
         width="50"
         height="50"
         alt="Logo">
  </a>

  <ul class="nav-links">
    
    <li><a href="../about/"> About</a></li>
    
    <li><a href="../talks/"> Talks</a></li>
    
    <li><a href="https://github.com/juanitorduz"><i class='fab fa-github fa-2x'></i>  </a></li>
    
    <li><a href="https://www.linkedin.com/in/juanitorduz/"><i class='fab fa-linkedin fa-2x' style='color:#0a66c2;'></i>  </a></li>
    
    <li><a href="https://ko-fi.com/juanitorduz"><i class='fa-solid fa-mug-hot fa-2x' style='color:#FF5E5B;'></i>  </a></li>
    
  </ul>
</nav>

      </header>


<main class="content" role="main">

  <article class="article">
    
    <span class="article-duration">9 min read</span>
    

    <h1 class="article-title">Zero-Inflated TSB Model</h1>

    
    <span class="article-date">2024-02-20</span>
    

    <div class="article-content">
      


<p>After going through the fundamentals of the <a href="https://juanitorduz.github.io/tsb_numpyro/">TSB Method for Intermittent Time Series Forecasting in NumPyro</a> in the previous notebook, we explore a variation of it that might be useful for certain applications. In a nutshell, we keep the same model structure of the TSB model, but we modify the likelihood function to account for the sparsity of the time series. Concretely, we replace the classic Gaussian likelihood function with a zero-inflated Negative Binomial likelihood function. One clear conceptual advantage of this approach that all our prediction and credible intervals will be non-negative.</p>
<hr />
<div id="model-specification" class="section level2">
<h2>Model Specification</h2>
<p>Recall that the <strong>TSB method </strong>is similar to the <a href="https://juanitorduz.github.io/croston_numpyro/">Croston’s method</a> in the sense that is constructs two different time series out of the original one and then forecast each of them separately, so that the final forecast is generated by combining the forecasts of the two time series. The main difference between the two methods is that the TSB method uses the demand probability instead of the demand periods. Let <span class="math inline">\(y_{t}\)</span> denote the input time series then the TSB method is specified by the following equations:</p>
<p>If <span class="math inline">\(y_{t} &gt; 0\)</span>, then</p>
<p><span class="math display">\[
\begin{align*}
z_{t + 1} &amp; = \alpha y_{t} + (1 - \alpha) z_{t} \\
p_{t + 1} &amp; = \beta + (1 - \beta) p_{t}
\end{align*}
\]</span></p>
<p>If <span class="math inline">\(y_{t} = 0\)</span>, then</p>
<p><span class="math display">\[
\begin{align*}
z_{t + 1} &amp; = z_{t} \\
p_{t + 1} &amp; = (1 - \beta) p_{t}
\end{align*}
\]</span></p>
<p>where <span class="math inline">\(z_{t}\)</span> is the demand (level) of the time series at time <span class="math inline">\(t\)</span>, <span class="math inline">\(p_{t}\)</span> is the probability of observing a non-zero demand at time <span class="math inline">\(t\)</span>, and <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> are the smoothing parameters. The forecast is then given by the product.</p>
<p><span class="math display">\[
\hat{y}_{t + 1} = z_{t} p_{t}
\]</span></p>
<p>Well, to be more precise, one generate predictions by sampling from the distribution:</p>
<p><span class="math display">\[
\hat{y}_{t + 1} \sim \text{Normal}(z_{t} p_{t}, \sigma^2)
\]</span></p>
<p>The idea behind the zero-inflated TSB model is to replace the Gaussian likelihood function with a <a href="https://num.pyro.ai/en/stable/distributions.html#zeroinflatednegativebinomial2">Zero-Inflated Negative Binomial</a> likelihood function.</p>
<p><span class="math display">\[
\hat{y}_{t + 1} \sim \text{ZeroInflatedNegativeBinomial}(\text{mean}=z_{t}, \text{concentration}=\sigma, \text{gate}=1 - p_{t}),
\]</span></p>
<p>where the parameter <code>gate</code> is the probability of observing a zero demand at time <span class="math inline">\(t\)</span>. Hence, it is natural to consider <span class="math inline">\(1 - p_{t}\)</span>. Note that we use <span class="math inline">\(z_{t}\)</span> as the man since we account for the demand probability in the <code>gate</code> parameter.</p>
<hr />
</div>
<div id="prepare-notebook" class="section level2">
<h2>Prepare Notebook</h2>
<pre class="python"><code>from collections.abc import Callable

import arviz as az
import jax.numpy as jnp
import matplotlib.pyplot as plt
import numpyro
import numpyro.distributions as dist
import pandas as pd
import preliz as pz
import xarray as xr
from jax import random
from jaxlib.xla_extension import ArrayImpl
from numpyro.contrib.control_flow import scan
from numpyro.infer import MCMC, NUTS, Predictive
from pydantic import BaseModel, Field
from statsforecast import StatsForecast
from statsforecast.models import TSB, CrostonOptimized
from statsforecast.utils import ConformalIntervals
from tqdm.notebook import tqdm

az.style.use(&quot;arviz-darkgrid&quot;)
plt.rcParams[&quot;figure.figsize&quot;] = [12, 7]
plt.rcParams[&quot;figure.dpi&quot;] = 100
plt.rcParams[&quot;figure.facecolor&quot;] = &quot;white&quot;

numpyro.set_host_device_count(n=4)

rng_key = random.PRNGKey(seed=42)

%load_ext autoreload
%autoreload 2
%config InlineBackend.figure_format = &quot;retina&quot;</code></pre>
<hr />
</div>
<div id="generate-synthetic-data" class="section level2">
<h2>Generate Synthetic Data</h2>
<p>We consider thee same synthetic data as in the previous post <a href="https://juanitorduz.github.io/tsb_numpyro/">TSB Method for Intermittent Time Series Forecasting in NumPyro</a>:</p>
<pre class="python"><code>n = 80
lam = 0.3

y = random.poisson(key=rng_key, lam=lam, shape=(n,)).astype(jnp.float32)
t = jnp.arange(y.size)

fig, ax = plt.subplots()
ax.plot(t, y)
ax.set(xlabel=&quot;time&quot;, ylabel=&quot;y&quot;, title=&quot;Time Series Data&quot;)</code></pre>
<center>
<img src="../images/zi_tsb_numpyro_files/zi_tsb_numpyro_4_1.png" style="width: 900px;"/>
</center>
<hr />
</div>
<div id="train-test-split" class="section level2">
<h2>Train-Test Split</h2>
<p>Similarly as before we do a simple train-test split.</p>
<pre class="python"><code>n = y.size

prop_train = 0.85
n_train = round(prop_train * n)

y_train = y[:n_train]
t_train = t[:n_train]

y_test = y[n_train:]
t_test = t[n_train:]

fig, ax = plt.subplots()
ax.plot(t_train, y_train, color=&quot;C0&quot;, label=&quot;train&quot;)
ax.plot(t_test, y_test, color=&quot;C1&quot;, label=&quot;test&quot;)
ax.axvline(x=t_train[-1], c=&quot;black&quot;, linestyle=&quot;--&quot;)
ax.legend()
ax.set(xlabel=&quot;time&quot;, ylabel=&quot;y&quot;, title=&quot;Time Series Data Split&quot;)</code></pre>
<center>
<img src="../images/zi_tsb_numpyro_files/zi_tsb_numpyro_6_1.png" style="width: 900px;"/>
</center>
<hr />
</div>
<div id="croston-and-tsb-model-with-statsforecast" class="section level2">
<h2>Croston and TSB Model with StatsForecast</h2>
<p>For the sake of comparison, let’s start by looking into the results of the <a href="https://nixtlaverse.nixtla.io/statsforecast/index.html"><code>statsforecast</code></a> package. We keep the parameters from the previous posts.</p>
<pre class="python"><code>sf = StatsForecast(
    models=[CrostonOptimized(), TSB(alpha_d=0.311, alpha_p=0.57)],
    freq=1,
    n_jobs=-1,
)

train_df = pd.DataFrame({&quot;unique_id&quot;: &quot;a&quot;, &quot;ds&quot;: t_train, &quot;y&quot;: y_train})

sf_forecast = sf.forecast(
    h=y_test.size,
    df=train_df,
    level=[94],
    prediction_intervals=ConformalIntervals(n_windows=5),
)

fig, ax = plt.subplots()
ax.plot(t_train, y_train, color=&quot;C0&quot;, label=&quot;train&quot;)
ax.plot(t_test, y_test, color=&quot;C1&quot;, label=&quot;test&quot;)
ax.fill_between(
    t_test,
    sf_forecast[&quot;TSB-lo-94&quot;],
    sf_forecast[&quot;TSB-hi-94&quot;],
    color=&quot;C2&quot;,
    alpha=0.3,
    label=&quot;TSB $94\\%$ Conformal Interval&quot;,
)
ax.plot(t_test, sf_forecast[&quot;TSB&quot;], color=&quot;C2&quot;, label=&quot;TSB mean forecast&quot;)
ax.fill_between(
    t_test,
    sf_forecast[&quot;CrostonOptimized-lo-94&quot;],
    sf_forecast[&quot;CrostonOptimized-hi-94&quot;],
    color=&quot;C4&quot;,
    alpha=0.3,
    label=&quot;Croston $94\\%$ Conformal Interval&quot;,
)
ax.plot(
    t_test, sf_forecast[&quot;CrostonOptimized&quot;], color=&quot;C4&quot;, label=&quot;sCroston mean forecast&quot;
)
ax.axvline(x=t_train[-1], c=&quot;black&quot;, linestyle=&quot;--&quot;)
ax.legend(loc=&quot;upper center&quot;, bbox_to_anchor=(0.5, -0.1), ncol=3)
ax.set(xlabel=&quot;time&quot;, ylabel=&quot;y&quot;, title=&quot;Time Series Data Split&quot;)</code></pre>
<center>
<img src="../images/zi_tsb_numpyro_files/zi_tsb_numpyro_8_2.png" style="width: 1000px;"/>
</center>
<p>As explained in the previous post, for this specific smoothing parameters the forecast in significantly higher then the Croston’s method. The reason is that at the end of the training set we have a big spike.</p>
<hr />
</div>
<div id="zero-inflated-tsb-model-with-numpyro" class="section level2">
<h2>Zero-Inflated TSB Model with NumPyro</h2>
<p>As described in the introduction, the structure of the Zero-Inflated TSB model is thee same as in the one presented in <a href="https://juanitorduz.github.io/tsb_numpyro/">TSB Method for Intermittent Time Series Forecasting in NumPyro</a>. We just change the likelihood structure.</p>
<div id="prior-specification" class="section level3">
<h3>Prior Specification</h3>
<p>For this specific case, we need to constrain the priors a bit by making the support of the Beta distribution close to <span class="math inline">\([0.05, 0.3]\)</span>.</p>
<pre class="python"><code>fig, ax = plt.subplots()
pz.Beta(10, 60).plot_pdf(ax=ax)
ax.axvline(x=(10 / (60 + 10)), c=&quot;black&quot;, linestyle=&quot;--&quot;)  # mean
ax.axvline(x=0.05, c=&quot;C3&quot;, linestyle=&quot;:&quot;)  # lower bound
ax.axvline(x=0.3, c=&quot;C3&quot;, linestyle=&quot;:&quot;)  # upper bound
ax.axvspan(xmin=0.05, xmax=0.3, color=&quot;C3&quot;, alpha=0.2)
ax.set(title=&quot;Beta(10, 60) PDF&quot;, xlabel=&quot;$\\alpha$&quot;)</code></pre>
<center>
<img src="../images/zi_tsb_numpyro_files/zi_tsb_numpyro_13_1.png" style="width: 900px;"/>
</center>
</div>
<div id="model-specification-1" class="section level3">
<h3>Model Specification</h3>
<p>We now specify the model using the Zero-Inflated Negative Binomial likelihood function.</p>
<pre class="python"><code>def zi_tsb_model(ts_trim: ArrayImpl, z0: float, p0: float, future: int = 0) -&gt; None:
    t_max_trim = ts_trim.size

    # --- Priors ---

    z_smoothing = numpyro.sample(
        &quot;z_smoothing&quot;, dist.Beta(concentration1=10, concentration0=60)
    )
    p_smoothing = numpyro.sample(
        &quot;p_smoothing&quot;, dist.Beta(concentration1=10, concentration0=60)
    )
    concentration = numpyro.sample(&quot;concentration&quot;, dist.HalfNormal(scale=1))

    # --- Transition Function ---

    def transition_fn(carry, t):
        z_prev, p_prev = carry

        z_next = jnp.where(
            t &lt; t_max_trim,
            jnp.where(
                ts_trim[t] &gt; 0,
                z_smoothing * ts_trim[t] + (1 - z_smoothing) * z_prev,
                z_prev,
            ),
            z_prev,
        )

        p_next = jnp.where(
            t &lt; t_max_trim,
            jnp.where(
                ts_trim[t] &gt; 0,
                p_smoothing + (1 - p_smoothing) * p_prev,
                (1 - p_smoothing) * p_prev,
            ),
            p_prev,
        )

        mu = z_next
        gate = 1 - p_next
        pred = numpyro.sample(
            &quot;pred&quot;,
            dist.ZeroInflatedNegativeBinomial2(
                mean=mu, concentration=concentration, gate=gate
            ),
        )

        return (z_next, p_next), pred

    # --- Run Scan ---

    with numpyro.handlers.condition(data={&quot;pred&quot;: ts_trim}):
        _, preds = scan(
            transition_fn,
            (z0, p0),
            jnp.arange(t_max_trim + future),
        )

    # --- Forecast ---

    if future &gt; 0:
        return numpyro.deterministic(&quot;ts_forecast&quot;, preds[-future:])
    return None</code></pre>
</div>
<div id="inference" class="section level3">
<h3>Inference</h3>
<p>We now fit the model:</p>
<pre class="python"><code>def get_model_args(y_train: ArrayImpl) -&gt; tuple[ArrayImpl, float, float]:
    y_train_trim = jnp.trim_zeros(y_train, trim=&quot;f&quot;)
    p_idx = jnp.flatnonzero(y_train)
    p_diff = jnp.diff(p_idx, prepend=-1)
    z0 = y_train[p_idx[0]]
    p0 = 1 / p_diff.mean()
    return y_train_trim, z0, p0


class InferenceParams(BaseModel):
    num_warmup: int = Field(2_000, ge=1)
    num_samples: int = Field(2_000, ge=1)
    num_chains: int = Field(4, ge=1)


def run_inference(
    rng_key: ArrayImpl,
    model: Callable,
    args: InferenceParams,
    *model_args,
    **nuts_kwargs,
) -&gt; MCMC:
    sampler = NUTS(model, **nuts_kwargs)
    mcmc = MCMC(
        sampler=sampler,
        num_warmup=args.num_warmup,
        num_samples=args.num_samples,
        num_chains=args.num_chains,
    )
    mcmc.run(rng_key, *model_args)
    return mcmc


y_train_trim, z0, p0 = get_model_args(y_train)

inference_params = InferenceParams()

rng_key, rng_subkey = random.split(key=rng_key)
mcmc = run_inference(
    rng_subkey,
    zi_tsb_model,
    inference_params,
    y_train_trim,
    z0,
    p0,
)

idata = az.from_numpyro(posterior=mcmc)

az.summary(data=idata)</code></pre>
<center>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
mean
</th>
<th>
sd
</th>
<th>
hdi_3%
</th>
<th>
hdi_97%
</th>
<th>
mcse_mean
</th>
<th>
mcse_sd
</th>
<th>
ess_bulk
</th>
<th>
ess_tail
</th>
<th>
r_hat
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
concentration
</th>
<td>
1.956
</td>
<td>
0.592
</td>
<td>
0.903
</td>
<td>
3.054
</td>
<td>
0.007
</td>
<td>
0.005
</td>
<td>
6240.0
</td>
<td>
4385.0
</td>
<td>
1.0
</td>
</tr>
<tr>
<th>
p_smoothing
</th>
<td>
0.245
</td>
<td>
0.053
</td>
<td>
0.147
</td>
<td>
0.345
</td>
<td>
0.001
</td>
<td>
0.000
</td>
<td>
7912.0
</td>
<td>
5831.0
</td>
<td>
1.0
</td>
</tr>
<tr>
<th>
z_smoothing
</th>
<td>
0.144
</td>
<td>
0.041
</td>
<td>
0.071
</td>
<td>
0.223
</td>
<td>
0.000
</td>
<td>
0.000
</td>
<td>
8171.0
</td>
<td>
5759.0
</td>
<td>
1.0
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p>All diagnostics look good:</p>
<pre class="python"><code>print(f&quot;&quot;&quot;Divergences: {idata[&quot;sample_stats&quot;][&quot;diverging&quot;].sum().item()}&quot;&quot;&quot;)</code></pre>
<pre><code>Divergences: 0</code></pre>
<pre class="python"><code>axes = az.plot_trace(
    data=idata,
    compact=True,
    kind=&quot;rank_bars&quot;,
    backend_kwargs={&quot;figsize&quot;: (12, 7), &quot;layout&quot;: &quot;constrained&quot;},
)
plt.gcf().suptitle(&quot;Zero-Inflated TSB Model Trace&quot;, fontsize=16)</code></pre>
<center>
<img src="../images/zi_tsb_numpyro_files/zi_tsb_numpyro_21_1.png" style="width: 1000px;"/>
</center>
</div>
<div id="forecast" class="section level3">
<h3>Forecast</h3>
<p>We now generate the forecast:</p>
<pre class="python"><code>def forecast(
    rng_key: ArrayImpl, model: Callable, samples: dict[str, ArrayImpl], *model_args
) -&gt; dict[str, ArrayImpl]:
    predictive = Predictive(
        model=model,
        posterior_samples=samples,
        return_sites=[&quot;ts_forecast&quot;],
    )
    return predictive(rng_key, *model_args)


rng_key, rng_subkey = random.split(key=rng_key)
tsb_forecast = forecast(
    rng_subkey,
    zi_tsb_model,
    mcmc.get_samples(),
    y_train_trim.astype(jnp.int32),
    z0,
    p0,
    y_test.size,
)

posterior_predictive = az.from_numpyro(
    posterior_predictive=tsb_forecast,
    coords={&quot;t&quot;: t_test},
    dims={&quot;ts_forecast&quot;: [&quot;t&quot;]},
)</code></pre>
<p>Let’s see the forecast and compare it with the <code>statsforecast</code> models:</p>
<pre class="python"><code>fig, ax = plt.subplots()
ax.plot(t_train, y_train, color=&quot;C0&quot;, label=&quot;train&quot;)
ax.plot(t_test, y_test, color=&quot;C1&quot;, label=&quot;test&quot;)
ax.axvline(x=t_train[-1], c=&quot;black&quot;, linestyle=&quot;--&quot;)
az.plot_hdi(
    x=t_test,
    y=posterior_predictive[&quot;posterior_predictive&quot;][&quot;ts_forecast&quot;],
    hdi_prob=0.94,
    color=&quot;C3&quot;,
    smooth=False,
    fill_kwargs={&quot;alpha&quot;: 0.1, &quot;label&quot;: &quot;$94\\%$ HDI&quot;},
    ax=ax,
)
ax.plot(
    t_test,
    posterior_predictive[&quot;posterior_predictive&quot;][&quot;ts_forecast&quot;].mean(
        dim=(&quot;chain&quot;, &quot;draw&quot;)
    ),
    color=&quot;C3&quot;,
    label=&quot;mean forecast&quot;,
)
ax.plot(t_test, sf_forecast[&quot;TSB&quot;], color=&quot;C2&quot;, label=&quot;TSB [statsforecast]&quot;)
ax.plot(
    t_test,
    sf_forecast[&quot;CrostonOptimized&quot;],
    color=&quot;C4&quot;,
    label=&quot;CrostonOptimized [statsforecast]&quot;,
)
ax.legend(loc=&quot;upper center&quot;, bbox_to_anchor=(0.5, -0.1), ncol=4)
ax.set(xlabel=&quot;time&quot;, ylabel=&quot;y&quot;, title=&quot;Zero-Inflated TSB Model Forecast&quot;)</code></pre>
<center>
<img src="../images/zi_tsb_numpyro_files/zi_tsb_numpyro_25_1.png" style="width: 900px;"/>
</center>
<p>Observes that the mean forecast lies in between the Croston and TSB forecast.</p>
<p>We can zoom in into the one-step ahead forecast posterior distribution:</p>
<pre class="python"><code>fig, ax = plt.subplots(figsize=(10, 6))
az.plot_posterior(
    data=posterior_predictive[&quot;posterior_predictive&quot;][&quot;ts_forecast&quot;].sel(t=n_train),
    ax=ax,
)
ax.set(
    title=&quot;Zero-Inflated TSB Model Forecast Posterior&quot;,
    xlabel=&quot;y&quot;,
    ylabel=&quot;Density&quot;,
)</code></pre>
<center>
<img src="../images/zi_tsb_numpyro_files/zi_tsb_numpyro_27_1.png" style="width: 1000px;"/>
</center>
<p>Note that, in contrast to the Gaussian likelihood case, zero is in the <span class="math inline">\(94\%\)</span> credible interval. More over, it is in most of the credible intervals as the distribution is skewed to the right. This goes in alignment with the fact that the input time series is very sparse.</p>
<hr />
</div>
</div>
<div id="time-slice-cross-validation" class="section level2">
<h2>Time Slice Cross Validation</h2>
<p>Similarly as in the previous post, we run a time slice cross validation to compare the performance of the Zero-Inflated TSB model with the Croston and TSB models on the one-step ahead forecast.</p>
<ul>
<li>StatsForecast</li>
</ul>
<pre class="python"><code>def statsforecast_time_slice_cross_validation(
    y: ArrayImpl, n_splits: int, sf: StatsForecast
) -&gt; pd.DataFrame:
    forecast_list = []
    for i in tqdm(range(n_splits)):
        y_train = y[: -(n_splits - i)]
        train_df = pd.DataFrame(
            {&quot;unique_id&quot;: &quot;a&quot;, &quot;ds&quot;: jnp.arange(y_train.size), &quot;y&quot;: y_train}
        )
        forecast_list.append(
            sf.forecast(
                h=1,
                df=train_df,
                level=[94],
                prediction_intervals=ConformalIntervals(n_windows=5),
            )
        )
    return pd.concat(forecast_list, axis=0)


sf_cv = statsforecast_time_slice_cross_validation(y=y, n_splits=y_test.size, sf=sf)</code></pre>
<ul>
<li>Zero-Inflated TSB</li>
</ul>
<pre class="python"><code>def tsb_time_slice_cross_validation(
    rng_key: ArrayImpl, y: ArrayImpl, n_splits: int, inference_params: InferenceParams
) -&gt; xr.Dataset:
    forecast_list = []
    for i in tqdm(range(n_splits)):
        # Prepare data
        y_train = y[: -(n_splits - i)]
        y_train_trim, z0, p0 = get_model_args(y_train)
        # Inference
        rng_key, rng_subkey = random.split(key=rng_key)
        mcmc = run_inference(
            rng_subkey,
            zi_tsb_model,
            inference_params,
            y_train_trim,
            z0,
            p0,
        )
        # Forecast
        rng_key, rng_subkey = random.split(key=rng_key)
        tsb_forecast = forecast(
            rng_subkey,
            zi_tsb_model,
            mcmc.get_samples(),
            y_train_trim.astype(jnp.int32),
            z0,
            p0,
            1,
        )
        forecast_list.append(
            az.from_numpyro(
                posterior_predictive=tsb_forecast,
                coords={&quot;t&quot;: [y_train_trim.size]},
                dims={&quot;ts_forecast&quot;: [&quot;t&quot;]},
            )
        )
    # Concatenate forecasts
    return xr.concat(
        [x[&quot;posterior_predictive&quot;] for x in forecast_list],
        dim=(&quot;t&quot;),
    )


rng_key, rng_subkey = random.split(key=rng_key)
forecast_cv = tsb_time_slice_cross_validation(
    rng_key=rng_subkey,
    y=y,
    n_splits=y_test.size,
    inference_params=inference_params,
)</code></pre>
<p>We plot the results:</p>
<pre class="python"><code>fig, ax = plt.subplots()
ax.plot(t_train, y_train, color=&quot;C0&quot;, label=&quot;train&quot;)
ax.plot(t_test, y_test, marker=&quot;o&quot;, markersize=4, color=&quot;C1&quot;, label=&quot;test (cv)&quot;)
ax.axvline(x=t_train[-1], c=&quot;black&quot;, linestyle=&quot;--&quot;)
az.plot_hdi(
    x=t_test,
    y=forecast_cv[&quot;ts_forecast&quot;],
    hdi_prob=0.94,
    color=&quot;C3&quot;,
    smooth=False,
    fill_kwargs={&quot;alpha&quot;: 0.2, &quot;label&quot;: &quot;$94\\%$ HDI&quot;},
    ax=ax,
)
ax.plot(
    t_test,
    forecast_cv[&quot;ts_forecast&quot;].mean(dim=(&quot;chain&quot;, &quot;draw&quot;)),
    marker=&quot;o&quot;,
    markersize=4,
    color=&quot;C3&quot;,
    label=&quot;mean forecast&quot;,
)
ax.plot(
    t_test,
    sf_cv[&quot;TSB&quot;],
    color=&quot;C2&quot;,
    marker=&quot;o&quot;,
    markersize=4,
    label=&quot;TSB [statsforecast]&quot;,
)
ax.plot(
    t_test,
    sf_cv[&quot;CrostonOptimized&quot;],
    marker=&quot;o&quot;,
    markersize=4,
    color=&quot;C4&quot;,
    label=&quot;CrostonOptimized [statsforecast]&quot;,
)
ax.legend(loc=&quot;upper center&quot;, bbox_to_anchor=(0.5, -0.1), ncol=3)
ax.set(
    xlabel=&quot;time&quot;,
    ylabel=&quot;y&quot;,
    title=&quot;Zero-Inflated TSB Model Forecast - 1 Step Ahead Cross-Validation&quot;,
)</code></pre>
<center>
<img src="../images/zi_tsb_numpyro_files/zi_tsb_numpyro_34_1.png" style="width: 900px;"/>
</center>
<p>Here are some remarks about the results:</p>
<ul>
<li>The Zero-Inflated TSB model forecast lies in between the Croston’s and TSB forecast. It keeps the property of updating the forecast when there is no demand as in the TSB model case. However, for the given parameters, the decay rate is much more conservative and goes to zero slower than the TSB model.</li>
<li>The credible intervals take integer values (as we are assuming we are modeling count data) and they are never negative.</li>
</ul>
<p>Depending on the application, and the forecasting metric to optimize for, the Zero-Inflated TSB model might be a better choice than the Croston’s and TSB models as it somehow lies in between and the likelihood function better captures the discreteness of the input data. Note that this approach is relative natural once we write the model in a probabilistic programming language.</p>
</div>

    </div>
  </article>

  



</main>

      <footer class="footer">
        <ul class="footer-links">
          <li>
            <a href="../index.xml" type="application/rss+xml" target="_blank">RSS feed</a>
          </li>
          <li>
            <a href="https://gohugo.io/" class="footer-links-kudos">Made with <img src="../images/hugo-logo.png" alt="Img link to Hugo website" width="22" height="22"></a>
          </li>
        </ul>
      </footer>

    </div>
    



<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>



<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/r.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/yaml.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/dockerfile.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>
<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



    
<script src="../js/math-code.js"></script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-MML-AM_CHTML"></script>


    
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-5NM5EDH834"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-5NM5EDH834');
        }
      </script>
  </body>
</html>

