<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Dr. Juan Camilo Orduz</title>
    <link>/post/</link>
    <description>Recent content in Posts on Dr. Juan Camilo Orduz</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 05 Jan 2026 00:00:00 +0000</lastBuildDate>
    <atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Forecasting Hierarchical Models - Part III</title>
      <link>/numpyro_hierarchical_forecasting_3/</link>
      <pubDate>Mon, 05 Jan 2026 00:00:00 +0000</pubDate>
      <guid>/numpyro_hierarchical_forecasting_3/</guid>
      <description>&lt;p&gt;In this third notebook, I extend the hierarchical forecasting model from &lt;a href=&#34;https://juanitorduz.github.io/numpyro_hierarchical_forecasting_2/&#34;&gt;Part II&lt;/a&gt; by adding a &lt;strong&gt;neural network component&lt;/strong&gt; to the state transition function. This creates a &lt;strong&gt;Hybrid Deep State-Space Model&lt;/strong&gt; that combines probabilistic modeling with deep learning.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Why?&lt;/strong&gt; This is a personal experiment to explore how to integrate neural networks with hierarchical models. It is not adding complexity for the sake of complexity. It is rather an exploratory exercise to see if this approach can lead to better forecasting performance.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Machine Learning for Optimization: Toy Example</title>
      <link>/sklearn_optim/</link>
      <pubDate>Thu, 01 Jan 2026 00:00:00 +0000</pubDate>
      <guid>/sklearn_optim/</guid>
      <description>&lt;p&gt;Based on my experience, whenever someone asks for a prediction (or forecasting) model, they actually do not need a prediction model per se. They typically want to answer causal questions or do some kind of optimization. I have covered some case studies on causal questions in previous posts (for example, &lt;a href=&#34;https://juanitorduz.github.io/intro_causal_inference_ppl_pymc/&#34;&gt;Introduction to Causal Inference with PPLs&lt;/a&gt; and &lt;a href=&#34;https://juanitorduz.github.io/causal_inference_example/&#34;&gt;‚ÄúUsing Data Science for Bad Decision-Making: A Case Study‚Äù&lt;/a&gt;).&lt;/p&gt;&#xA;&lt;p&gt;In this blog post, I want to focus on optimization. I found a little nice use case when working on adtech, where one is interested in optimizing bids to maximize the revenue (or any other target, like ROAS or lifetime value). How to set the bids? This is a huge active research area so this is by no means an exhaustive treatment. I want to focus on a small component on a recent paper: &lt;a href=&#34;https://arxiv.org/pdf/2508.06069&#34;&gt;‚ÄúLightweight Auto-bidding based on Traffic Prediction in Live Advertising‚Äù&lt;/a&gt; where the authors propose a method to set the bids by optimizing on the output of a fitted forecast model. I won‚Äôt go into the paper scope, but rather focus on a self contained problem: &lt;em&gt;Algorithm 1 Algorithm BiCB&lt;/em&gt;. The basic idea is as follows: In order to set bids on time intervals we can fit a forecasting model to predict the cumulative cost over the day based on time features and the current bid value &lt;span class=&#34;math inline&#34;&gt;\(\text{bid}_t\)&lt;/span&gt;. To set the next bid &lt;span class=&#34;math inline&#34;&gt;\(\text{bid}_{t + 1}\)&lt;/span&gt; we can compare the forecast against the desired target (say, the expected cumulative daily budget at &lt;span class=&#34;math inline&#34;&gt;\(t + 1\)&lt;/span&gt;). We can adjust the under/over pacing by minimizing this difference. In other words, we want to steer achieving the target using the bids values through a &lt;em&gt;time machine&lt;/em&gt; (i.e.¬†a forecasting model) to generate counterfactuals. The paper works out this in certain level of detail, but the concrete implementation is a bit open. So here we do it by plain &lt;em&gt;brute force&lt;/em&gt; (why not?). The whole idea is not to solve this concrete algorithm but to experiment on how to use machine learning methods for optimization purposes.&lt;/p&gt;</description>
    </item>
    <item>
      <title>CATE Estimation with Causal Effect Variational Autoencoders</title>
      <link>/cate_nn/</link>
      <pubDate>Sat, 13 Dec 2025 00:00:00 +0000</pubDate>
      <guid>/cate_nn/</guid>
      <description>&lt;p&gt;In this notebook, we demonstrate how to estimate &lt;strong&gt;Conditional Average Treatment Effects&#xA;(CATE)&lt;/strong&gt; using a &lt;strong&gt;Causal Effect Variational Autoencoder (CEVAE)&lt;/strong&gt; by implementing an example&#xA;from scratch in &lt;a href=&#34;https://num.pyro.ai/&#34;&gt;NumPyro&lt;/a&gt;. This approach is particularly useful when we suspect&#xA;the presence of &lt;strong&gt;unobserved confounders&lt;/strong&gt; that affect both treatment assignment and outcomes.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Disclaimer&lt;/strong&gt;: I am not an expert in this specific approach, so please take all the results with a grain of salt and please do not hesitate to provide feedback.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Causal Effect Estimation with Variational Inference and Latent Confounders</title>
      <link>/online_game_ate/</link>
      <pubDate>Wed, 10 Dec 2025 00:00:00 +0000</pubDate>
      <guid>/online_game_ate/</guid>
      <description>&lt;p&gt;This notebook demonstrates how to estimate the Average Treatment Effect (ATE) using variational&#xA;inference in the presence of unobserved confounders. The approach is based on the tutorial by &lt;a href=&#34;https://scholar.google.com/citations?user=8gWTOBAAAAAJ&amp;amp;hl=en&#34;&gt;Robert Ness&lt;/a&gt; from his book: &lt;a href=&#34;https://github.com/altdeep/causalAI/blob/master/book/chapter%2011/Chapter_11_Bayesian_Causal_Graphical_Inference.ipynb&#34;&gt;Causal AI book&lt;/a&gt;. We port his Pyro code to NumPyro (this was the objective for me to learn the details of the method).&lt;/p&gt;&#xA;&lt;p&gt;The fundamental challenge in causal inference from observational data is confounding: variables&#xA;that affect both the treatment and outcome can bias naive estimates. When confounders are&#xA;unobserved, traditional adjustment methods fail. However, as shown in the CEVAE paper&#xA;(&lt;a href=&#34;https://proceedings.neurips.cc/paper_files/paper/2017/file/94b5bde6de888ddf9cde6748ad2523d1-Paper.pdf&#34;&gt;Louizos et al., NeurIPS 2017&lt;/a&gt;),&#xA;latent variable models can simultaneously infer the hidden confounders and estimate causal&#xA;effects. The variational autoencoder framework provides flexibility to model complex latent&#xA;structures without strong parametric assumptions. The encoder (recognition network) learns to&#xA;map observed data to the latent confounder distribution, enabling amortized inference.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Causal Inference with Multilevel Models: The Electric Company Example</title>
      <link>/ci_multilevel/</link>
      <pubDate>Fri, 28 Nov 2025 00:00:00 +0000</pubDate>
      <guid>/ci_multilevel/</guid>
      <description>&lt;p&gt;Estimating causal effects from clustered or grouped data requires careful attention to the hierarchical structure of observations. When units are nested within groups such as students within classrooms, or patients within hospitals‚Äîignoring this structure can lead to incorrect standard errors, inefficient estimates, and invalid causal inferences. Multilevel models provide a principled framework for handling such data while leveraging the advantages of partial pooling across groups.&lt;/p&gt;&#xA;&lt;p&gt;This notebook reproduces and extends the analysis from &lt;strong&gt;Chapter 23&lt;/strong&gt; of Gelman and Hill‚Äôs &lt;em&gt;‚ÄúData Analysis Using Regression and Multilevel/Hierarchical Models‚Äù&lt;/em&gt;. We demonstrate two complementary approaches to modeling treatment effects in hierarchical data: first, a model with varying intercepts that efficiently controls for group-level confounding, and second, a more flexible covariance model that allows treatment effects themselves to vary across groups. Together, these models illustrate how multilevel structures enhance both the efficiency and interpretability of causal effect estimation. In addition to reproducing the analysis, we show how to efficiently vectorize the model (across &lt;code&gt;grades&lt;/code&gt; and &lt;code&gt;pairs&lt;/code&gt;) using PyMC.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Introduction to Causal Inference with PPLs</title>
      <link>/intro_causal_inference_ppl_pymc/</link>
      <pubDate>Thu, 27 Nov 2025 00:00:00 +0000</pubDate>
      <guid>/intro_causal_inference_ppl_pymc/</guid>
      <description>&lt;p&gt;Causal inference asks a deceptively simple question: &lt;em&gt;‚ÄúWhat would have happened if things were&#xA;different?‚Äù&lt;/em&gt; Whether we‚Äôre evaluating a job training program, testing a new medical treatment,&#xA;or analyzing the impact of a policy change, we want to understand the causal effect of an&#xA;intervention not just observe correlations in the data.&lt;/p&gt;&#xA;&lt;p&gt;Traditional statistical methods often struggle with causal questions because they conflate&#xA;correlation with causation. When confounders variables that affect both treatment assignment&#xA;and outcomes are present, naive comparisons can lead us astray. This notebook demonstrates how&#xA;&lt;strong&gt;probabilistic programming languages (PPLs)&lt;/strong&gt; provide a powerful framework for causal inference&#xA;that makes confounding explicit, quantifies uncertainty properly, and enables us to answer&#xA;counterfactual questions directly.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Bayesian Vector Autoregressive Models in NumPyro</title>
      <link>/var_numpyro/</link>
      <pubDate>Fri, 03 Oct 2025 00:00:00 +0000</pubDate>
      <guid>/var_numpyro/</guid>
      <description>&lt;p&gt;In this notebook, we present how to implement and fit Bayesian Vector Autoregressive (VAR) models using &lt;a href=&#34;https://num.pyro.ai/en/stable/&#34;&gt;NumPyro&lt;/a&gt;. We work out three components:&lt;/p&gt;&#xA;&lt;ol style=&#34;list-style-type: decimal&#34;&gt;&#xA;&lt;li&gt;Specifying and fitting the model in NumPyro&lt;/li&gt;&#xA;&lt;li&gt;Using the model to generate forecasts&lt;/li&gt;&#xA;&lt;li&gt;Computing the Impulse Response Functions (IRFs)&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;We compare these three components with the ones obtained using the &lt;code&gt;statsmodels&lt;/code&gt; implementation from the &lt;a href=&#34;https://www.statsmodels.org/stable/vector_ar.html&#34;&gt;Vector Autoregressions tsa.vector_ar&lt;/a&gt; tutorial.&lt;/p&gt;&#xA;&lt;div id=&#34;prepare-notebook&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Prepare Notebook&lt;/h2&gt;&#xA;&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;from functools import partial&#xA;&#xA;import arviz as az&#xA;import jax.numpy as jnp&#xA;import matplotlib.pyplot as plt&#xA;import numpy as np&#xA;import numpyro&#xA;import numpyro.distributions as dist&#xA;import pandas as pd&#xA;import statsmodels.api as sm&#xA;import xarray as xr&#xA;from jax import jit, lax, random, vmap&#xA;from jaxtyping import Array, Float&#xA;from numpyro.contrib.control_flow import scan&#xA;from numpyro.handlers import condition&#xA;from numpyro.infer import MCMC, NUTS&#xA;from statsmodels.tsa.api import VAR&#xA;from statsmodels.tsa.base.datetools import dates_from_str&#xA;&#xA;numpyro.set_host_device_count(n=10)&#xA;&#xA;rng_key = random.PRNGKey(seed=42)&#xA;&#xA;az.style.use(&amp;quot;arviz-darkgrid&amp;quot;)&#xA;plt.rcParams[&amp;quot;figure.figsize&amp;quot;] = [12, 7]&#xA;plt.rcParams[&amp;quot;figure.dpi&amp;quot;] = 100&#xA;plt.rcParams[&amp;quot;figure.facecolor&amp;quot;] = &amp;quot;white&amp;quot;&#xA;&#xA;%load_ext autoreload&#xA;%autoreload 2&#xA;%load_ext jaxtyping&#xA;%jaxtyping.typechecker beartype.beartype&#xA;%config InlineBackend.figure_format = &amp;quot;retina&amp;quot;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;div id=&#34;load-data&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Load Data&lt;/h2&gt;&#xA;&lt;p&gt;We are going to use a dataset from the &lt;a href=&#34;https://www.statsmodels.org/stable/datasets/index.html&#34;&gt;&lt;code&gt;statsmodels&lt;/code&gt; package&lt;/a&gt;. Specifically, we will use the &lt;code&gt;macrodata&lt;/code&gt; dataset from &lt;a href=&#34;https://www.statsmodels.org/stable/vector_ar.html&#34;&gt;Vector Autoregressions tsa.vector_ar&lt;/a&gt; tutorial. For the sake of reproducibility, we will keep the exact same code as in the tutorial.&lt;/p&gt;</description>
    </item>
    <item>
      <title>PyData Berlin 2025: Introduction to Stochastic Variational Inference with NumPyro</title>
      <link>/intro_svi/</link>
      <pubDate>Mon, 01 Sep 2025 00:00:00 +0000</pubDate>
      <guid>/intro_svi/</guid>
      <description>&lt;p&gt;In this notebook we provide a brief introduction to Stochastic Variational Inference (SVI) with &lt;a href=&#34;https://pyro.ai/numpyro&#34;&gt;NumPyro&lt;/a&gt;. We provide the key mathematical concepts, but we focus on the code implementation. This introductory notebook is meant for practitioners. We do this by working through two examples: a very simple parameter recovery model and a Bayesian Neural Network.&lt;/p&gt;&#xA;&lt;p&gt;This work was presented at &lt;a href=&#34;https://cfp.pydata.org/berlin2025/talk/BCGJQB/&#34;&gt;PyData Berlin 2025&lt;/a&gt;, you can find the slides &lt;a href=&#34;../html/intro_svi.html&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;div id=&#34;overview&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Overview&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;Stochastic Variational Inference (SVI)&lt;/strong&gt; is a scalable approximate inference method that transforms the problem of posterior inference into an optimization problem. Instead of sampling from the posterior distribution (like MCMC), SVI finds the best approximation to the posterior within a family of simpler distributions.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Hierarchical Revenue &amp; Retention Modeling</title>
      <link>/hierarchical_revenue_retention/</link>
      <pubDate>Mon, 04 Aug 2025 00:00:00 +0000</pubDate>
      <guid>/hierarchical_revenue_retention/</guid>
      <description>&lt;p&gt;In this notebook, we extend the revenue-retention model introduced in the sequence of blog posts &lt;a href=&#34;https://juanitorduz.github.io/revenue_retention/&#34;&gt;‚ÄúCohort Revenue &amp;amp; Retention Analysis: A Bayesian Approach‚Äù&lt;/a&gt; and &lt;a href=&#34;https://juanitorduz.github.io/revenue_retention_numpyro/&#34;&gt;‚ÄúCohort Revenue Retention Analysis with Flax and NumPyro‚Äù&lt;/a&gt; (plus the associated pre-print &lt;a href=&#34;https://arxiv.org/abs/2504.16216&#34;&gt;‚ÄúCohort Revenue &amp;amp; Retention Analysis: A Bayesian Approach‚Äù&lt;/a&gt;) to include analysis across different &lt;em&gt;markets&lt;/em&gt; (or any type of grouping variable). The motivation for this extension is that in many real applications one is interested in understanding the revenue and retention patterns across different &lt;em&gt;markets&lt;/em&gt; where typically we have different data sizes. Instead of modeling all separately, we take advantage of the hierarchical structure of the data to share information across markets. This will help have better forecasts for younger markets where limited data is available. We show through a simulation the power of this approach (and how relatively simple it is to implement once we have the basic model in place).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Vectorize ROC Curve for Bayesian Models</title>
      <link>/vectorize_roc_curve/</link>
      <pubDate>Mon, 30 Jun 2025 00:00:00 +0000</pubDate>
      <guid>/vectorize_roc_curve/</guid>
      <description>&lt;p&gt;In this notebook, we present a simple example to illustrate how to vectorize the ROC curve computation over a Bayesian model. This is helpful when we want to compute the ROC curve using the implementations from &lt;a href=&#34;https://scikit-learn.org/stable/modules/generated/sklearn.metrics.roc_curve.html&#34;&gt;&lt;code&gt;scikit-learn&lt;/code&gt;&lt;/a&gt;. We use the classical &lt;a href=&#34;https://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_moons.html&#34;&gt;moons dataset&lt;/a&gt; to generate the data and fit a Gaussian process models similarly as the previous post &lt;a href=&#34;https://juanitorduz.github.io/sklearn_pymc_classifier/&#34;&gt;Scikit-Learn Example in PyMC: Gaussian Process Classifier&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;div id=&#34;prepare-notebook&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Prepare Notebook&lt;/h2&gt;&#xA;&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;import arviz as az&#xA;import matplotlib.pyplot as plt&#xA;import numpy as np&#xA;import preliz as pz&#xA;import pymc as pm&#xA;import pytensor&#xA;import seaborn as sns&#xA;import xarray as xr&#xA;from sklearn.datasets import make_moons&#xA;from sklearn.metrics import roc_auc_score, roc_curve&#xA;from sklearn.model_selection import train_test_split&#xA;&#xA;az.style.use(&amp;quot;arviz-darkgrid&amp;quot;)&#xA;plt.rcParams[&amp;quot;figure.figsize&amp;quot;] = [10, 6]&#xA;plt.rcParams[&amp;quot;figure.dpi&amp;quot;] = 100&#xA;plt.rcParams[&amp;quot;figure.facecolor&amp;quot;] = &amp;quot;white&amp;quot;&#xA;&#xA;%load_ext autoreload&#xA;%autoreload 2&#xA;%config InlineBackend.figure_format = &amp;quot;retina&amp;quot;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;seed: int = sum(map(ord, &amp;quot;vectorize_roc_curve&amp;quot;))&#xA;rng: np.random.Generator = np.random.default_rng(seed=seed)&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;div id=&#34;generate-synthetic-data&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Generate Synthetic Data&lt;/h2&gt;&#xA;&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;# Generate data&#xA;x, y = make_moons(n_samples=150, noise=0.25, random_state=seed)&#xA;# Split data into training and test sets&#xA;x_train, x_test, y_train, y_test = train_test_split(&#xA;    x, y, test_size=0.3, random_state=seed&#xA;)&#xA;# Get number of samples in training and test sets&#xA;n_train = x_train.shape[0]&#xA;n_test = x_test.shape[0]&#xA;n = n_train + n_test&#xA;# Create indices for training and test sets&#xA;idx_train = range(n_train)&#xA;idx_test = range(n_train, n_train + n_test)&#xA;# Get dimension of the domain&#xA;domain_dim = x.shape[1]&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Let‚Äôs start by visualizing the data.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Introduction to Bayesian Power Analysis: Exclude a Null Value</title>
      <link>/power_sample_size_exclude_null/</link>
      <pubDate>Tue, 29 Apr 2025 00:00:00 +0000</pubDate>
      <guid>/power_sample_size_exclude_null/</guid>
      <description>&lt;p&gt;Recently, I have been thinking a lot about data-driven decision-making, particularly in the context of experimentation. Why? I am uncomfortable with the common practice of using p-values and frequentist null hypothesis significance testing to make decisions. I don‚Äôt feel confident about the approach. I think it is because I do not get it. For instance, when I am forced to explain the definition of a confidence interval precisely, it does not come naturally. I always need to check with a trustworthy source (it is common to find wrong explanations online). If I do not understand it, I cannot use it, especially for decision-making. I always play this exercise when thinking about business recommendations in real applications: ‚ÄúWould I bet my salary on this?‚Äù Whenever I work with p-values, the answer to this question is no.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Prior Predictive Modeling in Bayesian AB Testing</title>
      <link>/prior_predictive_ab_testing/</link>
      <pubDate>Tue, 11 Mar 2025 00:00:00 +0000</pubDate>
      <guid>/prior_predictive_ab_testing/</guid>
      <description>&lt;p&gt;In this notebook we generate a simulation to reproduce the results of the great blog post &lt;a href=&#34;https://www.geteppo.com/blog/the-bet-test-problems-in-bayesian-ab-test-analysis&#34;&gt;‚ÄúThe Bet Test: Spotting Problems in Bayesian A/B Test Analysis‚Äù&lt;/a&gt;, where &lt;a href=&#34;https://www.geteppo.com/author/tyler-buffington&#34;&gt;Tyler Buffington&lt;/a&gt; discussed about some caveats of using Bayesian AB testing when not thinking about the prior predictive distribution on the key metrics of interested. If you haven‚Äôt read it yet, please do it before continuing ;)&lt;/p&gt;&#xA;&lt;p&gt;In a nutshell, the blog post showcases the risk of using informative priors to speed-up A/B tests in a naive way. To be fair, it is easy to fall into this trap (I have been there üôà), so I think it is great to have these discussions to make us think twice about what we are doing.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Notes on Hierarchical Hilbert Space Gaussian Processes</title>
      <link>/hierarchical_hsgp/</link>
      <pubDate>Wed, 01 Jan 2025 00:00:00 +0000</pubDate>
      <guid>/hierarchical_hsgp/</guid>
      <description>&lt;p&gt;In this notebook, we want to explore some ideas on hierarchical Hilbert Space Gaussian Processes following the fantastic exposition of the PyMC example notebook: &lt;a href=&#34;https://www.pymc.io/projects/examples/en/latest/gaussian_processes/HSGP-Advanced.html&#34;&gt;‚ÄúGaussian Processes: HSGP Advanced Usage‚Äù&lt;/a&gt; by &lt;a href=&#34;https://github.com/bwengals&#34;&gt;Bill Engels&lt;/a&gt;, &lt;a href=&#34;https://github.com/AlexAndorra&#34;&gt;Alexandre Andorra&lt;/a&gt; and &lt;a href=&#34;https://github.com/ferrine&#34;&gt;Maxim Kochurov&lt;/a&gt;. I can only recommend to read the notebook and the references therein!&#xA;For an introduction to Hilbert Space Gaussian Processes, please see my introductory blog post: &lt;a href=&#34;https://juanitorduz.github.io/hsgp_intro/&#34;&gt;‚ÄúA Conceptual and Practical Introduction to Hilbert Space GPs Approximation Methods‚Äù&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Motivation&lt;/strong&gt;: In many applications, one is interested in understanding the dynamic effect of one variable on another. For example, in marketing, one is interested in efficiency across many channels on sales (or conversions) as a function of time. For such a purpose, one typically uses a time-varying regression model with time-varying coefficients (for a simple example, see &lt;a href=&#34;https://juanitorduz.github.io/bikes_gp/&#34;&gt;‚ÄúTime-Varying Regression Coefficients via Hilbert Space Gaussian Process Approximation‚Äù&lt;/a&gt;). The main challenge is that, if not done carefully, the model will easily overfit the data. One can use a hierarchical model with a global component and a group-specific component to overcome this. The global component will capture the overall trend, while the group-specific component will capture the idiosyncratic behavior of each group. As a side effect, we will gain some regularization effect that will help to avoid overfitting. For the marketing example above, &lt;a href=&#34;https://www.pymc-labs.com/blog-posts/&#34;&gt;PyMC Labs&lt;/a&gt; has successfully applied this approach in the context of media mix modeling: &lt;a href=&#34;https://www.pymc-labs.com/blog-posts/modelling-changes-marketing-effectiveness-over-time/&#34;&gt;‚ÄúBayesian Media Mix Models: Modelling changes in marketing effectiveness over time‚Äù&lt;/a&gt;. This hierarchical approach was motivated by the work &lt;a href=&#34;https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-14-252&#34;&gt;‚ÄúHierarchical Bayesian modeling of gene expression time series across irregularly sampled replicates and clusters‚Äù&lt;/a&gt;. Here is a schematic diagram of the hierarchical approach (taken from the paper):&lt;/p&gt;</description>
    </item>
    <item>
      <title>Hacking the TSB Model for Intermediate Time Series to Accommodate for Availability Constraints</title>
      <link>/availability_tsb/</link>
      <pubDate>Mon, 25 Nov 2024 00:00:00 +0000</pubDate>
      <guid>/availability_tsb/</guid>
      <description>&lt;p&gt;In many demand forecasting problems, we face the challenge of predicting the demand for a product or service with very sparse data. This is especially true in retail, where many products are only sold occasionally. This sparsity can come from many sources, as greatly described in the (recommended!) blog post &lt;a href=&#34;https://openforecast.org/2024/11/18/why-zeroes-happen/&#34;&gt;‚ÄúWhy zeroes happen‚Äù&lt;/a&gt; by &lt;a href=&#34;https://openforecast.org/&#34;&gt;Ivan Svetunkov&lt;/a&gt;. On one hand, the sparsity can simply come from the lack of demand for the product. On the other hand, the sparsity can also come from the lack of availability of the product. For example, a product might be only available for purchase during certain times of the year or only in certain geographical locations. There could be other reasons as well. In this notebook, we experiment with an extension on a classical TSB time-series model for intermediate time series to accommodate availability constraints.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Bayesian CUPED &amp; Sensitivity Analysis</title>
      <link>/bayesian_cuped/</link>
      <pubDate>Tue, 29 Oct 2024 00:00:00 +0000</pubDate>
      <guid>/bayesian_cuped/</guid>
      <description>&lt;p&gt;Motivated by the great blog post by &lt;a href=&#34;https://towardsdatascience.com/understanding-cuped-a822523641af&#34;&gt;Understanding CUPED&lt;/a&gt; by &lt;a href=&#34;https://medium.com/@matteo.courthoud&#34;&gt;Matteo Courthoud&lt;/a&gt;, we explore a Bayesian approach to &lt;a href=&#34;https://dl.acm.org/doi/abs/10.1145/2433396.2433413&#34;&gt;CUPED&lt;/a&gt; to understand its sensitivity with respect to the covariance parameter &lt;span class=&#34;math inline&#34;&gt;\(\theta\)&lt;/span&gt; of the pre-post mean model. I will assume that the reader is already familiar with CUPED and has read Matteo‚Äôs blog post (highly recommended!). Here we focus on the sensitivity component. We do not do this in full generality but rather focus on the specific example of Matteo‚Äôs blog post.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Electricity Demand Forecast: Dynamic Time-Series Model with Prior Calibration</title>
      <link>/electricity_forecast_with_priors/</link>
      <pubDate>Mon, 07 Oct 2024 00:00:00 +0000</pubDate>
      <guid>/electricity_forecast_with_priors/</guid>
      <description>&lt;p&gt;We present an example of a dynamic forecasting time-series model that incorporates a prior calibration process to estimate the temperature effect on electricity demand. The model is based on the previous example &lt;a href=&#34;https://juanitorduz.github.io/electricity_forecast/&#34;&gt;Electricity Demand Forecast: Dynamic Time-Series Model&lt;/a&gt;. In this second iteration, we borrow the ideas from the Pyro great example &lt;a href=&#34;https://pyro.ai/examples/forecasting_dlm.html&#34;&gt;Forecasting with Dynamic Linear Model (DLM)&lt;/a&gt; where they use a prior calibration process on a local level forecasting model. In our case, we use the same technique with a Hilbert Space Gaussian Process latent component model.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Electricity Demand Forecast: Dynamic Time-Series Model</title>
      <link>/electricity_forecast/</link>
      <pubDate>Sun, 06 Oct 2024 00:00:00 +0000</pubDate>
      <guid>/electricity_forecast/</guid>
      <description>&lt;p&gt;We work out a classical electricity demand forecasting model form the case study &lt;a href=&#34;https://www.tensorflow.org/probability/examples/Structural_Time_Series_Modeling_Case_Studies_Atmospheric_CO2_and_Electricity_Demand&#34;&gt;Structural Time Series Modeling Case Studies: Atmospheric CO2 and Electricity Demand&lt;/a&gt; from the TensorFlow Probability documentation. The idea of this example is to use temperature as a linear covariate to model the electricity demand. In this example, we show how to use a (Hilbert Space Approximation) Gaussian process to model the non-linear relationship between temperature and electricity demand (for an introduction to the topic see &lt;a href=&#34;https://juanitorduz.github.io/hsgp_intro/&#34;&gt;A Conceptual and Practical Introduction to Hilbert Space GPs Approximation Methods&lt;/a&gt;). This technique improves the simple linear model in and out of sample predictions as we aro not using the Gaussian process to extrapolate over time, but rather to model the non-linear relationship between temperature and electricity demand, similarly as how it has done in the example &lt;a href=&#34;https://juanitorduz.github.io/bikes_gp/&#34;&gt;Time-Varying Regression Coefficients via Hilbert Space Gaussian Process Approximation&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>From Pyro to NumPyro: Forecasting Hierarchical Models - Part II</title>
      <link>/numpyro_hierarchical_forecasting_2/</link>
      <pubDate>Sat, 05 Oct 2024 00:00:00 +0000</pubDate>
      <guid>/numpyro_hierarchical_forecasting_2/</guid>
      <description>&lt;p&gt;In this second notebook, we continue working on the NumPyro implementation of the hierarchical forecasting models presented in Pyro‚Äôs forecasting documentation: &lt;a href=&#34;https://pyro.ai/examples/forecasting_iii.html&#34;&gt;Forecasting III: hierarchical models&lt;/a&gt;. In this second part, we extend the model described in the first part &lt;a href=&#34;https://juanitorduz.github.io/numpyro_hierarchical_forecasting_1/&#34;&gt;From Pyro to NumPyro: Forecasting Hierarchical Models - Part I&lt;/a&gt; by adding all stations to the model.&lt;/p&gt;&#xA;&lt;div id=&#34;prepare-notebook&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Prepare Notebook&lt;/h2&gt;&#xA;&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;import arviz as az&#xA;import jax&#xA;import jax.numpy as jnp&#xA;import matplotlib.pyplot as plt&#xA;import numpyro&#xA;import numpyro.distributions as dist&#xA;from jax import random&#xA;from jaxtyping import Array, Float&#xA;from numpyro.contrib.control_flow import scan&#xA;from numpyro.infer import SVI, Predictive, Trace_ELBO&#xA;from numpyro.infer.autoguide import AutoNormal&#xA;from numpyro.infer.reparam import LocScaleReparam&#xA;from pyro.contrib.examples.bart import load_bart_od&#xA;&#xA;az.style.use(&amp;quot;arviz-darkgrid&amp;quot;)&#xA;plt.rcParams[&amp;quot;figure.figsize&amp;quot;] = [12, 7]&#xA;plt.rcParams[&amp;quot;figure.dpi&amp;quot;] = 100&#xA;plt.rcParams[&amp;quot;figure.facecolor&amp;quot;] = &amp;quot;white&amp;quot;&#xA;&#xA;numpyro.set_host_device_count(n=4)&#xA;&#xA;rng_key = random.PRNGKey(seed=42)&#xA;&#xA;%load_ext autoreload&#xA;%autoreload 2&#xA;%load_ext jaxtyping&#xA;%jaxtyping.typechecker beartype.beartype&#xA;%config InlineBackend.figure_format = &amp;quot;retina&amp;quot;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;The autoreload extension is already loaded. To reload it, use:&#xA;  %reload_ext autoreload&#xA;The jaxtyping extension is already loaded. To reload it, use:&#xA;  %reload_ext jaxtyping&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;div id=&#34;read-data&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Read Data&lt;/h2&gt;&#xA;&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;dataset = load_bart_od()&#xA;print(dataset.keys())&#xA;print(dataset[&amp;quot;counts&amp;quot;].shape)&#xA;print(&amp;quot; &amp;quot;.join(dataset[&amp;quot;stations&amp;quot;]))&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;dict_keys([&amp;#39;stations&amp;#39;, &amp;#39;start_date&amp;#39;, &amp;#39;counts&amp;#39;])&#xA;torch.Size([78888, 50, 50])&#xA;12TH 16TH 19TH 24TH ANTC ASHB BALB BAYF BERY CAST CIVC COLM COLS CONC DALY DBRK DELN DUBL EMBR FRMT FTVL GLEN HAYW LAFY LAKE MCAR MLBR MLPT MONT NBRK NCON OAKL ORIN PCTR PHIL PITT PLZA POWL RICH ROCK SANL SBRN SFIA SHAY SSAN UCTY WARM WCRK WDUB WOAK&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;In this second example, we model all the rides from all stations to all other stations.&lt;/p&gt;</description>
    </item>
    <item>
      <title>From Pyro to NumPyro: Forecasting Hierarchical Models - Part I</title>
      <link>/numpyro_hierarchical_forecasting_1/</link>
      <pubDate>Thu, 03 Oct 2024 00:00:00 +0000</pubDate>
      <guid>/numpyro_hierarchical_forecasting_1/</guid>
      <description>&lt;p&gt;In this notebook we provide a NumPyro implementation of the first model presented in the Pyro forecasting documentation: &lt;a href=&#34;https://pyro.ai/examples/forecasting_iii.html&#34;&gt;Forecasting III: hierarchical models&lt;/a&gt;. This model generalizes the local level model with seasonality presented in the univariate example &lt;a href=&#34;https://pyro.ai/examples/forecasting_i.html&#34;&gt;Forecasting I: univariate, heavy tailed&lt;/a&gt; (see &lt;a href=&#34;https://juanitorduz.github.io/numpyro_forecasting-univariate/&#34;&gt;From Pyro to NumPyro: Forecasting a univariate, heavy tailed time series&lt;/a&gt; for the corresponding NumPyro implementation).&lt;/p&gt;&#xA;&lt;p&gt;In this example, we continue working with the BART train ridership &lt;a href=&#34;https://www.bart.gov/about/reports/ridership&#34;&gt;dataset&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;div id=&#34;prepare-notebook&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Prepare Notebook&lt;/h2&gt;&#xA;&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;import arviz as az&#xA;import jax&#xA;import jax.numpy as jnp&#xA;import matplotlib.pyplot as plt&#xA;import numpyro&#xA;import numpyro.distributions as dist&#xA;import torch&#xA;from jax import random&#xA;from jaxtyping import Array, Float&#xA;from numpyro.contrib.control_flow import scan&#xA;from numpyro.infer import SVI, Predictive, Trace_ELBO&#xA;from numpyro.infer.autoguide import AutoNormal&#xA;from numpyro.infer.reparam import LocScaleReparam&#xA;from pyro.contrib.examples.bart import load_bart_od&#xA;from pyro.ops.tensor_utils import periodic_repeat&#xA;&#xA;az.style.use(&amp;quot;arviz-darkgrid&amp;quot;)&#xA;plt.rcParams[&amp;quot;figure.figsize&amp;quot;] = [12, 7]&#xA;plt.rcParams[&amp;quot;figure.dpi&amp;quot;] = 100&#xA;plt.rcParams[&amp;quot;figure.facecolor&amp;quot;] = &amp;quot;white&amp;quot;&#xA;&#xA;numpyro.set_host_device_count(n=4)&#xA;&#xA;rng_key = random.PRNGKey(seed=42)&#xA;&#xA;%load_ext autoreload&#xA;%autoreload 2&#xA;%load_ext jaxtyping&#xA;%jaxtyping.typechecker beartype.beartype&#xA;%config InlineBackend.figure_format = &amp;quot;retina&amp;quot;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;The autoreload extension is already loaded. To reload it, use:&#xA;  %reload_ext autoreload&#xA;The jaxtyping extension is already loaded. To reload it, use:&#xA;  %reload_ext jaxtyping&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;div id=&#34;read-data&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Read Data&lt;/h2&gt;&#xA;&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;dataset = load_bart_od()&#xA;print(dataset.keys())&#xA;print(dataset[&amp;quot;counts&amp;quot;].shape)&#xA;print(&amp;quot; &amp;quot;.join(dataset[&amp;quot;stations&amp;quot;]))&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;dict_keys([&amp;#39;stations&amp;#39;, &amp;#39;start_date&amp;#39;, &amp;#39;counts&amp;#39;])&#xA;torch.Size([78888, 50, 50])&#xA;12TH 16TH 19TH 24TH ANTC ASHB BALB BAYF BERY CAST CIVC COLM COLS CONC DALY DBRK DELN DUBL EMBR FRMT FTVL GLEN HAYW LAFY LAKE MCAR MLBR MLPT MONT NBRK NCON OAKL ORIN PCTR PHIL PITT PLZA POWL RICH ROCK SANL SBRN SFIA SHAY SSAN UCTY WARM WCRK WDUB WOAK&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;For this first model, we just model the rides to Embarcadero station, from each of the other &lt;span class=&#34;math inline&#34;&gt;\(50\)&lt;/span&gt; stations.&lt;/p&gt;</description>
    </item>
    <item>
      <title>From Pyro to NumPyro: Forecasting a univariate, heavy tailed time series</title>
      <link>/numpyro_forecasting-univariate/</link>
      <pubDate>Tue, 01 Oct 2024 00:00:00 +0000</pubDate>
      <guid>/numpyro_forecasting-univariate/</guid>
      <description>&lt;p&gt;In this notebooks we port the &lt;a href=&#34;https://github.com/pyro-ppl/pyro&#34;&gt;&lt;code&gt;Pyro&lt;/code&gt;&lt;/a&gt; forecasting example &lt;a href=&#34;https://pyro.ai/examples/forecasting_i.html&#34;&gt;Forecasting I: univariate, heavy tailed&lt;/a&gt; to &lt;a href=&#34;https://github.com/pyro-ppl/numpyro&#34;&gt;&lt;code&gt;NumPyro&lt;/code&gt;&lt;/a&gt;. The forecasting module in Pyro is fantastic as it provides an easy interface to develop custom forecasting models. It has also many helpful utility functions to generate features and for model evaluation. The purpose of this translation is to dig deeper into the some forecasting components and to show that translating Pyro code to NumPyro is not that hard, even though there are come caveats.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Hierarchical Pricing Elasticity Models</title>
      <link>/elasticities/</link>
      <pubDate>Thu, 01 Aug 2024 00:00:00 +0000</pubDate>
      <guid>/elasticities/</guid>
      <description>&lt;p&gt;In this notebook we use a retail publicly available dataset to fit and compare various pricing elasticity models. This example can be seen as a continuation of the notebooks regarding Bayesian hierarchical models (see for example &lt;a href=&#34;https://juanitorduz.github.io/multilevel_elasticities_single_sku/&#34;&gt;Multilevel Elasticities for a Single SKU - Part I&lt;/a&gt;). In this example we also see how Bayesian hierarchical models can help regularize elasticity estimates when taking advantage of the hierarchical structure of the data. In addition, this example shows that these models can scale well using stochastic variational inference in &lt;a href=&#34;https://github.com/pyro-ppl/numpyro&#34;&gt;NumPyro&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Multilevel Elasticities for a Single SKU - Part III.</title>
      <link>/multilevel_elasticities_single_sku_3/</link>
      <pubDate>Fri, 19 Jul 2024 00:00:00 +0000</pubDate>
      <guid>/multilevel_elasticities_single_sku_3/</guid>
      <description>&lt;p&gt;In this notebook we continue our simulation study for elasticities, see:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://juanitorduz.github.io/multilevel_elasticities_single_sku/&#34;&gt;Multilevel Elasticities for a Single SKU - Part I&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://juanitorduz.github.io/multilevel_elasticities_single_sku_2/&#34;&gt;Multilevel Elasticities for a Single SKU - Part II&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;for an introduction to the problem and some models. We extend the covariance model to allow two covariance components on both the intercepts and slopes (coefficient of the &lt;code&gt;median_ income&lt;/code&gt; variable). Also, to abstract from a specific framework, we do the implementation in &lt;a href=&#34;https://num.pyro.ai/&#34;&gt;NumPyro&lt;/a&gt;. The corresponding &lt;a href=&#34;https://docs.pymc.io/&#34;&gt;PyMC&lt;/a&gt; is very similar.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Hierarchical Exponential Smoothing Model</title>
      <link>/hierarchical_exponential_smoothing/</link>
      <pubDate>Fri, 07 Jun 2024 00:00:00 +0000</pubDate>
      <guid>/hierarchical_exponential_smoothing/</guid>
      <description>&lt;p&gt;In this blog post, we experiment with a hierarchical exponential smoothing forecasting model, extending the ideas from the univariate case presented in the blog post &lt;a href=&#34;https://juanitorduz.github.io/exponential_smoothing_numpyro/&#34;&gt;‚ÄúNotes on Exponential Smoothing with NumPyro‚Äù&lt;/a&gt;. We use &lt;a href=&#34;https://github.com/pyro-ppl/numpyro&#34;&gt;NumPyro&lt;/a&gt; and compare the NUTS and SVI results. For such a purpose, we use &lt;strong&gt;Continuous Ranked Probability Score&lt;/strong&gt; (&lt;a href=&#34;https://towardsdatascience.com/crps-a-scoring-function-for-bayesian-machine-learning-models-dd55a7a337a8&#34;&gt;CRPS&lt;/a&gt;). We also compare these forecasts with univariate statistical models like Holt-Winters, AutoETS and Seasonal Naive from the great &lt;a href=&#34;https://nixtlaverse.nixtla.io/statsforecast/index.html&#34;&gt;Statsforecast&lt;/a&gt; package. These baseline models are, in general, hard to beat!&lt;/p&gt;</description>
    </item>
    <item>
      <title>Demand Forecasting with Censored Likelihood</title>
      <link>/demand/</link>
      <pubDate>Sun, 21 Apr 2024 00:00:00 +0000</pubDate>
      <guid>/demand/</guid>
      <description>&lt;p&gt;In this notebook we will explore the use of censored likelihoods for demand forecasting.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Business Problem&lt;/strong&gt;: Let us assume we have a store with a single product. We want to forecast the (true!) demand for this product for the next 30 days using historical data. The historical data consists of the daily sales of the product for the last year (approximately). An important challenge is that our historical sales data is censored. This means that we only observe the sales of the product when it is in stock. If the product is out of stock, we do not observe any sales. This includes when the product is not available in the store or when we sold out of the product.&lt;/p&gt;</description>
    </item>
    <item>
      <title>A Conceptual and Practical Introduction to Hilbert Space GPs Approximation Methods</title>
      <link>/hsgp_intro/</link>
      <pubDate>Thu, 18 Apr 2024 00:00:00 +0000</pubDate>
      <guid>/hsgp_intro/</guid>
      <description>&lt;p&gt;In this notebook, we explore the (conceptual) ideas and (practical) implementation details of the &lt;em&gt;Hilbert Space&lt;/em&gt; approximation for Gaussian processes introduced in the article &lt;a href=&#34;https://link.springer.com/article/10.1007/s11222-019-09886-w&#34;&gt;‚ÄúHilbert space methods for reduced-rank Gaussian process regression‚Äù&lt;/a&gt; by Arno Solin and Simo S√§rkk√§. We do not go deep into the mathematical details (proofs) but focus on the core ideas to help us understand the main concepts guiding the technical implementation. We provide examples, both in &lt;a href=&#34;https://github.com/pyro-ppl/numpyro&#34;&gt;&lt;code&gt;NumPyro&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://github.com/pymc-devs/pymc&#34;&gt;&lt;code&gt;PyMC&lt;/code&gt;&lt;/a&gt;, so that users can learn from cross-framework comparison so that we abstract the core ideas.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Bayesian Censoring Data Modeling</title>
      <link>/censoring/</link>
      <pubDate>Mon, 26 Feb 2024 00:00:00 +0000</pubDate>
      <guid>/censoring/</guid>
      <description>&lt;p&gt;In this notebook, we explore how we can use Bayesian modeling to estimate the parameters of a censored data set. These datasets are common in many fields, including survival analysis and supply chain management. I was motivated to write this notebook after reading the excellent blog post &lt;a href=&#34;https://kylejcaron.github.io/posts/censored_demand/2024-02-06-censored-demand.html&#34;&gt;‚ÄúModeling Anything With First Principles: Demand under extreme stockouts‚Äù&lt;/a&gt; by &lt;a href=&#34;https://kylejcaron.github.io/&#34;&gt;Kyle Caron&lt;/a&gt; where he uses these techniques to model and balance demand under extreme stockouts and other constraints.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Zero-Inflated TSB Model</title>
      <link>/zi_tsb_numpyro/</link>
      <pubDate>Tue, 20 Feb 2024 00:00:00 +0000</pubDate>
      <guid>/zi_tsb_numpyro/</guid>
      <description>&lt;p&gt;After going through the fundamentals of the &lt;a href=&#34;https://juanitorduz.github.io/tsb_numpyro/&#34;&gt;TSB Method for Intermittent Time Series Forecasting in NumPyro&lt;/a&gt; in the previous notebook, we explore a variation of it that might be useful for certain applications. In a nutshell, we keep the same model structure of the TSB model, but we modify the likelihood function to account for the sparsity of the time series. Concretely, we replace the classic Gaussian likelihood function with a zero-inflated Negative Binomial likelihood function. One clear conceptual advantage of this approach that all our prediction and credible intervals will be non-negative.&lt;/p&gt;</description>
    </item>
    <item>
      <title>TSB Method for Intermittent Time Series Forecasting in NumPyro</title>
      <link>/tsb_numpyro/</link>
      <pubDate>Sat, 17 Feb 2024 00:00:00 +0000</pubDate>
      <guid>/tsb_numpyro/</guid>
      <description>&lt;p&gt;In this notebook we provide a &lt;a href=&#34;http://num.pyro.ai&#34;&gt;&lt;code&gt;NumPyro&lt;/code&gt;&lt;/a&gt; implementation of the TSB (Teunter, Syntetos and Babai) method for forecasting intermittent time series. The TSB method is similar to the &lt;a href=&#34;https://juanitorduz.github.io/croston_numpyro/&#34;&gt;Croston‚Äôs method&lt;/a&gt; in the sense that is constructs two different time series out of the original one and then forecast each of them separately, so that the final forecast is generated by combining the forecasts of the two time series. The main difference between the two methods is that the TSB method uses the demand probability instead of the demand periods. Consequently, let &lt;span class=&#34;math inline&#34;&gt;\(y_{t}\)&lt;/span&gt; denote the input time series then the TSB method is specified by the following equations:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Croston&#39;s Method for Intermittent Time Series Forecasting in NumPyro</title>
      <link>/croston_numpyro/</link>
      <pubDate>Thu, 15 Feb 2024 00:00:00 +0000</pubDate>
      <guid>/croston_numpyro/</guid>
      <description>&lt;p&gt;In this notebook, we will implement Croston‚Äôs method for intermittent demand forecasting using &lt;a href=&#34;https://github.com/pyro-ppl/numpyro&#34;&gt;&lt;code&gt;NumPyro&lt;/code&gt;&lt;/a&gt;. Croston‚Äôs method is a popular forecasting method for intermittent demand data, which is characterized by a large number of zero values. The method is based on the idea of separating the demand size and the demand interval, and then forecasting them separately using simple exponential smoothing. We therefore can leverage on top of the previous post &lt;a href=&#34;https://juanitorduz.github.io/exponential_smoothing_numpyro/&#34;&gt;Notes on Exponential Smoothing with NumPyro&lt;/a&gt;. Once we have the forecasts for the demand size and the demand interval, we can combine them to get the final forecast. For a succinct explanation of Croston‚Äôs method, I recommend the following blog post: &lt;a href=&#34;https://www.pmorgan.com.au/tutorials/crostons-method/&#34; class=&#34;uri&#34;&gt;https://www.pmorgan.com.au/tutorials/crostons-method/&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Notes on an ARMA(1, 1) Model with NumPyro</title>
      <link>/arma_numpyro/</link>
      <pubDate>Tue, 13 Feb 2024 00:00:00 +0000</pubDate>
      <guid>/arma_numpyro/</guid>
      <description>&lt;p&gt;This are some notes on how to implement an ARMA(1, 1) model using &lt;a href=&#34;https://github.com/pyro-ppl/numpyro&#34;&gt;&lt;code&gt;NumPyro&lt;/code&gt;&lt;/a&gt; for time series forecasting. The ARMA(1, 1) model is given by&lt;/p&gt;&#xA;&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[y_t = \mu + \phi y_{t-1} + \theta \varepsilon_{t-1} + \varepsilon_t\]&lt;/span&gt;&lt;/p&gt;&#xA;&lt;p&gt;where &lt;span class=&#34;math inline&#34;&gt;\(y_t\)&lt;/span&gt; is the time series, &lt;span class=&#34;math inline&#34;&gt;\(\mu\)&lt;/span&gt; is the mean, &lt;span class=&#34;math inline&#34;&gt;\(\phi\)&lt;/span&gt; is the autoregressive parameter, &lt;span class=&#34;math inline&#34;&gt;\(\theta\)&lt;/span&gt; is the moving average parameter, and &lt;span class=&#34;math inline&#34;&gt;\(\varepsilon_t\)&lt;/span&gt; is a white noise process with mean zero and variance &lt;span class=&#34;math inline&#34;&gt;\(\sigma^2\)&lt;/span&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Notes on Exponential Smoothing with NumPyro</title>
      <link>/exponential_smoothing_numpyro/</link>
      <pubDate>Sun, 11 Feb 2024 00:00:00 +0000</pubDate>
      <guid>/exponential_smoothing_numpyro/</guid>
      <description>&lt;p&gt;This notebook serves as personal notes on &lt;a href=&#34;https://num.pyro.ai/en/stable/index.html&#34;&gt;&lt;code&gt;NumPyro&lt;/code&gt;&lt;/a&gt;‚Äôs implementation of the classic &lt;a href=&#34;https://en.wikipedia.org/wiki/Exponential_smoothing&#34;&gt;exponential smoothing&lt;/a&gt; forecasting method. I use &lt;a href=&#34;https://num.pyro.ai/en/stable/examples/holt_winters.html&#34;&gt;Example: Holt-Winters Exponential Smoothing&lt;/a&gt;. The strategy is to go into the nitty-gritty details of the code presented in the example from the documentation: &lt;a href=&#34;https://num.pyro.ai/en/stable/examples/holt_winters.html&#34;&gt;‚ÄúExample: Holt-Winters Exponential Smoothing‚Äù&lt;/a&gt;. In particular, I want to understand the auto-regressive components using the &lt;a href=&#34;https://num.pyro.ai/en/stable/primitives.html#scan&#34;&gt;&lt;code&gt;scan&lt;/code&gt;&lt;/a&gt; function, which always confuses me üòÖ. After reproducing the example from the documentation, we go a step further and extend the algorithm to include a damped trend.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Media Mix Model and Experimental Calibration: A Simulation Study</title>
      <link>/mmm_roas/</link>
      <pubDate>Sun, 04 Feb 2024 00:00:00 +0000</pubDate>
      <guid>/mmm_roas/</guid>
      <description>&lt;p&gt;In this notebook, we present a complete simulation study of the media mix model (MMM) and experimental calibration method presented in the paper &lt;a href=&#34;https://research.google/pubs/media-mix-model-calibration-with-bayesian-priors/&#34;&gt;‚ÄúMedia Mix Model Calibration With Bayesian Priors‚Äù, by Zhang, et al.&lt;/a&gt;, where the authors propose a convenient parametrization the regression model in terms of the ROAs (return on advertising spend) instead of the classical regression (beta) coefficients. The benefit of this parametrization is that it allows for using Bayesian priors on the ROAS, which typically come from previous experiments or domain knowledge. Providing this information to the model is essential in real-life MMM applications, as biases and noise can easily fool us. Similar to the author‚Äôs paper, we show that the proposed method can provide better ROAS estimation when we have a bias due to missing covariates or omitted variables. We work out an example of the classical media mix model presented in the paper &lt;a href=&#34;https://research.google/pubs/bayesian-methods-for-media-mix-modeling-with-carryover-and-shape-effects/&#34;&gt;‚ÄúBayesian Methods for Media Mix Modeling with Carryover and Shape Effects‚Äù, by Jin, et al.&lt;/a&gt;. I strongly recommend taking a look in too these two papers before reading this notebook. Reading them in parallel with this notebook is also a good alternative.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Cohort Revenue Retention Analysis with Flax and NumPyro</title>
      <link>/revenue_retention_numpyro/</link>
      <pubDate>Mon, 08 Jan 2024 00:00:00 +0000</pubDate>
      <guid>/revenue_retention_numpyro/</guid>
      <description>&lt;p&gt;In this notebook we present an alternative implementation of the cohort-revenue-retention model presented in the blog post &lt;a href=&#34;https://juanitorduz.github.io/revenue_retention/&#34;&gt;Cohort Revenue &amp;amp; Retention Analysis: A Bayesian Approach&lt;/a&gt; where we show how to replace the &lt;a href=&#34;https://github.com/pymc-devs/pymc-bart&#34;&gt;BART&lt;/a&gt; retention component with a general neural network implemented with &lt;a href=&#34;https://github.com/google/flax&#34;&gt;Flax&lt;/a&gt;. This allows faster inference, as we can use &lt;a href=&#34;https://github.com/pyro-ppl/numpyro&#34;&gt;NumPyro&lt;/a&gt;‚Äôs NUTS sampler or any of the stochastic variational inference (SVI) algorithms available. We could even use a wider family of samplers using the newly released package &lt;a href=&#34;https://jax-ml.github.io/bayeux/&#34;&gt;Bayeux&lt;/a&gt; or the great &lt;a href=&#34;https://github.com/blackjax-devs/blackjax&#34;&gt;BlackJax&lt;/a&gt; (see for example, the &lt;a href=&#34;https://blackjax-devs.github.io/sampling-book/models/mlp.html&#34;&gt;MLP Classifier Example&lt;/a&gt;).&#xA;We use the same simulated dataset to be able to compare the approaches. Overall, the retention and revenue in and out-of sample predictions, as well as the credible intervals are very similar to the ones obtained with the &lt;a href=&#34;https://github.com/pymc-devs/pymc-bart&#34;&gt;BART&lt;/a&gt; model.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Flax and NumPyro Toy Example</title>
      <link>/flax_numpyro/</link>
      <pubDate>Fri, 05 Jan 2024 00:00:00 +0000</pubDate>
      <guid>/flax_numpyro/</guid>
      <description>&lt;p&gt;In this notebook I want to experiment with the &lt;a href=&#34;https://github.com/pyro-ppl/numpyro/blob/master/numpyro/contrib/module.py&#34;&gt;&lt;code&gt;numpyro/contrib/module.py&lt;/code&gt;&lt;/a&gt; module which allow us to integrate &lt;a href=&#34;https://github.com/google/flax&#34;&gt;&lt;code&gt;Flax&lt;/code&gt;&lt;/a&gt; models with &lt;a href=&#34;https://github.com/pyro-ppl/numpyro&#34;&gt;&lt;code&gt;NumPyro&lt;/code&gt;&lt;/a&gt; models. I am interested in this because I want to experiment with complex bayesian models with larger datasets.&lt;/p&gt;&#xA;&lt;p&gt;Most of the main components can be found in the great blog post &lt;a href=&#34;https://omarfsosa.github.io/bayesian_nn&#34;&gt;Bayesian Neural Networks with Flax and Numpyro&lt;/a&gt;. The author takes a different path working directly with potentials, but he also points out the recent addition of the &lt;code&gt;numpyro/contrib/module.py&lt;/code&gt; module. The main difference with the model presented here is that I am using two components in the model (to model the mean and standard deviation of the data), I use &lt;em&gt;stochastic variational inference&lt;/em&gt; instead of &lt;em&gt;MCMC&lt;/em&gt; and I work with scaling transformations.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Time Series Modeling with HSGP: Baby Births Example</title>
      <link>/birthdays/</link>
      <pubDate>Tue, 02 Jan 2024 00:00:00 +0000</pubDate>
      <guid>/birthdays/</guid>
      <description>&lt;p&gt;In this notebook we want to reproduce a classical example of using Gaussian processes to model time series data: The birthdays data set. I first encountered this example in the seminal book &lt;a href=&#34;http://www.stat.columbia.edu/~gelman/book/BDA3.pdf&#34;&gt;Chapter 21, Bayesian Data Analysis (Third edition)&lt;/a&gt; when learning about the subject. One thing I rapidly realized was that fitting these types of models in practice is very computationally expensive and sometimes almost infeasible for real industry applications where the data size is larger than all of these academic examples. Recently, there has been a lot of progress in approximation methods to speed up the computations. We investigate one such method: the Hilbert Space Gaussian Process (HSGP) approximation introduced in &lt;a href=&#34;https://link.springer.com/article/10.1007/s11222-019-09886-w&#34;&gt;Hilbert space methods for reduced-rank Gaussian process regression&lt;/a&gt;. The main idea of this method relies on the Laplacian‚Äôs spectral decomposition to approximate kernels‚Äô spectral measures as a function of basis functions. The key observation is that the basis functions in the reduced-rank approximation do not depend on the hyperparameters of the covariance function for the Gaussian process. This allows us to speed up the computations tremendously. We do not go into the mathematical details here (we might do this in a future post), as the original article is very well written and easy to follow (see also the great paper &lt;a href=&#34;https://link.springer.com/article/10.1007/s11222-022-10167-2&#34;&gt;Practical Hilbert space approximate Bayesian Gaussian processes for probabilistic programming&lt;/a&gt;). Instead, we reproduce this classical example using PyMC using a very raw implementation from &lt;a href=&#34;https://num.pyro.ai/en/stable/examples/hsgp.html&#34;&gt;&lt;code&gt;NumPyro&lt;/code&gt; Docs - Example: Hilbert space approximation for Gaussian processes&lt;/a&gt;, which is a great resource to learn about the method internals (so it is also strongly recommended!).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Non-Parametric Product Life Cycle Modeling</title>
      <link>/iphone_trends/</link>
      <pubDate>Sun, 10 Dec 2023 00:00:00 +0000</pubDate>
      <guid>/iphone_trends/</guid>
      <description>&lt;p&gt;In this notebook we present an example of how to use a combination of Bayesian hierarchical models and the non-parametric methods , namely bayesian additive trees (&lt;a href=&#34;https://www.pymc.io/projects/bart/en/latest/&#34;&gt;BART&lt;/a&gt;), to model the product life cycles. This approach is motivated by previous work in cohort analysis, see &lt;a href=&#34;https://juanitorduz.github.io/revenue_retention/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;As a case study we use the Google search index (trends) data for iPhones worldwide. We use the data of four different models to predict the development of the latest iPhone. The model presented for this specific example can be easily extended for other products and product life cycles structures.&lt;/p&gt;</description>
    </item>
    <item>
      <title>NumPyro with Pathfinder</title>
      <link>/numpyro_pathfinder/</link>
      <pubDate>Mon, 04 Dec 2023 00:00:00 +0000</pubDate>
      <guid>/numpyro_pathfinder/</guid>
      <description>&lt;p&gt;In this notebook we describe how to use &lt;a href=&#34;https://blackjax-devs.github.io/blackjax/index.html&#34;&gt;&lt;code&gt;blackjax&lt;/code&gt;&lt;/a&gt;‚Äôs &lt;a href=&#34;https://blackjax-devs.github.io/sampling-book/algorithms/pathfinder.html&#34;&gt;&lt;code&gt;pathfinder&lt;/code&gt;&lt;/a&gt; implementation to do inference with a &lt;a href=&#34;https://num.pyro.ai/en/stable/&#34;&gt;&lt;code&gt;numpyro&lt;/code&gt;&lt;/a&gt; model.&lt;/p&gt;&#xA;&lt;p&gt;I am simply putting some pieces together from the following resources (strongly recommended to read):&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;References:&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Blackjax docs: &lt;a href=&#34;https://blackjax-devs.github.io/blackjax/examples/howto_use_numpyro.html&#34;&gt;Use with Numpyro models&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;Blackjax Sampling Book: &lt;a href=&#34;https://blackjax-devs.github.io/sampling-book/algorithms/pathfinder.html&#34;&gt;Pathfinder&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;Numpyro Issue &lt;a href=&#34;https://github.com/pyro-ppl/numpyro/issues/1485&#34;&gt;#1485&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/pymc-devs/pymc-experimental/blob/main/pymc_experimental/inference/pathfinder.py&#34;&gt;PyMC Experimental - Pathfinder&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://arxiv.org/abs/2108.03782&#34;&gt;Pathfinder: Parallel quasi-Newton variational inference&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div id=&#34;what-and-why-pathfinder&#34; class=&#34;section level3&#34;&gt;&#xA;&lt;h3&gt;What and Why Pathfinder?&lt;/h3&gt;&#xA;&lt;p&gt;From the &lt;a href=&#34;https://arxiv.org/abs/2108.03782&#34;&gt;paper&lt;/a&gt;‚Äôs abstract:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;What?&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;em&gt;We propose Pathfinder, a variational method for approximately sampling from differentiable log densities. Starting from a random initialization, Pathfinder locates normal approximations to the target density along a quasi-Newton optimization path, with local covariance estimated using the inverse Hessian estimates produced by the optimizer. Pathfinder returns draws from the approximation with the lowest estimated Kullback-Leibler (KL) divergence to the true posterior.&lt;/em&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Causal Bandits: Causality, Marketing &amp; Simulations</title>
      <link>/causal_bandits/</link>
      <pubDate>Sun, 19 Nov 2023 00:00:00 +0000</pubDate>
      <guid>/causal_bandits/</guid>
      <description>&lt;p&gt;I had the great opportunity to have a conversation with &lt;a href=&#34;https://alxndr.io/&#34;&gt;Aleksander Molak&lt;/a&gt; about causality, marketing and simulations as well as my career from academia to industry. Check it out!&lt;/p&gt;&#xA;&lt;center&gt;&#xA;&lt;iframe width=&#34;800&#34; height=&#34;500&#34; src=&#34;https://www.youtube.com/embed/bTTSg91pFUk?rel=0s&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&#xA;&lt;/iframe&gt;&#xA;&lt;/center&gt;</description>
    </item>
    <item>
      <title>Multilevel Elasticities for a Single SKU - Part II.</title>
      <link>/multilevel_elasticities_single_sku_2/</link>
      <pubDate>Mon, 13 Nov 2023 00:00:00 +0000</pubDate>
      <guid>/multilevel_elasticities_single_sku_2/</guid>
      <description>&lt;p&gt;In this notebook we go deeper into the last covariance model presented in the previous blog post &lt;a href=&#34;https://juanitorduz.github.io/multilevel_elasticities_single_sku/&#34;&gt;Multilevel Elasticities for a Single SKU&lt;/a&gt;. In particular we describe how to generate posterior predictive samples from an unseen region by the model. This can be useful for scenario planning: once can simulated outcome quantities from price ranges through the elasticity estimates (with uncertainty!)&lt;/p&gt;&#xA;&lt;p&gt;We strongly recommend reading the previous blog post before reading this one as we will skip the EDA and baseline model comparison parts.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Multilevel Elasticities for a Single SKU - Part I.</title>
      <link>/multilevel_elasticities_single_sku/</link>
      <pubDate>Thu, 10 Aug 2023 00:00:00 +0000</pubDate>
      <guid>/multilevel_elasticities_single_sku/</guid>
      <description>&lt;p&gt;In this notebook I want to experiment with some basic models for price elasticity estimation in the simple context of a simple &lt;a href=&#34;https://en.wikipedia.org/wiki/Stock_keeping_unit&#34;&gt;sku&lt;/a&gt; across multiple stores and regions. The motivation is to have a concrete example of the elasticity models presented in the Chapter 11: Big Data Pricing Models of the book &lt;a href=&#34;https://www.routledge.com/Pricing-Analytics-Models-and-Advanced-Quantitative-Techniques-for-Product/Paczkowski/p/book/9781138623934&#34;&gt;Pricing Analytics&lt;/a&gt; by &lt;a href=&#34;https://www.linkedin.com/in/walter-paczkowski-a17a1511/&#34;&gt;Walter R. Paczkowski&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;div id=&#34;elasticity-definition&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Elasticity Definition&lt;/h2&gt;&#xA;&lt;p&gt;Here I provide a very succinct definition of elasticity (there is a vast literature on this topic, see the reference above). The elasticity of a variable &lt;span class=&#34;math inline&#34;&gt;\(y(x, z)\)&lt;/span&gt; with respect to another variable &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; is defined as the percentage change in &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; for a one percent change in &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;. Mathematically, this is written as&#xA;&lt;span class=&#34;math display&#34;&gt;\[&#xA;\eta = \frac{\partial \log(y(x, z))}{\partial \log(x)}&#xA;\]&lt;/span&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Time-Varying Regression Coefficients via Hilbert Space Gaussian Process Approximation</title>
      <link>/bikes_gp/</link>
      <pubDate>Wed, 05 Jul 2023 00:00:00 +0000</pubDate>
      <guid>/bikes_gp/</guid>
      <description>&lt;p&gt;In this notebook we present an example of a regression model with time varying coefficients using Gaussian processes. In particular, we use a Hilbert space Gaussian process approximation in &lt;a href=&#34;https://www.pymc.io/welcome.html&#34;&gt;&lt;code&gt;pymc&lt;/code&gt;&lt;/a&gt; to speed up the computations (see &lt;a href=&#34;https://www.pymc.io/projects/docs/en/latest/api/gp/generated/pymc.gp.HSGP.html&#34;&gt;&lt;code&gt;HSGP&lt;/code&gt;&lt;/a&gt;). We continue using the &lt;code&gt;bikes&lt;/code&gt; dataset from the previous posts (&lt;a href=&#34;https://juanitorduz.github.io/interpretable_ml/&#34;&gt;Exploring Tools for Interpretable Machine Learning&lt;/a&gt; and &lt;a href=&#34;https://juanitorduz.github.io/bikes_pymc/&#34;&gt;Time-Varying Regression Coefficients via Gaussian Random Walk in PyMC&lt;/a&gt;). Please refer to those posts for more details on the dataset, EDA and base models. In essence, we are trying to model bike count rentals as a function of meteorological variables and seasonality. We are particularly interested in the marginal effect of temperature on bike rentals, which we expect to be non-linear.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Using Data Science for Bad Decision-Making: A Case Study</title>
      <link>/causal_inference_example/</link>
      <pubDate>Fri, 16 Jun 2023 00:00:00 +0000</pubDate>
      <guid>/causal_inference_example/</guid>
      <description>&lt;p&gt;You will probably be intrigued by the title of this post. In this notebook I do not want to present a fancy data science trick or to test a novel technique. I would simply like to tell a story. A story about how data science can be used to make bad decisions. ‚ÄúHow can this be?‚Äù you might ask. Everyone has been saying that data is the way to unlock insights to gain a competitive advantage. Well, it is true. But it is also true that data can be used to make decisions that can actually hurt your business. There are many possible reasons you could think of (and you might even have experienced some of them). The story I am about to tell won‚Äôt be about bad algorithms or bad data. It will be about thinking about data as simply&lt;/p&gt;</description>
    </item>
    <item>
      <title>Regression Discontinuity with GLMs and Kernel Weighting</title>
      <link>/regression_glmdiscontinuity_glm/</link>
      <pubDate>Sat, 10 Jun 2023 00:00:00 +0000</pubDate>
      <guid>/regression_glmdiscontinuity_glm/</guid>
      <description>&lt;p&gt;In this notebook we explore &lt;a href=&#34;https://en.wikipedia.org/wiki/Regression_discontinuity_design&#34;&gt;regression discontinuity design&lt;/a&gt; using &lt;a href=&#34;https://en.wikipedia.org/wiki/Generalized_linear_model&#34;&gt;generalized linear models (GLMs)&lt;/a&gt; and kernel weighting from a bayesian perspective. The motivation comes from applications when:&lt;/p&gt;&#xA;&lt;ol style=&#34;list-style-type: decimal&#34;&gt;&#xA;&lt;li&gt;The data does not fit the usual linear regression OLS normal likelihood (e.g.¬†modeling count data).&lt;/li&gt;&#xA;&lt;li&gt;The data size is limited.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;In addition, we experiment with kernel weighting to weight the data points near the cutoff more heavily. This is a common technique in RD analysis, but it is not always clear how to do this with GLMs in the bayesian framework. We show how to do this with the &lt;a href=&#34;https://www.pymc.io/welcome.html&#34;&gt;PyMC&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>ATE Estimation for Count Data</title>
      <link>/causal_inference_negative_binomial/</link>
      <pubDate>Wed, 07 Jun 2023 00:00:00 +0000</pubDate>
      <guid>/causal_inference_negative_binomial/</guid>
      <description>&lt;p&gt;This notebook is a continuation of the &lt;a href=&#34;https://juanitorduz.github.io/causal_inference_logistic/&#34;&gt;previous notebook&lt;/a&gt; on ATE estimation for binary data with logistic regression based on the sequence of (great!) posts by &lt;a href=&#34;https://solomonkurz.netlify.app/&#34;&gt;Solomon Kurz&lt;/a&gt;. In this notebook, we will focus on count data. We reproduce in python an example presented in the post &lt;a href=&#34;https://solomonkurz.netlify.app/blog/2023-05-07-causal-inference-with-count-regression/&#34;&gt;&lt;em&gt;Causal inference with count regression&lt;/em&gt;&lt;/a&gt; by Solomon Kurz. Our intention is to simply show how to port these type of model to &lt;a href=&#34;https://bambinos.github.io/bambi/&#34;&gt;&lt;code&gt;bambi&lt;/code&gt;&lt;/a&gt;. In addition, as in the previous post, we compare the ATE estimation with a simple linear regression model.&lt;/p&gt;</description>
    </item>
    <item>
      <title>ATE Estimation with Logistic Regression</title>
      <link>/causal_inference_logistic/</link>
      <pubDate>Sun, 04 Jun 2023 00:00:00 +0000</pubDate>
      <guid>/causal_inference_logistic/</guid>
      <description>&lt;p&gt;In this notebook, I want to reproduce some components of the extensive blog post &lt;a href=&#34;https://solomonkurz.netlify.app/blog/2023-04-30-causal-inference-with-bayesian-models/&#34;&gt;Causal inference with Bayesian models&lt;/a&gt; by &lt;a href=&#34;https://solomonkurz.netlify.app/&#34;&gt;Solomon Kurz&lt;/a&gt;. Specifically, I want to deep dive into the &lt;em&gt;logistic regression model&lt;/em&gt; used to estimate the &lt;em&gt;average treatment effect&lt;/em&gt; (ATE) of the study &lt;a href=&#34;https://journals.plos.org/plosmedicine/article?id=10.1371/journal.pmed.1002479&#34;&gt;&lt;em&gt;Internet-accessed sexually transmitted infection (e-STI) testing and results service: A randomised, single-blind, controlled trial&lt;/em&gt;&lt;/a&gt; by Wilson, et.al. I can only recommend to read the original sequence of posts Solomon has written on causal inference. They are very well written, easy to follow and provide a lot of insights into the topic.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Bayesian Methods in Modern Marketing Analytics Webinar with PyMC Labs</title>
      <link>/marketing_bayes_webinar/</link>
      <pubDate>Wed, 31 May 2023 00:00:00 +0000</pubDate>
      <guid>/marketing_bayes_webinar/</guid>
      <description>&lt;p&gt;Here I want to share the recording and &lt;a href=&#34;../html/marketing_bayes.html&#34;&gt;slides&lt;/a&gt; of the webinar &lt;strong&gt;Bayesian Methods in Modern Marketing Analytics&lt;/strong&gt; in collaboration with &lt;a href=&#34;https://www.pymc-labs.io/&#34;&gt;PyMC Labs&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; During the webinar, we will discuss some of the most crucial topics in marketing analytics: media spend optimization through media mix models and experimentation, and customer lifetime value estimation. We will approach these topics from a Bayesian perspective, as it gives us great tools to have better models and more actionable insights. We will take this opportunity to describe our join with PyMC Labs in open-sourcing some of these tools in our brand-new &lt;a href=&#34;https://www.pymc-marketing.io/&#34;&gt;&lt;code&gt;pymc-marketing&lt;/code&gt;&lt;/a&gt; Python package.&lt;/p&gt;</description>
    </item>
    <item>
      <title>How to vectorize an scikit-learn transformer over a numpy array?</title>
      <link>/vectorize_sklearn_transformer/</link>
      <pubDate>Mon, 01 May 2023 00:00:00 +0000</pubDate>
      <guid>/vectorize_sklearn_transformer/</guid>
      <description>&lt;p&gt;In this short post, I show how to vectorize an &lt;a href=&#34;https://scikit-learn.org/stable/&#34;&gt;&lt;code&gt;scikit-learn&lt;/code&gt;&lt;/a&gt; transformer over a &lt;a href=&#34;https://numpy.org/doc/stable/&#34;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt; array. That is, how to apply a transformer along a specific axes of a &lt;code&gt;numpy&lt;/code&gt; array. I have found this to be particularly useful when working with output sample posterior distributions from a bayesian model where I want to apply a transformer to each sample. This is not particularly difficult, but I always forget how to do it, so I thought I would write it down once and for all üòÑ.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Counting the Number of Kitas per PLZ in Berlin using a Hierarchical Bayesian Model</title>
      <link>/kitas-hierarchical/</link>
      <pubDate>Fri, 28 Apr 2023 00:00:00 +0000</pubDate>
      <guid>/kitas-hierarchical/</guid>
      <description>&lt;p&gt;This notebook is the continuation of data gathering and data analysis post &lt;a href=&#34;https://juanitorduz.github.io/kitas_berlin/&#34;&gt;Open Data: Berlin Kitas&lt;/a&gt;. In this second part we use the data gathered to model the number of Kitas per PLZ in Berlin using a hierarchical bayesian model. The hierarchy is defined by the Berlin districts. The objective is to develop a sound basic model which can be enhanced in the future with a richer data set.&lt;/p&gt;&#xA;&lt;div id=&#34;prepare-notebook&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Prepare Notebook&lt;/h2&gt;&#xA;&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;import arviz as az&#xA;import geopandas as gpd&#xA;import jax.numpy as jnp&#xA;import matplotlib.pyplot as plt&#xA;import numpy as np&#xA;import numpyro&#xA;import numpyro.distributions as dist&#xA;import pandas as pd&#xA;import seaborn as sns&#xA;from jax import random&#xA;from jaxlib.xla_extension import ArrayImpl&#xA;from numpyro.infer import MCMC, NUTS, Predictive&#xA;from sklearn.preprocessing import LabelEncoder&#xA;&#xA;plt.style.use(&amp;quot;bmh&amp;quot;)&#xA;plt.rcParams[&amp;quot;figure.figsize&amp;quot;] = [10, 6]&#xA;plt.rcParams[&amp;quot;figure.dpi&amp;quot;] = 100&#xA;plt.rcParams[&amp;quot;figure.facecolor&amp;quot;] = &amp;quot;white&amp;quot;&#xA;&#xA;numpyro.set_host_device_count(n=4)&#xA;&#xA;rng_key = random.PRNGKey(seed=0)&#xA;&#xA;%load_ext autoreload&#xA;%autoreload 2&#xA;%config InlineBackend.figure_format = &amp;quot;retina&amp;quot;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;div id=&#34;read-data&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Read Data&lt;/h2&gt;&#xA;&lt;p&gt;Let‚Äôs start by reading the data we gathered in the previous post.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Simple Hierarchical Model with NumPyro: Cookie Chips Example</title>
      <link>/cookies_example_numpyro/</link>
      <pubDate>Mon, 24 Apr 2023 00:00:00 +0000</pubDate>
      <guid>/cookies_example_numpyro/</guid>
      <description>&lt;p&gt;This notebook presents a simple example of a hierarchical model using &lt;a href=&#34;https://num.pyro.ai/en/latest/index.html#&#34;&gt;&lt;code&gt;NumPyro&lt;/code&gt;&lt;/a&gt;. The example is based on the cookie chips example in presented in the post &lt;a href=&#34;https://juanitorduz.github.io/intro_pymc3/&#34;&gt;Introduction to Bayesian Modeling with PyMC3&lt;/a&gt;. There are many great resources regarding bayesian hierarchical model and probabilistic programming &lt;a href=&#34;https://num.pyro.ai/en/latest/index.html#&#34;&gt;&lt;code&gt;NumPyro&lt;/code&gt;&lt;/a&gt;. This notebook aims to provide a succinct simple example to get started.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt; Well, the real reason is that I want to get acquainted other probabilistic programming libraries in order to abstract the core principles of probabilistic programming.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Experimentation, Non-Compliance and Instrumental Variables with PyMC</title>
      <link>/iv_pymc/</link>
      <pubDate>Mon, 20 Feb 2023 00:00:00 +0000</pubDate>
      <guid>/iv_pymc/</guid>
      <description>&lt;p&gt;In this notebook we present an example of how to use PyMC to estimate the effect of a treatment in an experiment where there is non-compliance through the use of instrumental variables.&lt;/p&gt;&#xA;&lt;p&gt;By non-compliance we mean that the treatment assignment does not guarantee that the treatment is actually received by the treated. The main challenge is that we can not simply estimate the treatment effect as a difference in means since the non-compliance mechanism is most of the time not at random and may introduce confounders. For a more detailed discussion of the problem see &lt;a href=&#34;https://matheusfacure.github.io/python-causality-handbook/09-Non-Compliance-and-LATE.html&#34;&gt;Chapter 9&lt;/a&gt; in the (amazing!) book &lt;a href=&#34;https://matheusfacure.github.io/python-causality-handbook/landing-page.html&#34;&gt;&lt;em&gt;Causal Inference for The Brave and True&lt;/em&gt;&lt;/a&gt; by &lt;a href=&#34;https://github.com/matheusfacure&#34;&gt;Matheus Facure Alves&lt;/a&gt;. One very common tool to tackle such problem are instrumental variables (see &lt;a href=&#34;https://matheusfacure.github.io/python-causality-handbook/08-Instrumental-Variables.html&#34;&gt;Chapter 8&lt;/a&gt;) for a nice introduction. In essence, we can use the variant assignment as an instrument to control for confounders introduced by the non-compliance mechanism.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Cohort Revenue &amp; Retention Analysis: A Bayesian Approach</title>
      <link>/revenue_retention/</link>
      <pubDate>Mon, 23 Jan 2023 00:00:00 +0000</pubDate>
      <guid>/revenue_retention/</guid>
      <description>&lt;p&gt;In this notebook we extend the cohort retention model presented in the post &lt;a href=&#34;https://juanitorduz.github.io/retention_bart/&#34;&gt;Cohort Retention Analysis with BART&lt;/a&gt; so that we just model retention &lt;strong&gt;and&lt;/strong&gt; per cohort simultaneously (we recommend reading the referenced post before this one). The idea is to keep modeling the retention using a Bayesian Additive Regression Tree (BART) model (see &lt;a href=&#34;https://www.pymc.io/projects/bart/en/latest/&#34;&gt;&lt;code&gt;pymc-bart&lt;/code&gt;&lt;/a&gt;) and linearly model the revenue per cohort using a Gamma distribution. We couple the retention and revenue components in a similar way as presented in the notebook &lt;a href=&#34;https://www.pymc.io/projects/examples/en/latest/case_studies/bayesian_ab_testing_introduction.html&#34;&gt;Introduction to Bayesian A/B Testing&lt;/a&gt;. For this simulated example we use a synthetic data set, see the blog post &lt;a href=&#34;https://juanitorduz.github.io/retention/&#34;&gt;A Simple Cohort Retention Analysis in PyMC&lt;/a&gt; For more details. &lt;a href=&#34;https://github.com/juanitorduz/website_projects/blob/master/data/retention_data.csv&#34;&gt;Here&lt;/a&gt; you can find the data to reproduce the results.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Cohort Retention Analysis with BART</title>
      <link>/retention_bart/</link>
      <pubDate>Mon, 02 Jan 2023 00:00:00 +0000</pubDate>
      <guid>/retention_bart/</guid>
      <description>&lt;p&gt;In this notebook we study an alternative approach for the cohort analysis problem presented in &lt;a href=&#34;https://juanitorduz.github.io/retention/&#34;&gt;A Simple Cohort Retention Analysis in PyMC&lt;/a&gt;. Instead of using a linear model to estimate the retention rate, we use a Bayesian Additive Regression Tree (BART) model(see &lt;a href=&#34;https://www.pymc.io/projects/bart/en/latest/&#34;&gt;&lt;code&gt;pymc-bart&lt;/code&gt;&lt;/a&gt;). The BART model is a flexible non-parametric model that can be used to model complex relationships between the response and the predictors.&lt;/p&gt;&#xA;&lt;div id=&#34;prepare-notebook&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Prepare Notebook&lt;/h2&gt;&#xA;&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;import arviz as az&#xA;import matplotlib.pyplot as plt&#xA;import matplotlib.ticker as mtick&#xA;import numpy as np&#xA;import pandas as pd&#xA;import pymc as pm&#xA;import pymc_bart as pmb&#xA;import pytensor.tensor as pt&#xA;import seaborn as sns&#xA;&#xA;from scipy.special import expit, logit&#xA;from sklearn.preprocessing import LabelEncoder&#xA;from pymc_bart.split_rules import ContinuousSplitRule, SubsetSplitRule&#xA;&#xA;az.style.use(&amp;quot;arviz-darkgrid&amp;quot;)&#xA;plt.rcParams[&amp;quot;figure.figsize&amp;quot;] = [12, 7]&#xA;plt.rcParams[&amp;quot;figure.dpi&amp;quot;] = 100&#xA;plt.rcParams[&amp;quot;figure.facecolor&amp;quot;] = &amp;quot;white&amp;quot;&#xA;&#xA;%load_ext autoreload&#xA;%autoreload 2&#xA;%config InlineBackend.figure_format = &amp;quot;retina&amp;quot;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;seed: int = sum(map(ord, &amp;quot;retention&amp;quot;))&#xA;rng: np.random.Generator = np.random.default_rng(seed=seed)&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;div id=&#34;read-data&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Read Data&lt;/h2&gt;&#xA;&lt;p&gt;Here we simply read the data from the previous post.&lt;/p&gt;</description>
    </item>
    <item>
      <title>A Simple Cohort Retention Analysis in PyMC</title>
      <link>/retention/</link>
      <pubDate>Tue, 20 Dec 2022 00:00:00 +0000</pubDate>
      <guid>/retention/</guid>
      <description>&lt;p&gt;In this notebook we present a simple approach to study cohort retention analysis through a simulated data set. The aim is to understand how retention rates change over time and provide a simple model to predict them (with uncertainty estimates!). We do not expect this technique to be a silver bullet for all retention problems, but rather a simple approach to get started with the problem.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt; A motivation for this notebook was the great post &lt;em&gt;&lt;a href=&#34;https://www.austinrochford.com/posts/apc-pymc.html&#34;&gt;Bayesian Age/Period/Cohort Models in Python with PyMC&lt;/a&gt;&lt;/em&gt; by &lt;a href=&#34;https://www.austinrochford.com/about.html&#34;&gt;Austin Rochford&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Geo-Experimentation via Time Based Regression in PyMC</title>
      <link>/time_based_regression_pymc/</link>
      <pubDate>Thu, 01 Dec 2022 00:00:00 +0000</pubDate>
      <guid>/time_based_regression_pymc/</guid>
      <description>&lt;div id=&#34;introduction&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;In this notebook I describe and present an implementation of the &lt;strong&gt;time based regression&lt;/strong&gt; (TBR) approach to marketing campaign analysis in the context of geo experimentation presented in the paper &lt;a href=&#34;https://research.google/pubs/pub45950/&#34;&gt;Estimating Ad Effectiveness using Geo Experiments in a Time-Based Regression Framework&lt;/a&gt; by Jouni Kerman, Peng Wang and Jon Vaver (Google, Inc.¬†2017). I strongly recommend reading the paper as it is quite clear in the exposition of the approach and presents some simulation results. Here I will focus on the basic model specification and on the implementation in PyMC.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Offline Campaign Analysis Measurement: A journey through causal impact, geo-experimentation and synthetic control</title>
      <link>/wolt_ds_meetup/</link>
      <pubDate>Tue, 25 Oct 2022 00:00:00 +0000</pubDate>
      <guid>/wolt_ds_meetup/</guid>
      <description>&lt;p&gt;In October 2022 I had the opportunity to give a talk at the &lt;a href=&#34;https://dainstudios.com/event/data-science-at-wolt/&#34;&gt;Helsinki Data Science Meetup&lt;/a&gt; hosted by &lt;strong&gt;Wolt&lt;/strong&gt;. Here I want to share the recording of my talk.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; The talk will show how to measure offline campaigns using causal inference techniques. In particular it‚Äôll focus on tapping into the potential of synthetic control, geo-experiments via time-based regression, and Google‚Äôs Causal-Impact Method.&lt;/p&gt;&#xA;&lt;center&gt;&#xA;&lt;iframe width=&#34;800&#34; height=&#34;500&#34; src=&#34;https://www.youtube.com/embed/gMaxM8PAcpo?rel=0&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&#xA;&lt;/iframe&gt;&#xA;&lt;/center&gt;&#xA;&lt;hr /&gt;&#xA;&lt;div id=&#34;code-to-generate-data&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Code to generate data&lt;/h2&gt;&#xA;&lt;p&gt;You can find the raw data &lt;a href=&#34;https://raw.githubusercontent.com/juanitorduz/website_projects/master/data/zipcodes_data.csv&#34;&gt;here&lt;/a&gt; and the code &lt;a href=&#34;https://github.com/juanitorduz/website_projects/blob/master/Python/zipcode_data.py&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Scikit-Learn Example in PyMC: Gaussian Process Classifier</title>
      <link>/sklearn_pymc_classifier/</link>
      <pubDate>Sat, 24 Sep 2022 00:00:00 +0000</pubDate>
      <guid>/sklearn_pymc_classifier/</guid>
      <description>&lt;p&gt;In this notebook we want to describe how to port a couple of classification examples from &lt;a href=&#34;https://scikit-learn.org/stable/auto_examples/classification/plot_classifier_comparison.html#sphx-glr-auto-examples-classification-plot-classifier-comparison-py&#34;&gt;scikit-learn‚Äôs documentation (classifier comparison)&lt;/a&gt; to PyMC. We focus in the classical &lt;a href=&#34;https://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_moons.html#sklearn.datasets.make_moons&#34;&gt;&lt;code&gt;moons&lt;/code&gt;&lt;/a&gt; synthetic dataset.&lt;/p&gt;&#xA;&lt;div id=&#34;prepare-notebook&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Prepare Notebook&lt;/h2&gt;&#xA;&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;import arviz as az&#xA;import matplotlib.pyplot as plt&#xA;import numpy as np&#xA;import pandas as pd&#xA;import pymc as pm&#xA;import pymc.sampling_jax&#xA;import seaborn as sns&#xA;from sklearn.datasets import make_moons&#xA;from sklearn.metrics import accuracy_score&#xA;from sklearn.model_selection import train_test_split&#xA;&#xA;&#xA;plt.style.use(&amp;quot;bmh&amp;quot;)&#xA;plt.rcParams[&amp;quot;figure.figsize&amp;quot;] = [8, 6]&#xA;plt.rcParams[&amp;quot;figure.dpi&amp;quot;] = 100&#xA;plt.rcParams[&amp;quot;figure.facecolor&amp;quot;] = &amp;quot;white&amp;quot;&#xA;&#xA;%load_ext autoreload&#xA;%autoreload 2&#xA;%config InlineBackend.figure_format = &amp;quot;retina&amp;quot;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;div id=&#34;generate-raw-data&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Generate Raw Data&lt;/h2&gt;&#xA;&lt;p&gt;We generate synthetic data using the &lt;a href=&#34;https://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_moons.html#sklearn.datasets.make_moons&#34;&gt;&lt;code&gt;moons&lt;/code&gt;&lt;/a&gt; function from &lt;code&gt;sklearn.datasets&lt;/code&gt; and split it into a training and test set.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Synthetic Control in PyMC</title>
      <link>/synthetic_control_pymc/</link>
      <pubDate>Tue, 09 Aug 2022 00:00:00 +0000</pubDate>
      <guid>/synthetic_control_pymc/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;em&gt;Synthetic control can be considered ‚Äúthe most important innovation in the policy evaluation literature in the last few years‚Äù&lt;/em&gt; (see &lt;a href=&#34;https://www.aeaweb.org/articles?id=10.1257/jep.31.2.3&#34;&gt;The State of Applied Econometrics: Causality and Policy Evaluation&lt;/a&gt; by Susan Athey and Guido W. Imbens).&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;In this notebook we provide an example of how to implement a synthetic control problem in &lt;a href=&#34;https://github.com/pymc-devs/pymc&#34;&gt;PyMC&lt;/a&gt; to answer a ‚Äúwhat if this had happened?‚Äù type of question in the context of causal inference. We reproduce the results of the example provided in the great book &lt;a href=&#34;https://matheusfacure.github.io/python-causality-handbook/landing-page.html&#34;&gt;Causal Inference for The Brave and True&lt;/a&gt; by &lt;a href=&#34;https://matheusfacure.github.io/&#34;&gt;Matheus Facure&lt;/a&gt;. Specifically, we look into the problem of estimating the &lt;em&gt;effect of cigarette taxation on its consumption&lt;/em&gt; presented in Chapter &lt;a href=&#34;https://matheusfacure.github.io/python-causality-handbook/15-Synthetic-Control.html&#34;&gt;15 - Synthetic Control&lt;/a&gt;. The purpose of this notebook is not to present a general description of this method but rather show how to implement it in PyMC. Therefore, we strongly recommend to look into the book to understand the problem, motivation and details of the method.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Modeling Short Time Series with Prior Knowledge in PyMC</title>
      <link>/short_time_series_pymc/</link>
      <pubDate>Tue, 19 Jul 2022 00:00:00 +0000</pubDate>
      <guid>/short_time_series_pymc/</guid>
      <description>&lt;p&gt;In this notebook I want to reproduce in &lt;a href=&#34;https://github.com/pymc-devs/pymc&#34;&gt;PyMC&lt;/a&gt; the methodology described in the amazing blog post &lt;a href=&#34;https://minimizeregret.com/short-time-series-prior-knowledge&#34;&gt;Modeling Short Time Series with Prior Knowledge&lt;/a&gt; by &lt;a href=&#34;https://minimizeregret.com/about/&#34;&gt;Tim Radtke&lt;/a&gt; to forecast short time series using &lt;em&gt;bayesian transfer learning&lt;/em&gt; üöÄ. The main idea is to transfer information (e.g.¬†long term seasonality) from a long time series to a short time series via prior distributions. Tim‚Äôs blog post treats a very concrete example where all the concepts become very concrete. The challenge of the example is to generate long term forecast for a short time series of bike sales data. Specifically, the input sales data consists of three months of daily data and the objective is to generate at least a two years forecast. In general this is very hard to to with commonly available methods (as we will show below) due the fact we do not have enough historical data to capture seasonal patterns. For this concrete example, we do expect to have a strong yearly seasonal pattern as bike sales are usually much higher during summer than in winter. Hence, we could use temperature as a proxy for this seasonal pattern. However, as mentioned above, we can not simply try to use such data in a model with just 3 months of daily data ‚Ä¶ ¬Ø\&lt;em&gt;(„ÉÑ)&lt;/em&gt;/¬Ø ‚Ä¶&lt;/p&gt;</description>
    </item>
    <item>
      <title>Time-Varying Regression Coefficients via Gaussian Random Walk in PyMC</title>
      <link>/bikes_pymc/</link>
      <pubDate>Sun, 03 Jul 2022 00:00:00 +0000</pubDate>
      <guid>/bikes_pymc/</guid>
      <description>&lt;p&gt;In this notebook we want to illustrate how to use PyMC to fit a time-varying coefficient regression model. The motivation comes from post &lt;a href=&#34;https://juanitorduz.github.io/interpretable_ml/&#34;&gt;Exploring Tools for Interpretable Machine Learning&lt;/a&gt; where we studied a time series problem, regarding the &lt;a href=&#34;https://christophm.github.io/interpretable-ml-book/bike-data.html&#34;&gt;prediction of the number of bike rentals&lt;/a&gt;, from a machine learning perspective. Concretely, we fitted and compared two machine learning models: a linear regression with interactions and a gradient boost model (XGBoost). The models regressors were mainly meteorological data and seasonality features. One interesting feature we saw, through &lt;a href=&#34;https://christophm.github.io/interpretable-ml-book/pdp.html&#34;&gt;PDP&lt;/a&gt; and &lt;a href=&#34;https://christophm.github.io/interpretable-ml-book/ice.html&#34;&gt;ICE&lt;/a&gt; plots was that the temperature feature had a non-constant effect over the bike rentals (see &lt;a href=&#34;https://christophm.github.io/interpretable-ml-book/ice.html#examples-4&#34;&gt;here&lt;/a&gt;). Indeed, when the temperature is high (more than 25 degrees approximately), the bike rentals are negatively impacted by the temperature (to be fair, this is when controlling by other regressors) on average. What we want to do in this notebook is to tackle the same problem from a different perspective. Namely, use to use a &lt;a href=&#34;https://www.pymc.io/projects/docs/en/stable/api/distributions/generated/pymc.GaussianRandomWalk.html&#34;&gt;GaussianRandomWalk&lt;/a&gt; to model the interaction effect between the temperature and the bike rentals. We of course start with the simple regression baseline for comparison.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Data Talks Club: Machine Learning in Marketing</title>
      <link>/machine_learning_marketing/</link>
      <pubDate>Tue, 17 May 2022 00:00:00 +0000</pubDate>
      <guid>/machine_learning_marketing/</guid>
      <description>&lt;p&gt;On Friday 13th of May 2022 I was invited to join &lt;a href=&#34;https://www.linkedin.com/in/agrigorev/?originalSubdomain=de&#34;&gt;Alexey Grigorev&lt;/a&gt; in an event organised by &lt;a href=&#34;https://datatalks.club/&#34;&gt;DataTalks.Club&lt;/a&gt; to talk about &lt;a href=&#34;https://datatalks.club/podcast/s09e01-machine-learning-in-marketing.html&#34;&gt;&lt;em&gt;Machine Learning in Marketing&lt;/em&gt;&lt;/a&gt;. It was a really insightful discussion and i would like to thanks the organizers who make it possible. Here is the recording:&lt;/p&gt;&#xA;&lt;center&gt;&#xA;&lt;iframe width=&#34;600&#34; height=&#34;400&#34; src=&#34;https://www.youtube.com/embed/jsAxUd_bZpw?rel=0&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&#xA;&lt;/iframe&gt;&#xA;&lt;/center&gt;&#xA;&lt;p&gt;Here are some useful links and resources about the subject:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Relevant blog post I have written about the subject:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://juanitorduz.github.io/orbit_mmm/&#34;&gt;Media Effect Estimation with Orbit‚Äôs KTR Model&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://juanitorduz.github.io/pymc_mmm/&#34;&gt;Media Effect Estimation with PyMC: Adstock, Saturation &amp;amp; Diminishing Returns&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://juanitorduz.github.io/uplift/&#34;&gt;PyConDE &amp;amp; PyData Berlin 2022: Introduction to Uplift Modeling&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://juanitorduz.github.io/bg_nbd_pymc/&#34;&gt;BG/NBD Model in PyMC&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://juanitorduz.github.io/gamma_gamma_pymc/&#34;&gt;Gamma-Gamma Model of Monetary Value in PyMC&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Books and references to learn more about marketing data science&lt;/p&gt;</description>
    </item>
    <item>
      <title>PyConDE &amp; PyData Berlin 2022: Introduction to Uplift Modeling</title>
      <link>/uplift/</link>
      <pubDate>Mon, 11 Apr 2022 00:00:00 +0000</pubDate>
      <guid>/uplift/</guid>
      <description>&lt;p&gt;In this notebook we present a simple example of &lt;a href=&#34;https://en.wikipedia.org/wiki/Uplift_modelling&#34;&gt;uplift modeling&lt;/a&gt; estimation via &lt;em&gt;meta-models&lt;/em&gt; using &lt;a href=&#34;https://github.com/uber/causalml&#34;&gt;&lt;code&gt;causalml&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;scikit-uplift&#34;&gt;&lt;code&gt;scikit-uplift&lt;/code&gt;&lt;/a&gt;. For a more detailed introduction to uplift modeling, see:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://ama.imag.fr/~amini/Publis/large-scale-benchmark.pdf&#34;&gt;Diemert, Eustache, et.al. (2020) &lt;em&gt;‚ÄúA Large Scale Benchmark for Uplift Modeling‚Äù&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://proceedings.mlr.press/v67/gutierrez17a/gutierrez17a.pdf&#34;&gt;Gutierrez, P., &amp;amp; G√©rardy, J. Y. (2017). &lt;em&gt;‚ÄúCausal Inference and Uplift Modelling: A Review of the Literature‚Äù&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.diva-portal.org/smash/get/diva2:1328437/FULLTEXT01.pdf&#34;&gt;Karlsson, H. (2019) &lt;em&gt;‚ÄúUplift Modeling: Identifying Optimal Treatment Group Allocation and Whom to Contact to Maximize Return on Investment‚Äù&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Gamma-Gamma Model of Monetary Value in PyMC</title>
      <link>/gamma_gamma_pymc/</link>
      <pubDate>Tue, 29 Mar 2022 00:00:00 +0000</pubDate>
      <guid>/gamma_gamma_pymc/</guid>
      <description>&lt;p&gt;In this notebook we describe how to fit Fader‚Äôs and Hardie‚Äôs &lt;em&gt;gamma-gamma model&lt;/em&gt; presented in the paper &lt;a href=&#34;http://www.brucehardie.com/papers/rfm_clv_2005-02-16.pdf&#34;&gt;‚ÄúRFM and CLV: Using Iso-value Curves&#xA;for Customer Base Analysis‚Äù&lt;/a&gt; and the note &lt;a href=&#34;http://www.brucehardie.com/notes/025/gamma_gamma.pdf&#34;&gt;‚ÄúThe Gamma-Gamma Model of Monetary&#xA;Value‚Äù&lt;/a&gt;. The approach is very similar as the one presented in the previous post &lt;a href=&#34;https://juanitorduz.github.io/bg_nbd_pymc/&#34;&gt;BG/NBD Model in PyMC&lt;/a&gt; where we simply ported the log-likelihood of the &lt;a href=&#34;https://github.com/CamDavidsonPilon/lifetimes&#34;&gt;&lt;code&gt;lifetimes&lt;/code&gt;&lt;/a&gt; package from &lt;code&gt;numpy&lt;/code&gt; to &lt;code&gt;pytensor&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;div id=&#34;prepare-notebook&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Prepare Notebook&lt;/h2&gt;&#xA;&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;import arviz as az&#xA;import matplotlib.pyplot as plt&#xA;import numpy as np&#xA;import pymc as pm&#xA;import pytensor.tensor as pt&#xA;import seaborn as sns&#xA;from lifetimes import GammaGammaFitter&#xA;from lifetimes.datasets import load_cdnow_summary_data_with_monetary_value&#xA;&#xA;az.style.use(&amp;quot;arviz-darkgrid&amp;quot;)&#xA;plt.rcParams[&amp;quot;figure.figsize&amp;quot;] = [12, 7]&#xA;plt.rcParams[&amp;quot;figure.dpi&amp;quot;] = 100&#xA;plt.rcParams[&amp;quot;figure.facecolor&amp;quot;] = &amp;quot;white&amp;quot;&#xA;&#xA;seed = sum(map(ord, &amp;quot;juanitorduz&amp;quot;))&#xA;rng = np.random.default_rng(seed)&#xA;&#xA;%load_ext autoreload&#xA;%autoreload 2&#xA;%config InlineBackend.figure_format = &amp;quot;retina&amp;quot;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;div id=&#34;load-data&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Load Data&lt;/h2&gt;&#xA;&lt;p&gt;We are going to use an existing data set from the &lt;a href=&#34;https://github.com/CamDavidsonPilon/lifetimes&#34;&gt;&lt;code&gt;lifetimes&lt;/code&gt;&lt;/a&gt; package documentation, see &lt;a href=&#34;https://lifetimes.readthedocs.io/en/latest/Quickstart.html&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>BG/NBD Model in PyMC</title>
      <link>/bg_nbd_pymc/</link>
      <pubDate>Thu, 03 Mar 2022 00:00:00 +0000</pubDate>
      <guid>/bg_nbd_pymc/</guid>
      <description>&lt;p&gt;In this notebook we show how to port the BG/NBD model from the the &lt;a href=&#34;https://github.com/CamDavidsonPilon/lifetimes&#34;&gt;&lt;code&gt;lifetimes&lt;/code&gt;&lt;/a&gt; (developed mainly by &lt;a href=&#34;https://github.com/CamDavidsonPilon&#34;&gt;Cameron Davidson-Pilon&lt;/a&gt;) package to &lt;a href=&#34;https://github.com/pymc-devs/pymc&#34;&gt;&lt;code&gt;pymc&lt;/code&gt;&lt;/a&gt;. The BG/NBD model, introduced in the seminal paper &lt;a href=&#34;http://brucehardie.com/papers/018/fader_et_al_mksc_05.pdf&#34;&gt;‚ÄúCounting Your Customers‚Äù the Easy Way: An Alternative to the Pareto/NBD Model&lt;/a&gt; by Peter S. Fader, Bruce G. S. Hardie and Ka Lok Lee in 2005, is used to&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;em&gt;predict future purchasing patterns, which can then serve as an input into ‚Äúlifetime value‚Äù calculations, in the ‚Äúnon-contractual‚Äù setting (i.e., where the opportunities for transactions are continuous and the time at which customers become inactive is unobserved).&lt;/em&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Media Effect Estimation with PyMC: Adstock, Saturation &amp; Diminishing Returns</title>
      <link>/pymc_mmm/</link>
      <pubDate>Fri, 11 Feb 2022 00:00:00 +0000</pubDate>
      <guid>/pymc_mmm/</guid>
      <description>&lt;p&gt;In this notebook we present a concrete example of estimating the media effects via bayesian methods, following the strategy outlined in Google‚Äôs paper &lt;a href=&#34;https://research.google/pubs/pub46001/&#34;&gt;Jin, Yuxue, et al.¬†‚ÄúBayesian methods for media mix modeling with carryover and shape effects.‚Äù (2017)&lt;/a&gt;. This example can be considered the continuation of the post &lt;a href=&#34;https://juanitorduz.github.io/orbit_mmm/&#34;&gt;Media Effect Estimation with Orbit‚Äôs KTR Model&lt;/a&gt;. However, it is not strictly necessary to read before as we make this notebook self-contained. In addition, we provide some remarks and references regarding MMM projects in practice.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Media Effect Estimation with Orbit&#39;s KTR Model</title>
      <link>/orbit_mmm/</link>
      <pubDate>Fri, 04 Feb 2022 00:00:00 +0000</pubDate>
      <guid>/orbit_mmm/</guid>
      <description>&lt;p&gt;In this notebook we want to experiment to the new &lt;a href=&#34;https://orbit-ml.readthedocs.io/en/stable/tutorials/ktr1.html&#34;&gt;KTR model&lt;/a&gt; included in the new &lt;a href=&#34;https://github.com/uber/orbit&#34;&gt;&lt;code&gt;orbit&lt;/code&gt;&lt;/a&gt;‚Äôs release &lt;a href=&#34;https://github.com/uber/orbit/releases/tag/v1.1.0&#34;&gt;(1.1)&lt;/a&gt;. In particular, we are interested in its applications to media effects estimation in the context of media mix modeling. This is one of the applications for the KTR model by the Uber‚Äôs team, see the corresponding paper &lt;a href=&#34;https://arxiv.org/abs/2106.03322&#34;&gt;Edwin, Ng, et al.¬†‚ÄúBayesian Time Varying Coefficient Model with Applications to Marketing Mix Modeling‚Äù&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;KTR stands for &lt;em&gt;kernel-based Time-varying regression&lt;/em&gt; as its main feature is to fit time-variant regression coefficients in a bayesian forecasting model. For details on the KTR model, see the paper mentioned above and &lt;a href=&#34;https://orbit-ml.readthedocs.io/en/stable/tutorials/ktr1.html&#34;&gt;KTR documentation&lt;/a&gt; where there is a great sequence of tutorials. In a nutshell, given a time series &lt;span class=&#34;math inline&#34;&gt;\(y_t\)&lt;/span&gt; the KTR models its components as &lt;span class=&#34;math inline&#34;&gt;\(y_t = l_t + s_t + r_t + \varepsilon_t\)&lt;/span&gt;, where &lt;span class=&#34;math inline&#34;&gt;\(l_t\)&lt;/span&gt; is the local-trend (level) , &lt;span class=&#34;math inline&#34;&gt;\(s_t\)&lt;/span&gt; is the seasonal component, &lt;span class=&#34;math inline&#34;&gt;\(r_t\)&lt;/span&gt; are the regression terms and &lt;span class=&#34;math inline&#34;&gt;\(\varepsilon_t\)&lt;/span&gt; is a stationary random error process. This is very similar to the &lt;a href=&#34;https://facebook.github.io/prophet/&#34;&gt;Prophet&lt;/a&gt; model (we actually compare these two models bellow). One of the main differences is that the regression coefficients are time-varying. From the model documentation:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Unobserved Components Model as a Bayesian Model with PyMC</title>
      <link>/uc_pymc/</link>
      <pubDate>Fri, 10 Dec 2021 00:00:00 +0000</pubDate>
      <guid>/uc_pymc/</guid>
      <description>&lt;p&gt;In this notebook I want to deep-dive into the idea of wrapping a &lt;a href=&#34;https://www.statsmodels.org/stable/index.html&#34;&gt;&lt;code&gt;statsmodels&lt;/code&gt;&lt;/a&gt; &lt;a href=&#34;https://www.statsmodels.org/dev/generated/statsmodels.tsa.statespace.structural.UnobservedComponents.html&#34;&gt;&lt;code&gt;UnobservedComponents&lt;/code&gt;&lt;/a&gt; model as a bayesian model with &lt;a href=&#34;https://github.com/pymc-devs/pymc&#34;&gt;PyMC&lt;/a&gt; described in the (great!) post &lt;a href=&#34;https://www.statsmodels.org/dev/examples/notebooks/generated/statespace_sarimax_pymc3.html&#34;&gt;Fast Bayesian estimation of SARIMAX models&lt;/a&gt;. This is a nice excuse to get into some internals of how PyMC works. I hope this can serve as a complement to the original post mentioned above. This post has two parts: In the first one we fit a UnobservedComponents model to a simulated time series. In the second part we describe the process of wrapping the model as a PyMC model, running the MCMC and sampling and generating out of sample predictions.&lt;/p&gt;</description>
    </item>
    <item>
      <title>ISLR2 - Survival Analysis Lab (lifelines)</title>
      <link>/islr2_survival_analysis/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      <guid>/islr2_survival_analysis/</guid>
      <description>&lt;script src=&#34;../rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;&#xA;&#xA;&#xA;&lt;p&gt;In this notebook we provide a python implementation of the lab from the &lt;em&gt;Survival Analysis - Chapter 11&lt;/em&gt; of the second edition of the book &lt;a href=&#34;https://www.statlearning.com/&#34;&gt;An Introduction to Statistical&#xA;Learning (Second Edition)&lt;/a&gt;. You can find a free pdf version of the book &lt;a href=&#34;https://web.stanford.edu/~hastie/ISLRv2_website.pdf&#34;&gt;here&lt;/a&gt;. We will use the &lt;a href=&#34;https://lifelines.readthedocs.io/en/latest/&#34;&gt;&lt;code&gt;lifelines&lt;/code&gt;&lt;/a&gt; python package, which you can find in &lt;a href=&#34;https://github.com/CamDavidsonPilon/lifelines&#34;&gt;this repository&lt;/a&gt;. There is a nice introduction into survival analysis on the &lt;a href=&#34;https://lifelines.readthedocs.io/en/latest/Survival%20Analysis%20intro.html&#34;&gt;documentation&lt;/a&gt;. There are also many concrete examples and guidelines to use the package.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Exploring Tools for Interpretable Machine Learning</title>
      <link>/interpretable_ml/</link>
      <pubDate>Thu, 01 Jul 2021 00:00:00 +0000</pubDate>
      <guid>/interpretable_ml/</guid>
      <description>&lt;script src=&#34;../rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;&#xA;&#xA;&#xA;&lt;p&gt;In this notebook we want to test various ways of getting a better understanding on how non-trivial machine learning models generate predictions and how features interact with each other. This is in general not straight forward and key components are (1) understanding on the input data and (2) domain knowledge on the problem. Two great references on the subject are:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://christophm.github.io/interpretable-ml-book/&#34;&gt;Interpretable Machine Learning, A Guide for Making Black Box Models Explainable by Christoph Molnar&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/PacktPublishing/Interpretable-Machine-Learning-with-Python&#34;&gt;Interpretable Machine Learning with Python by Serg Mas√≠s&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Note that the methods discussed in this notebook are not related with &lt;em&gt;causality&lt;/em&gt;. I strongly recommend to refer to the article &lt;a href=&#34;https://towardsdatascience.com/be-careful-when-interpreting-predictive-models-in-search-of-causal-insights-e68626e664b6&#34;&gt;Be Careful When Interpreting Predictive Models in Search of Causal Insights&lt;/a&gt; by &lt;a href=&#34;https://scottlundberg.com/&#34;&gt;Scott Lundberg&lt;/a&gt; (one of the core developers of &lt;a href=&#34;https://shap.readthedocs.io/en/latest/index.html&#34;&gt;SHAP&lt;/a&gt;). The following are two references I have found particularly useful as an introduction to &lt;em&gt;causal inference&lt;/em&gt;:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Feature Engineering: patsy as FormulaTransformer</title>
      <link>/formula_transformer/</link>
      <pubDate>Sat, 01 May 2021 00:00:00 +0000</pubDate>
      <guid>/formula_transformer/</guid>
      <description>&lt;script src=&#34;../rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;&#xA;&#xA;&#xA;&lt;p&gt;In this notebook I want to describe how to create features inside &lt;a href=&#34;https://scikit-learn.org/stable/modules/compose.html&#34;&gt;scikit-learn pipelines&lt;/a&gt; using &lt;a href=&#34;https://patsy.readthedocs.io/en/latest/formulas.html&#34;&gt;patsy-like formulas&lt;/a&gt;. I have used this approach to generate features in a previous post: &lt;a href=&#34;https://juanitorduz.github.io/glm_pymc3/&#34;&gt;GLM in PyMC3: Out-Of-Sample Predictions&lt;/a&gt;, so I will consider the same data set here for the sake of comparison.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt; Very recently (2021-09-01) I discovered there is an implementation of this transformer in &lt;a href=&#34;https://github.com/koaning/scikit-lego&#34;&gt;scikit-lego&lt;/a&gt;, see &lt;a href=&#34;https://scikit-lego.readthedocs.io/en/latest/preprocessing.html#Patsy-Formulas&#34;&gt;&lt;code&gt;PatsyTransformer&lt;/code&gt;&lt;/a&gt;. In addition, please refer to the great &lt;a href=&#34;https://calmcode.io/patsy/introduction.html&#34;&gt;tutorial on patsy&lt;/a&gt; in &lt;a href=&#34;https://calmcode.io&#34;&gt;calmcode.io&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>GLM in PyMC3: Out-Of-Sample Predictions</title>
      <link>/glm_pymc3/</link>
      <pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate>
      <guid>/glm_pymc3/</guid>
      <description>&lt;p&gt;In this notebook I explore the &lt;a href=&#34;https://docs.pymc.io/api/glm.html&#34;&gt;glm&lt;/a&gt; module of &lt;a href=&#34;https://docs.pymc.io/&#34;&gt;PyMC3&lt;/a&gt;. I am particularly interested in the model definition using &lt;a href=&#34;https://patsy.readthedocs.io/en/latest/&#34;&gt;patsy&lt;/a&gt; formulas, as it makes the model evaluation loop faster (easier to include features and/or interactions). There are many good resources on this subject, but most of them evaluate the model in-sample. For many applications we require doing predictions on out-of-sample data. This experiment was motivated by the discussion of the thread &lt;a href=&#34;https://discourse.pymc.io/t/out-of-sample-predictions-with-the-glm-sub-module/773&#34;&gt;‚ÄúOut of sample‚Äù predictions with the GLM sub-module&lt;/a&gt; on the (great!) forum &lt;a href=&#34;https://discourse.pymc.io/&#34;&gt;discourse.pymc.io/&lt;/a&gt;, thank you all for your input!&lt;/p&gt;</description>
    </item>
    <item>
      <title>Gaussian Processes for Time Series Forecasting with PyMC3</title>
      <link>/gp_ts_pymc3/</link>
      <pubDate>Sat, 02 Jan 2021 00:00:00 +0000</pubDate>
      <guid>/gp_ts_pymc3/</guid>
      <description>&lt;script src=&#34;../rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;&#xA;&#xA;&#xA;&lt;p&gt;In this notebook we translate the forecasting models developed for the post on &lt;a href=&#34;https://juanitorduz.github.io/gaussian_process_time_series&#34;&gt;Gaussian Processes for Time Series Forecasting with Scikit-Learn&lt;/a&gt; to the probabilistic Bayesian framework &lt;a href=&#34;https://docs.pymc.io/&#34;&gt;PyMC3&lt;/a&gt;. I strongly recommend looking into the following references for more details and&#xA;examples:&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;References:&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://juanitorduz.github.io/gaussian_process_reg/&#34;&gt;An Introduction to Gaussian Process Regression&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.pymc.io/Gaussian_Processes.html&#34;&gt;PyMC3 Docs: Gaussian Processes&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.pymc.io/notebooks/GP-MaunaLoa.html&#34;&gt;PyMC3 Docs Example: CO2 at Mauna Loa&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/aloctavodia/BAP/blob/master/code/Chp7/07_Gaussian%20process.ipynb&#34;&gt;Bayesian Analysis with Python (Second edition) - Chapter 7&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://xcelab.net/rm/statistical-rethinking/&#34;&gt;Statistical Rethinking - Chapter 14&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div id=&#34;prepare-notebook1&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Prepare Notebook1&lt;/h2&gt;&#xA;&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;import numpy as np&#xA;import pandas as pd&#xA;import matplotlib.pyplot as plt&#xA;import seaborn as sns&#xA;sns.set_style(&#xA;    style=&amp;#39;darkgrid&amp;#39;, &#xA;    rc={&amp;#39;axes.facecolor&amp;#39;: &amp;#39;.9&amp;#39;, &amp;#39;grid.color&amp;#39;: &amp;#39;.8&amp;#39;}&#xA;)&#xA;sns.set_palette(palette=&amp;#39;deep&amp;#39;)&#xA;sns_c = sns.color_palette(palette=&amp;#39;deep&amp;#39;)&#xA;&#xA;import pymc3 as pm&#xA;import arviz as az&#xA;&#xA;plt.rcParams[&amp;#39;figure.figsize&amp;#39;] = [12, 6]&#xA;plt.rcParams[&amp;#39;figure.dpi&amp;#39;] = 100&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;div id=&#34;generate-sample-data&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Generate Sample Data&lt;/h2&gt;&#xA;&lt;p&gt;Instead of the step-by-step approach we took in &lt;a href=&#34;https://juanitorduz.github.io/gaussian_process_time_series&#34;&gt;Gaussian Processes for Time sSeries Forecasting with Scikit-Learn&lt;/a&gt;, we are just going to develop one model.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Simple Bayesian Linear Regression with TensorFlow Probability</title>
      <link>/tfp_lm/</link>
      <pubDate>Tue, 06 Oct 2020 00:00:00 +0000</pubDate>
      <guid>/tfp_lm/</guid>
      <description>&lt;p&gt;In this post we show how to fit a simple linear regression model using &lt;a href=&#34;https://www.tensorflow.org/probability&#34;&gt;TensorFlow Probability&lt;/a&gt; by replicating the first example on the &lt;a href=&#34;https://docs.pymc.io/notebooks/getting_started.html&#34;&gt;getting started guide for PyMC3&lt;/a&gt;. We are going to use &lt;a href=&#34;https://www.tensorflow.org/probability/api_docs/python/tfp/distributions/JointDistributionCoroutineAutoBatched&#34;&gt;Auto-Batched Joint Distributions&lt;/a&gt; as they simplify the model specification considerably. Moreover, there is a great resource to get deeper into this type of distribution: &lt;a href=&#34;https://www.tensorflow.org/probability/examples/JointDistributionAutoBatched_A_Gentle_Tutorial&#34;&gt;Auto-Batched Joint Distributions: A Gentle Tutorial&lt;/a&gt;, which I &lt;strong&gt;strongly recommend&lt;/strong&gt; (see &lt;a href=&#34;https://juanitorduz.github.io/intro_tfd/&#34;&gt;this post&lt;/a&gt; to get a brief introduction on TensorFlow probability distributions). In addition the tutorial: &lt;a href=&#34;https://www.tensorflow.org/probability/examples/Modeling_with_JointDistribution&#34;&gt;Bayesian Modeling with Joint Distribution&lt;/a&gt; is also a great reference to get started with linear models in TensorFlow Probability.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Open Data: Berlin Kitas</title>
      <link>/kitas_berlin/</link>
      <pubDate>Sat, 19 Sep 2020 00:00:00 +0000</pubDate>
      <guid>/kitas_berlin/</guid>
      <description>&lt;p&gt;In this notebook I want to explore some data I found on the Berlin Open Data portal &lt;a href=&#34;https://daten.berlin.de/&#34;&gt;&lt;strong&gt;daten.berlin.de&lt;/strong&gt;&lt;/a&gt;. The &lt;a href=&#34;https://daten.berlin.de/datensaetze/kitas-berlin&#34;&gt;data source&lt;/a&gt; contains information of Kitas (Kindertagesst√§tte, i.e.¬†kindergartens) in Berlin. This is a big topic as finding a spot in a Kita in Berlin is extremely difficult. We first provide an initial exploratory data analysis of the data set, then we merge it with population data to create some geo-location maps.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Disclaimer:&lt;/strong&gt; In our way we do not expect to answer on &lt;em&gt;how to find a Kita&lt;/em&gt;, but rather simpler questions about their location, distribution and sizes.&lt;/p&gt;</description>
    </item>
    <item>
      <title>A Simple Hamiltonian Monte Carlo Example with TensorFlow Probability</title>
      <link>/tfp_hcm/</link>
      <pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate>
      <guid>/tfp_hcm/</guid>
      <description>&lt;p&gt;In this post we want to revisit a simple bayesian inference example worked out in &lt;a href=&#34;https://juanitorduz.github.io/intro_pymc3/&#34;&gt;this blog post&lt;/a&gt;. This time we want to use &lt;a href=&#34;https://www.tensorflow.org/probability&#34;&gt;TensorFlow Probability&lt;/a&gt; (TFP) instead of &lt;a href=&#34;https://docs.pymc.io/notebooks/getting_started.html&#34;&gt;PyMC3&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;References:&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://xcelab.net/rm/statistical-rethinking/&#34;&gt;Statistical Rethinking&lt;/a&gt; is an amazing reference for Bayesian analysis. It also has a sequence of online lectures freely available on &lt;a href=&#34;https://www.youtube.com/watch?v=4WVelCswXo4&amp;amp;list=PLDcUM9US4XdNM4Edgs7weiyIguLSToZRI&#34;&gt;YouTube&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://blog.tensorflow.org/2018/12/an-introduction-to-probabilistic.html&#34;&gt;An introduction to probabilistic programming, now available in TensorFlow Probability&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;There are many examples on the &lt;a href=&#34;https://github.com/tensorflow/probability/tree/master/tensorflow_probability/examples/jupyter_notebooks&#34;&gt;TensorFlow‚Äôs GitHub repository&lt;/a&gt;. I am following the case study &lt;a href=&#34;https://github.com/tensorflow/probability/blob/master/tensorflow_probability/examples/jupyter_notebooks/Bayesian_Switchpoint_Analysis.ipynb&#34;&gt;Bayesian Switchpoint Analysis&lt;/a&gt; for this example.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Regression Analysis &amp; Visualization</title>
      <link>/lm_viz/</link>
      <pubDate>Fri, 26 Jun 2020 00:00:00 +0000</pubDate>
      <guid>/lm_viz/</guid>
      <description>&lt;p&gt;In this notebook I want to collect some useful visualizations which can help model development and model evaluation in the context of regression analysis. I use many visualization resources not just only to share results but as a key component of my workflow: data QA, EDA, feature engineering, model development, model evaluation and communicating results. In this notebook I focus on a simple regression model (time series) with &lt;a href=&#34;https://www.statsmodels.org/stable/index.html&#34;&gt;statsmodels&lt;/a&gt; and visualization with &lt;a href=&#34;https://matplotlib.org/&#34;&gt;matplotlib&lt;/a&gt; and &lt;a href=&#34;https://seaborn.pydata.org/index.html&#34;&gt;seaborn&lt;/a&gt;. The focus is not on the model development but rather visualization.&lt;/p&gt;</description>
    </item>
    <item>
      <title>A Glimpse into TensorFlow Probability Distributions</title>
      <link>/intro_tfd/</link>
      <pubDate>Tue, 16 Jun 2020 00:00:00 +0000</pubDate>
      <guid>/intro_tfd/</guid>
      <description>&lt;p&gt;In this notebook we want to go take a look into the &lt;a href=&#34;https://www.tensorflow.org/probability/api_docs/python/tfp/distributions&#34;&gt;distributions&lt;/a&gt; module of &lt;a href=&#34;https://www.tensorflow.org/probability/api_docs/python/tfp&#34;&gt;TensorFlow probability&lt;/a&gt;. The aim is to understand the fundamentals and then explore further this probabilistic programming framework. &lt;a href=&#34;https://www.tensorflow.org/probability/overview&#34;&gt;Here&lt;/a&gt; you can find an overview of TensorFlow Probability. We will concentrate on the first part of &lt;em&gt;Layer 1: Statistical Building Blocks&lt;/em&gt;. As you could see from the distributions module documentation, there are many classes of distributions. We will explore a small sample of them in order to get an overall overview. I find the documentation itself a great place to start. In addition, there is a &lt;a href=&#34;https://github.com/tensorflow/probability/tree/master/tensorflow_probability/examples/jupyter_notebooks&#34;&gt;sample of notebooks&lt;/a&gt; with concrete examples on the &lt;a href=&#34;https://github.com/tensorflow/probability&#34;&gt;GitHub repository&lt;/a&gt;. In particular, I will follow some of cases presented on the &lt;a href=&#34;https://github.com/tensorflow/probability/blob/master/tensorflow_probability/examples/jupyter_notebooks/A_Tour_of_TensorFlow_Probability.ipynb&#34;&gt;A_Tour_of_TensorFlow_Probability&lt;/a&gt; notebook, expand on some details and add some other additional examples.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Disease Spread Simulation (Animation)</title>
      <link>/infection_sim/</link>
      <pubDate>Tue, 28 Apr 2020 00:00:00 +0000</pubDate>
      <guid>/infection_sim/</guid>
      <description>We describe how to generate a basic disease spread simulation. We explore how to do animations in Matplotlib.</description>
    </item>
    <item>
      <title>Getting Started with Spectral Clustering</title>
      <link>/spectral_clustering/</link>
      <pubDate>Sat, 04 Apr 2020 00:00:00 +0000</pubDate>
      <guid>/spectral_clustering/</guid>
      <description>&lt;p&gt;In this post I want to explore the ideas behind &lt;a href=&#34;https://en.wikipedia.org/wiki/Spectral_clustering&#34;&gt;spectral clustering&lt;/a&gt;. I do not intend to develop the theory. Instead, I will unravel a practical example to illustrate and motivate the intuition behind each step of the spectral clustering algorithm. I particularly recommend two references:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;For an introduction/overview on the theory, see the lecture notes &lt;a href=&#34;http://www.tml.cs.uni-tuebingen.de/team/luxburg/publications/Luxburg07_tutorial.pdf&#34;&gt;A Tutorial on Spectral Clustering&lt;/a&gt; by &lt;a href=&#34;http://www.tml.cs.uni-tuebingen.de/team/luxburg/index.php&#34;&gt;Prof.¬†Dr.¬†Ulrike von Luxburg&lt;/a&gt;.&lt;/li&gt;&#xA;&lt;li&gt;For a concrete application of this clustering method you can see the PyData‚Äôs talk: &lt;a href=&#34;https://www.youtube.com/watch?v=3heWpR6dC8k&#34;&gt;Extracting relevant Metrics with Spectral Clustering&lt;/a&gt; by Dr.¬†Evelyn Trautmann.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div id=&#34;prepare-notebook&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Prepare Notebook&lt;/h2&gt;&#xA;&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;import numpy as np&#xA;import pandas as pd&#xA;&#xA;import matplotlib.pyplot as plt&#xA;import seaborn as sns&#xA;sns.set_style(&amp;#39;darkgrid&amp;#39;, {&amp;#39;axes.facecolor&amp;#39;: &amp;#39;.9&amp;#39;})&#xA;sns.set_palette(palette=&amp;#39;deep&amp;#39;)&#xA;sns_c = sns.color_palette(palette=&amp;#39;deep&amp;#39;)&#xA;%matplotlib inline&#xA;&#xA;from pandas.plotting import register_matplotlib_converters&#xA;register_matplotlib_converters()&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;div id=&#34;generate-sample-data&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Generate Sample Data&lt;/h2&gt;&#xA;&lt;p&gt;Let us generate some sample data. As we will see, spectral clustering is very effective for non-convex clusters. In this example, we consider concentric circles:&lt;/p&gt;</description>
    </item>
    <item>
      <title>The Volume of the d-Ball via Monte Carlo Simulation</title>
      <link>/vol_d_ball/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      <guid>/vol_d_ball/</guid>
      <description>&lt;p&gt;In this notebook we run Monte Carlo simulations to estimate the volume of the &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt;-ball&#xA;&lt;span class=&#34;math display&#34;&gt;\[&#xA;B^{d}:=\{x \in \mathbb{R}^d : ||x|| \leq 1\}.&#xA;\]&lt;/span&gt;&#xA;There are many ways to obtain a closed formula for this volume , see for example this &lt;a href=&#34;https://en.wikipedia.org/wiki/N-sphere&#34;&gt;Wikipedia article&lt;/a&gt;. Here we do it via sampling just for fun!&lt;/p&gt;&#xA;&lt;div id=&#34;main-idea&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Main Idea&lt;/h2&gt;&#xA;&lt;p&gt;Consider a square &lt;span class=&#34;math inline&#34;&gt;\(A_{d}\subset \mathbb{R}\)&lt;/span&gt; centered at the origin with side length &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt;. We estimate the volume of the &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt;-ball &lt;span class=&#34;math inline&#34;&gt;\(B^{d}:=\{x \in \mathbb{R}^d : ||x|| \leq 1\}\subset A^{d}\)&lt;/span&gt; by sampling uniformly from &lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt; and computing the proportions of vectors having length less or equal than one. Note that &lt;span class=&#34;math inline&#34;&gt;\(\text{vol}(A^{d}) = 2^{d}\)&lt;/span&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Forecasting Weekly Data with Prophet</title>
      <link>/fb_prophet/</link>
      <pubDate>Fri, 21 Feb 2020 00:00:00 +0000</pubDate>
      <guid>/fb_prophet/</guid>
      <description>&lt;p&gt;In this notebook we are present an initial exploration of the &lt;a href=&#34;https://facebook.github.io/prophet/&#34;&gt;Prophet&lt;/a&gt; package by &lt;a href=&#34;https://opensource.facebook.com/&#34;&gt;Facebook&lt;/a&gt;. From the documentation:&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;Prophet is a procedure for forecasting time series data based on an additive model where non-linear trends are fit with yearly, weekly, and daily seasonality, plus holiday effects. It works best with time series that have strong seasonal effects and several seasons of historical data. Prophet is robust to missing data and shifts in the trend, and typically handles outliers well.&lt;/em&gt;&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Exploring TensorFlow Probability STS Forecasting</title>
      <link>/intro_sts_tfp/</link>
      <pubDate>Tue, 11 Feb 2020 00:00:00 +0000</pubDate>
      <guid>/intro_sts_tfp/</guid>
      <description>&lt;dl&gt;&#xA;&lt;dt&gt;In this notebook we explore the &lt;a href=&#34;https://www.tensorflow.org/probability/api_docs/python/tfp/sts&#34;&gt;Structural Time Series (STS) Module&lt;/a&gt; of &lt;a href=&#34;https://www.tensorflow.org/probability/&#34;&gt;TensorFlow Probability&lt;/a&gt;. We follow closely the &lt;a href=&#34;https://medium.com/tensorflow/structural-time-series-modeling-in-tensorflow-probability-344edac24083&#34;&gt;use cases&lt;/a&gt; presented in their &lt;a href=&#34;https://medium.com/tensorflow&#34;&gt;Medium blog&lt;/a&gt;. As described there: &lt;em&gt;An STS model expresses an observed time series as the sum of simpler components&lt;/em&gt; &lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;:&lt;/dt&gt;&#xA;&lt;dd&gt;&#xA;&#xA;&lt;/dd&gt;&#xA;&lt;/dl&gt;&#xA;&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[&#xA;f(t) = \sum_{k=1}^{N}f_{k}(t) + \varepsilon, \quad \text{where}\quad \varepsilon \sim N(0, \sigma^2).&#xA;\]&lt;/span&gt;&lt;/p&gt;&#xA;&lt;p&gt;Each summand &lt;span class=&#34;math inline&#34;&gt;\(f_{k}(t)\)&lt;/span&gt; has a particular structure, e.g.¬†specific seasonality, trend, autoregressive terms, etc.&lt;/p&gt;&#xA;&lt;p&gt;In this notebook we generate a time series sample and then present some techniques to recover its component structure. This is indeed a crucial step since in real applications we are not given the components separately. We then show how to fit and generate predictions using &lt;a href=&#34;https://en.wikipedia.org/wiki/Variational_Bayesian_methods&#34;&gt;variational inference&lt;/a&gt;. Finally we run some diagnostics of the errors on the test set.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Intro ML in Production: Flask, Docker and GitHub Actions</title>
      <link>/ml_prod_intro/</link>
      <pubDate>Tue, 28 Jan 2020 00:00:00 +0000</pubDate>
      <guid>/ml_prod_intro/</guid>
      <description>We describe how to set up a toy-model repository to train and dockerize a machine learning model with data store on aws s3.</description>
    </item>
    <item>
      <title>Drawing Manifolds in LaTeX with TikZ</title>
      <link>/manifold_fig_latex/</link>
      <pubDate>Fri, 10 Jan 2020 00:00:00 +0000</pubDate>
      <guid>/manifold_fig_latex/</guid>
      <description>We give some LaTex code to create figures of manifolds with boundaries.</description>
    </item>
    <item>
      <title>Open Data: Germany Maps Viz</title>
      <link>/germany_plots/</link>
      <pubDate>Tue, 07 Jan 2020 00:00:00 +0000</pubDate>
      <guid>/germany_plots/</guid>
      <description>&lt;p&gt;In this post I want to show how to use public available (open) data to create geo visualizations in python. Maps are a great way to communicate and compare information when working with geolocation data. There are many frameworks to plot maps, here I focus on &lt;a href=&#34;https://matplotlib.org&#34;&gt;matplotlib&lt;/a&gt; and &lt;a href=&#34;http://geopandas.org&#34;&gt;geopandas&lt;/a&gt; (and give a glimpse of &lt;a href=&#34;https://github.com/jwass/mplleaflet&#34;&gt;mplleaflet&lt;/a&gt;).&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Reference:&lt;/strong&gt; A very good introduction to matplotlib is the chapter on &lt;a href=&#34;https://jakevdp.github.io/PythonDataScienceHandbook/04.00-introduction-to-matplotlib.html&#34;&gt;Visualization with Matplotlib&lt;/a&gt; from the &lt;a href=&#34;https://jakevdp.github.io/PythonDataScienceHandbook/&#34;&gt;Python Data Science Handbook&lt;/a&gt; by &lt;a href=&#34;https://jakevdp.github.io/pages/about.html&#34;&gt;Jake VanderPlas&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>The Graph Laplacian &amp; Semi-Supervised Clustering</title>
      <link>/semi_supervised_clustering/</link>
      <pubDate>Thu, 05 Dec 2019 00:00:00 +0000</pubDate>
      <guid>/semi_supervised_clustering/</guid>
      <description>&lt;script src=&#34;../rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;&#xA;&#xA;&#xA;&lt;p&gt;In this post we want to explore the semi-supervided algorithm presented &lt;a href=&#34;https://eldad-haber.webnode.com/&#34;&gt;Eldad Haber&lt;/a&gt; in the &lt;a href=&#34;https://www.math-berlin.de/academics/summer-schools/2019&#34;&gt;BMS Summer School 2019: Mathematics of Deep Learning&lt;/a&gt;, during 19 - 30 August 2019, at the Zuse Institute Berlin. He developed an implementation in Matlab which you can find in &lt;a href=&#34;https://github.com/eldadHaber/CompAI/&#34;&gt;this&lt;/a&gt; GitHub repository. In addition, please find the corresponding slides &lt;a href=&#34;https://github.com/eldadHaber/CompAI/blob/master/02-SemiSup.pdf&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;div id=&#34;prepare-notebook&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Prepare Notebook&lt;/h2&gt;&#xA;&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;import numpy as np&#xA;import pandas as pd&#xA;import matplotlib.pyplot as plt&#xA;import seaborn as sns; sns.set()&#xA;&#xA;%matplotlib inline&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;div id=&#34;generate-sample-data&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Generate Sample Data&lt;/h2&gt;&#xA;&lt;p&gt;Let us generate the sample data as 3 concentric circles:&lt;/p&gt;</description>
    </item>
    <item>
      <title>The Lapacian on the 2-Torus</title>
      <link>/laplacian_2torus/</link>
      <pubDate>Sun, 13 Oct 2019 00:00:00 +0000</pubDate>
      <guid>/laplacian_2torus/</guid>
      <description>&lt;script src=&#34;../rmarkdown-libs/htmlwidgets/htmlwidgets.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;../rmarkdown-libs/plotly-binding/plotly.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;../rmarkdown-libs/typedarray/typedarray.min.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;../rmarkdown-libs/jquery/jquery.min.js&#34;&gt;&lt;/script&gt;&#xA;&lt;link href=&#34;../rmarkdown-libs/crosstalk/css/crosstalk.css&#34; rel=&#34;stylesheet&#34; /&gt;&#xA;&lt;script src=&#34;../rmarkdown-libs/crosstalk/js/crosstalk.min.js&#34;&gt;&lt;/script&gt;&#xA;&lt;link href=&#34;../rmarkdown-libs/plotly-htmlwidgets-css/plotly-htmlwidgets.css&#34; rel=&#34;stylesheet&#34; /&gt;&#xA;&lt;script src=&#34;../rmarkdown-libs/plotly-main/plotly-latest.min.js&#34;&gt;&lt;/script&gt;&#xA;&#xA;&#xA;&lt;p&gt;In this blog post I want to describe the explicit computation of the Laplacian on differential forms on the &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt;-Torus &lt;span class=&#34;math inline&#34;&gt;\(T^2\subset \mathbb{R}^3\)&lt;/span&gt;. This surface can be obtained by rotating the circle &lt;span class=&#34;math inline&#34;&gt;\((x-a)^2+y^2=r^2\)&lt;/span&gt; around the &lt;span class=&#34;math inline&#34;&gt;\(z\)&lt;/span&gt;-axis (&lt;span class=&#34;math inline&#34;&gt;\(0&amp;lt;r&amp;lt;a\)&lt;/span&gt;). Locally, this surface can be parametrized by the equations&#xA;&lt;span class=&#34;math display&#34;&gt;\[&#xA;x = (a+r\cos u)\cos v,\\&#xA;y = (a+r\cos u)\sin v,\\&#xA;z = r\sin u,&#xA;\]&lt;/span&gt;&lt;/p&gt;&#xA;&lt;p&gt;where &lt;span class=&#34;math inline&#34;&gt;\(0&amp;lt;u,v&amp;lt;2\pi\)&lt;/span&gt;.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt; Note that, topologically, &lt;span class=&#34;math inline&#34;&gt;\(T^2\)&lt;/span&gt; can be identified with the product of two circles. In particular, it is a &lt;a href=&#34;https://en.wikipedia.org/wiki/Lie_group&#34;&gt;Lie group&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>PyData Berlin 2019: Gaussian Processes for Time Series Forecasting (scikit-learn)</title>
      <link>/gaussian_process_time_series/</link>
      <pubDate>Thu, 10 Oct 2019 00:00:00 +0000</pubDate>
      <guid>/gaussian_process_time_series/</guid>
      <description>&lt;script src=&#34;../rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;&#xA;&#xA;&#xA;&lt;p&gt;In this notebook we run some experiments to demonstrate how we can use Gaussian Processes in the context of time series forecasting with &lt;a href=&#34;https://scikit-learn.org/stable/modules/gaussian_process.html&#34;&gt;scikit-learn&lt;/a&gt;. This material is part of a talk on &lt;a href=&#34;https://de.pycon.org/program/pydata-knlnbb-gaussian-process-for-time-series-analysis-dr-juan-orduz/&#34;&gt;Gaussian Process for Time Series Analysis&lt;/a&gt; presented at the &lt;a href=&#34;https://de.pycon.org/&#34;&gt;PyCon DE &amp;amp; PyData 2019 Conference&lt;/a&gt; in Berlin.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; Additional material and plots were included for the &lt;a href=&#34;http://www.fields.utoronto.ca/activities/20-21/dynamical&#34;&gt;Second Symposium on Machine Learning and Dynamical Systems&lt;/a&gt; at &lt;a href=&#34;http://www.fields.utoronto.ca/&#34;&gt;The Fields Institute&lt;/a&gt; (virtual event).&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Videos&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;PyData Berlin 2019&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;center&gt;&#xA;&lt;iframe width=&#34;500&#34; height=&#34;300&#34; src=&#34;https://www.youtube.com/embed/0p_6RzhSZEc?rel=0&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&#xA;&lt;/iframe&gt;&#xA;&lt;/center&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Second Symposium on Machine Learning and Dynamical Systems 2020&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;center&gt;&#xA;&lt;iframe width=&#34;500&#34; height=&#34;300&#34; src=&#34;https://www.youtube.com/embed/n42uQjhoS9g&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&#xA;&lt;/iframe&gt;&#xA;&lt;/center&gt;&#xA;&lt;p&gt;&lt;strong&gt;Slides&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>satRday Berlin 2019: Remedies for Severe Class Imbalance</title>
      <link>/class_imbalance/</link>
      <pubDate>Sat, 15 Jun 2019 00:00:00 +0000</pubDate>
      <guid>/class_imbalance/</guid>
      <description>&lt;p&gt;In this post I present a concrete case study illustrating some techniques to improve model performance in class-imbalanced classification problems. The methodologies described here are based on &lt;em&gt;Chapter 16: Remedies for Severe Class Imbalance&lt;/em&gt; of the (great!) book &lt;a href=&#34;http://appliedpredictivemodeling.com/&#34;&gt;Applied Predictive Modeling&lt;/a&gt; by Max Kuhn and Kjell Johnson. I absolutely recommend this reference to anyone interested in predictive modeling.&lt;/p&gt;&#xA;&lt;p&gt;This notebook should serve as an extension of my talk given at &lt;a href=&#34;https://berlin2019.satrdays.org/&#34;&gt;satRday Berlin 2019: A conference for R users in Berlin&lt;/a&gt;. Here are the slides:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Seasonal Bump Functions</title>
      <link>/bump_func/</link>
      <pubDate>Thu, 11 Apr 2019 00:00:00 +0000</pubDate>
      <guid>/bump_func/</guid>
      <description>&lt;p&gt;Motivated by the nice talk on &lt;a href=&#34;https://www.youtube.com/watch?v=68ABAU_V8qI&#34;&gt;Winning with Simple, even Linear, Models&lt;/a&gt; by Vincent D. Warmerdam, I briefly describe how to construct certain class of &lt;a href=&#34;https://en.wikipedia.org/wiki/Bump_function&#34;&gt;bump functions&lt;/a&gt; to encode seasonal variables in &lt;a href=&#34;https://www.r-project.org/&#34;&gt;R&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;div id=&#34;prepare-notebook&#34; class=&#34;section level1&#34;&gt;&#xA;&lt;h1&gt;Prepare Notebook&lt;/h1&gt;&#xA;&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(glue)&#xA;library(lubridate)&#xA;library(magrittr)&#xA;library(tidyverse)&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;div id=&#34;generate-data&#34; class=&#34;section level1&#34;&gt;&#xA;&lt;h1&gt;Generate Data&lt;/h1&gt;&#xA;&lt;p&gt;Let us generate a time sequence variable stored in a tibble.&lt;/p&gt;&#xA;&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Define time sequence. &#xA;t &amp;lt;- seq.Date(from = as.Date(&amp;quot;2017-07-01&amp;quot;), to = as.Date(&amp;quot;2019-04-01&amp;quot;), by = &amp;quot;day&amp;quot;)&#xA;# Store it in a tibble. &#xA;df &amp;lt;- tibble(t = t)&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;div id=&#34;symmetric-bump-function&#34; class=&#34;section level1&#34;&gt;&#xA;&lt;h1&gt;Symmetric Bump Function&lt;/h1&gt;&#xA;&lt;p&gt;We want to generate a gaussian-like curve around a specific date. The width of the bump function is parametrized by a non-negative number &lt;span class=&#34;math inline&#34;&gt;\(\varepsilon \geq 0\)&lt;/span&gt;. For &lt;span class=&#34;math inline&#34;&gt;\(\varepsilon = 0\)&lt;/span&gt; we generate a dummy variable. Namely, for &lt;span class=&#34;math inline&#34;&gt;\(\varepsilon \neq 0\)&lt;/span&gt;,&lt;/p&gt;</description>
    </item>
    <item>
      <title>An Introduction to Gaussian Process Regression</title>
      <link>/gaussian_process_reg/</link>
      <pubDate>Mon, 08 Apr 2019 00:00:00 +0000</pubDate>
      <guid>/gaussian_process_reg/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Updated Version: 2019/09/21&lt;/strong&gt; (Extension + Minor Corrections)&lt;/p&gt;&#xA;&lt;p&gt;After a sequence of preliminary posts (&lt;a href=&#34;https://juanitorduz.github.io/multivariate_normal/&#34;&gt;Sampling from a Multivariate Normal Distribution&lt;/a&gt; and &lt;a href=&#34;https://juanitorduz.github.io/reg_bayesian_regression/&#34;&gt;Regularized Bayesian Regression as a Gaussian Process&lt;/a&gt;), I want to explore a concrete example of a &lt;strong&gt;gaussian process regression&lt;/strong&gt;. We continue following &lt;a href=&#34;http://www.gaussianprocess.org/gpml/chapters/RW2.pdf&#34;&gt;Gaussian Processes for Machine Learning, Ch 2&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Other recommended references are:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.robots.ox.ac.uk/~sjrob/Pubs/philTransA_2012.pdf&#34;&gt;Gaussian Processes for Timeseries Modeling&lt;/a&gt; by S. Roberts, M. Osborne, M. Ebden, S. Reece, N. Gibson &amp;amp; S. Aigrain.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.stat.columbia.edu/~gelman/book/&#34;&gt;Bayesian Data Analyis, Chapter 21&lt;/a&gt; by by Andrew Gelman, John Carlin, Hal Stern, David Dunson, Aki Vehtari, and Donald Rubin.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div id=&#34;prepare-notebook&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Prepare Notebook&lt;/h2&gt;&#xA;&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;import numpy as np&#xA;import matplotlib.pyplot as plt&#xA;import seaborn as sns&#xA;sns.set_style(&#xA;    style=&amp;#39;darkgrid&amp;#39;, &#xA;    rc={&amp;#39;axes.facecolor&amp;#39;: &amp;#39;.9&amp;#39;, &amp;#39;grid.color&amp;#39;: &amp;#39;.8&amp;#39;}&#xA;)&#xA;sns.set_palette(palette=&amp;#39;deep&amp;#39;)&#xA;%matplotlib inline&#xA;plt.rcParams[&amp;#39;figure.figsize&amp;#39;] = [12, 6]&#xA;plt.rcParams[&amp;#39;figure.dpi&amp;#39;] = 100&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;div id=&#34;generate-data-samples&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Generate Data Samples&lt;/h2&gt;&#xA;&lt;p&gt;We consider de model &lt;span class=&#34;math inline&#34;&gt;\(y = f(x) + \varepsilon\)&lt;/span&gt;, where &lt;span class=&#34;math inline&#34;&gt;\(\varepsilon \sim N(0, \sigma_n)\)&lt;/span&gt;. Here &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; does not need to be a linear function of &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;. As a concrete example, let us consider (1-dim problem)&lt;/p&gt;</description>
    </item>
    <item>
      <title>Bayesian Regression as a Gaussian Process</title>
      <link>/reg_bayesian_regression/</link>
      <pubDate>Mon, 01 Apr 2019 00:00:00 +0000</pubDate>
      <guid>/reg_bayesian_regression/</guid>
      <description>&lt;p&gt;In this post we study the Bayesian Regression model to explore and compare the weight and function space and views of Gaussian Process Regression as described in the book &lt;a href=&#34;http://www.gaussianprocess.org/gpml/chapters/RW2.pdf&#34;&gt;Gaussian Processes for Machine Learning, Ch 2&lt;/a&gt;. We follow this reference very closely (and encourage to read it!). Our main objective is to illustrate the concepts and results through a concrete example. We use &lt;a href=&#34;https://docs.pymc.io&#34;&gt;PyMC3&lt;/a&gt; to run bayesian sampling.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;References:&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.gaussianprocess.org/gpml/chapters/RW2.pdf&#34;&gt;Gaussian Processes for Machine Learning&lt;/a&gt;, Carl Edward Rasmussen and Christopher K. I. Williams, MIT Press, 2006.&lt;/li&gt;&#xA;&lt;li&gt;See &lt;a href=&#34;https://juanitorduz.github.io/intro_pymc3/&#34;&gt;this&lt;/a&gt; post for an introduction to bayesian methods and PyMC3.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.pymc.io/notebooks/GLM-linear.html&#34;&gt;Documentation&lt;/a&gt; of linear regression in PyMC3.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.pymc.io/api/distributions/multivariate.html#pymc3.distributions.multivariate.MvNormal&#34;&gt;Documentation&lt;/a&gt; for the multivariate normal distribution in PyMC3.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/52509602/cant-compile-c-program-on-a-mac-after-upgrade-to-mojave&#34;&gt;Here&lt;/a&gt; is an Stackoverflow post which can help Mac OS users which might have problems with Theano after upgrading to Mojave.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Let us consider the model:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Sampling from a Multivariate Normal Distribution</title>
      <link>/multivariate_normal/</link>
      <pubDate>Sat, 23 Mar 2019 00:00:00 +0000</pubDate>
      <guid>/multivariate_normal/</guid>
      <description>&lt;script src=&#34;../rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;&#xA;&#xA;&#xA;&lt;p&gt;In this post I want to describe how to sample from a multivariate normal distribution following section &lt;a href=&#34;http://www.gaussianprocess.org/gpml/chapters/RWA.pdf&#34;&gt;A.2 Gaussian Identities&lt;/a&gt; of the book &lt;a href=&#34;http://www.gaussianprocess.org/gpml/chapters/&#34;&gt;Gaussian Processes for Machine Learning&lt;/a&gt;. This is a first step towards exploring and understanding Gaussian Processes methods in machine learning.&lt;/p&gt;&#xA;&lt;div id=&#34;multivariate-normal-distribution&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Multivariate Normal Distribution&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Multivariate_normal_distribution&#34;&gt;Recall&lt;/a&gt; that a random vector \(X = (X_1, , X_d)\) has a &lt;em&gt;multivariate normal (or Gaussian) distribution&lt;/em&gt; if every linear combination&lt;/p&gt;&#xA;&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[&#xA;\sum_{i=1}^{d} a_iX_i, \quad a_i\in\mathbb{R} &#xA;\]&lt;/span&gt;&#xA;is normally distributed.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Dockerize a ShinyApp</title>
      <link>/dockerize-a-shinyapp/</link>
      <pubDate>Sat, 02 Mar 2019 00:00:00 +0000</pubDate>
      <guid>/dockerize-a-shinyapp/</guid>
      <description>&lt;script src=&#34;../rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;&#xA;&#xA;&#xA;&lt;p&gt;In this post I want to describe how to dockerize a simple &lt;a href=&#34;https://shiny.rstudio.com&#34;&gt;Shiny App&lt;/a&gt;. &lt;a href=&#34;https://www.docker.com/&#34;&gt;Docker&lt;/a&gt; is a great way of sharing and deploying projects. You can download it &lt;a href=&#34;https://www.docker.com/get-started&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Resources:&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://ropenscilabs.github.io/r-docker-tutorial/&#34;&gt;R Docker tutorial&lt;/a&gt;, recommended for Docker beginners.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.sellorm.com/2021/04/25/shiny-app-in-docker/&#34;&gt;Running a shiny app in a docker container&lt;/a&gt; by Mark Sellors (which is an updated and more complete version of this post).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Assume you have a project folder structure as follows:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;.&#xA;+-- project.Rproj&#xA;+-- app.R&#xA;+-- R&#xA;|   +-- script_1.R&#xA;|   +-- script_2.R&#xA;+-- data&#xA;|   +-- data_df.rds&#xA;|   +-- raw_data.csv&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;The script &lt;code&gt;app.R&lt;/code&gt; contains the code of the Shiny application.&lt;/li&gt;&#xA;&lt;li&gt;The folder &lt;code&gt;R&lt;/code&gt; contains auxiliary scripts.&lt;/li&gt;&#xA;&lt;li&gt;The folder &lt;code&gt;data&lt;/code&gt; contains a csv and an rds file which might be nessesary for the application (cleaned data set, for example).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;To create a docker image you need to create a &lt;a href=&#34;https://docs.docker.com/engine/reference/builder/&#34;&gt;Dockerfile&lt;/a&gt;, which is a simple text file located in the same directory as &lt;code&gt;app.R&lt;/code&gt;. The name of the file must be &lt;code&gt;Dockerfile&lt;/code&gt;. A common structure of this file is the following:&lt;/p&gt;</description>
    </item>
    <item>
      <title>The Spectral Theorem for Matrices</title>
      <link>/the-spectral-theorem-for-matrices/</link>
      <pubDate>Sat, 02 Feb 2019 00:00:00 +0000</pubDate>
      <guid>/the-spectral-theorem-for-matrices/</guid>
      <description>&lt;p&gt;When working in data analysis it is almost impossible to avoid using linear algebra, even if it is on the background, e.g.¬†simple linear regression. In this post I want to discuss one of the most important theorems of finite dimensional vector spaces: &lt;strong&gt;the spectral theorem&lt;/strong&gt;. The objective is not to give a complete and rigorous treatment of the subject, but rather show the main ingredients, some examples and applications.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Movie Plots Text Generation with Keras</title>
      <link>/movie_plot_text_gen/</link>
      <pubDate>Sun, 13 Jan 2019 00:00:00 +0000</pubDate>
      <guid>/movie_plot_text_gen/</guid>
      <description>&lt;script src=&#34;../rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;&#xA;&#xA;&#xA;&lt;p&gt;In this post I show some text generation experiments I ran using &lt;a href=&#34;https://en.wikipedia.org/wiki/Long_short-term_memory&#34;&gt;LSTM&lt;/a&gt; with &lt;a href=&#34;https://keras.io&#34;&gt;Keras&lt;/a&gt;. For the preprocessing and tokenization I used &lt;a href=&#34;https://spacy.io&#34;&gt;SpaCy&lt;/a&gt;. The aim is not to present a completed project, but rather a first step which should be then iterated.&lt;/p&gt;&#xA;&lt;div id=&#34;resources&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;Resources&lt;/h2&gt;&#xA;&lt;p&gt;There are many great resources and blog posts about the subject (and similar experiments). Here I mention the ones I found particularly useful for the general theory:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Online Resources:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.deeplearning.ai&#34;&gt;Deep Learning Specialization&lt;/a&gt;, &lt;a href=&#34;https://www.coursera.org&#34;&gt;Coursera&lt;/a&gt; by &lt;a href=&#34;https://www.andrewng.org&#34;&gt;Andrew Ng&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Exploring the Curse of Dimensionality - Part II.</title>
      <link>/exploring-the-curse-of-dimensionality-part-ii./</link>
      <pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate>
      <guid>/exploring-the-curse-of-dimensionality-part-ii./</guid>
      <description>&lt;p&gt;I continue exploring the &lt;strong&gt;curse of dimensionality&lt;/strong&gt;. Following the analysis form &lt;a href=&#34;https://juanitorduz.github.io/exploring-the-curse-of-dimensionality-part-i./&#34;&gt;Part I.&lt;/a&gt;, I want to discuss another consequence of sparse sampling in high dimensions: sample points are close to an edge of the sample. This post is based on &lt;a href=&#34;https://web.stanford.edu/~hastie/ElemStatLearn/&#34;&gt;The Elements of Statistical Learning, Section 2.5&lt;/a&gt;, which I encourage to read!&lt;/p&gt;&#xA;&lt;div id=&#34;uniform-sampling&#34; class=&#34;section level1&#34;&gt;&#xA;&lt;h1&gt;Uniform Sampling&lt;/h1&gt;&#xA;&lt;p&gt;&lt;em&gt;Consider &lt;span class=&#34;math inline&#34;&gt;\(N\)&lt;/span&gt; data points uniformly distributed in a &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;-dimensional unit ball centered at the origin. Suppose we consider a nearest-neighbor estimate at the origin. The median distance from the origin to the closest data point is given by the expression&lt;/em&gt;&#xA;&lt;span class=&#34;math display&#34;&gt;\[&#xA;d(p,N)  = \left(1-\frac{1}{2}^{1/N}\right)^{1/p}.&#xA;\]&lt;/span&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Text Mining, Networks and Visualization: Plebiscito Tweets</title>
      <link>/text-mining-networks-and-visualization-plebiscito-tweets/</link>
      <pubDate>Thu, 20 Dec 2018 00:00:00 +0000</pubDate>
      <guid>/text-mining-networks-and-visualization-plebiscito-tweets/</guid>
      <description>&lt;script src=&#34;../rmarkdown-libs/htmlwidgets/htmlwidgets.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;../rmarkdown-libs/plotly-binding/plotly.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;../rmarkdown-libs/typedarray/typedarray.min.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;../rmarkdown-libs/jquery/jquery.min.js&#34;&gt;&lt;/script&gt;&#xA;&lt;link href=&#34;../rmarkdown-libs/crosstalk/css/crosstalk.css&#34; rel=&#34;stylesheet&#34; /&gt;&#xA;&lt;script src=&#34;../rmarkdown-libs/crosstalk/js/crosstalk.min.js&#34;&gt;&lt;/script&gt;&#xA;&lt;link href=&#34;../rmarkdown-libs/plotly-htmlwidgets-css/plotly-htmlwidgets.css&#34; rel=&#34;stylesheet&#34; /&gt;&#xA;&lt;script src=&#34;../rmarkdown-libs/plotly-main/plotly-latest.min.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;../rmarkdown-libs/d3/d3.min.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;../rmarkdown-libs/forceNetwork-binding/forceNetwork.js&#34;&gt;&lt;/script&gt;&#xA;&#xA;&#xA;&lt;p&gt;Nowadays social media generates a vast amount of raw data (text, images, videos, etc). It is a very interesting challenge to discover techniques to get insights on the content and development of social media data. In addition, as a fundamental component of the analysis, it is important to find ways of communicating the results, i.e.¬†data visualization. In this post I want to present a small case study where I analyze Twitter text data. The aim is not to give a complete analysis (as it would require many interations), but rather to describe how to to start. The emphasis of this post is in the data manipulation and data visualization. In particular, I describe how networks (graphs) can be used as data structures to describe text relations (some measure of pairwise count occurrences).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Exploring the Curse of Dimensionality - Part I.</title>
      <link>/exploring-the-curse-of-dimensionality-part-i./</link>
      <pubDate>Sun, 09 Dec 2018 00:00:00 +0000</pubDate>
      <guid>/exploring-the-curse-of-dimensionality-part-i./</guid>
      <description>&lt;p&gt;In this post I want to present the notion of &lt;strong&gt;curse of dimensionality&lt;/strong&gt; following a suggested exercise (Chapter 4 - Ex. 4) of the book &lt;a href=&#34;http://www-bcf.usc.edu/~gareth/ISL/&#34;&gt;An Introduction to Statistical Learning&lt;/a&gt;, written by Gareth James, Daniela Witten, Trevor Hastie and Robert Tibshirani.&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;When the number of features &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; is large, there tends to be a deterioration in the performance of KNN and other local approaches that perform prediction using only observations that are near the test observation for which a prediction must be made. This phenomenon is known as the &lt;strong&gt;curse of dimensionality&lt;/strong&gt;, and it ties into the fact that non-parametric approaches often perform poorly when &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; is large. We will now investigate this curse.&lt;/em&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>From Pelican to Blogdown</title>
      <link>/pelican_to_blogdown/</link>
      <pubDate>Sun, 02 Dec 2018 00:00:00 +0000</pubDate>
      <guid>/pelican_to_blogdown/</guid>
      <description>&lt;script src=&#34;../rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;&#xA;&#xA;&#xA;&lt;p&gt;Here I want to discuss my transition from &lt;a href=&#34;https://blog.getpelican.com&#34;&gt;Pelican&lt;/a&gt; to &lt;a href=&#34;https://bookdown.org/yihui/blogdown/&#34;&gt;Blogdown&lt;/a&gt; and present some personal learnings. In June 2017 I decided to build a personal website/portafolio. I chose &lt;a href=&#34;https://blog.getpelican.com&#34;&gt;Pelican&lt;/a&gt;, because:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;It is written in &lt;a href=&#34;https://www.python.org&#34;&gt;Python&lt;/a&gt;, which was the programing language I was mainly working on.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;I wanted to include some &lt;a href=&#34;http://jupyter.org&#34;&gt;Jupyter&lt;/a&gt; notebook I had already written.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;A great post: &lt;a href=&#34;https://www.dataquest.io/blog/how-to-setup-a-data-science-blog/&#34;&gt;Building a data science portfolio: Making a data science blog&lt;/a&gt; explaining the procedure and using &lt;a href=&#34;https://pages.github.com&#34;&gt;GitHub Pages&lt;/a&gt; to publist it.&lt;/p&gt;</description>
    </item>
    <item>
      <title>\(S^1\)-Equivariant Dirac operators on the Hopf Fibration</title>
      <link>/hopf_fibration/</link>
      <pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate>
      <guid>/hopf_fibration/</guid>
      <description>In this expository article I discuss the definition and basic properties of the Hopf fibration, with particular emphasis on Dirac-type operators induced, in the sense of Br√ºning and Heintze, by the Hodge-de Rham and spin-Dirac operators. In addition, we compute the Dirac-Schr√∂dinger type operator introduced in my PhD thesis.</description>
    </item>
    <item>
      <title>Introduction to R Plumber : Expose a Caret model to a web API</title>
      <link>/intro_plumber/</link>
      <pubDate>Fri, 12 Oct 2018 00:00:00 +0000</pubDate>
      <guid>/intro_plumber/</guid>
      <description>In this post we present a simple example of how to expose a prediction model to a web API using the Plumber package.</description>
    </item>
    <item>
      <title>Circle Radius Fit for a Cloud of Points</title>
      <link>/circle-radius-fit-for-a-cloud-of-points/</link>
      <pubDate>Sun, 09 Sep 2018 00:00:00 +0000</pubDate>
      <guid>/circle-radius-fit-for-a-cloud-of-points/</guid>
      <description>We explore how to include an R notebook into a pelican post. As an example, we describe how to fit a circle onto a cloud of points.</description>
    </item>
    <item>
      <title>From Bachelor to PhD: Geometric and Topological Methods for Quantum Field Theory</title>
      <link>/vdl_experience/</link>
      <pubDate>Thu, 02 Aug 2018 00:00:00 +0000</pubDate>
      <guid>/vdl_experience/</guid>
      <description>We give an introduction to PyMC3, a probabilistic programming framework written in Python. We revise the basic mathematical theory and present two concrete examples.</description>
    </item>
    <item>
      <title>PyData Berlin 2018: On Laplacian Eigenmaps for Dimensionality Reduction</title>
      <link>/laplacian_eigenmaps_dim_red/</link>
      <pubDate>Sun, 08 Jul 2018 00:00:00 +0000</pubDate>
      <guid>/laplacian_eigenmaps_dim_red/</guid>
      <description>This post contains the slides and material from a talk I gave at PyData Berlin 2018. I presented the paper &lt;em&gt;Laplacian Eigenmaps for Dimensionality Reduction and Data Representation&lt;/em&gt; by &lt;a href=&#34;http://web.cse.ohio-state.edu/~belkin.8/&#34;&gt;Mikhail Belkin&lt;/a&gt; and &lt;a href=&#34;http://people.cs.uchicago.edu/~niyogi/&#34;&gt;Partha Niyogi&lt;/a&gt;.</description>
    </item>
    <item>
      <title>Probability that a given observation is part of a bootstrap sample?</title>
      <link>/bootstrap/</link>
      <pubDate>Wed, 29 Nov 2017 00:00:00 +0000</pubDate>
      <guid>/bootstrap/</guid>
      <description>We study the problem of computing the probability that a given observation is part of a bootstrap sample. We include some numerical simulations.</description>
    </item>
    <item>
      <title>Induced Dirac-Schr√∂dinger operators on semi-free circle quotients</title>
      <link>/phd/</link>
      <pubDate>Sat, 11 Nov 2017 00:00:00 +0000</pubDate>
      <guid>/phd/</guid>
      <description>I present the content of my PhD Thesis in mathematics, which has now been published in The Journal of Geometric Analysis.</description>
    </item>
    <item>
      <title>Introduction to Bayesian Modeling with PyMC3</title>
      <link>/intro_pymc3/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      <guid>/intro_pymc3/</guid>
      <description>We give an introduction to PyMC3, a probabilistic programming framework written in Python. We revise the basic mahematical theory and present two concrete examples.</description>
    </item>
    <item>
      <title>Web scraping with Beautiful Soup: Plebiscito Colombia (October 2nd)</title>
      <link>/plebiscito/</link>
      <pubDate>Sun, 09 Jul 2017 00:00:00 +0000</pubDate>
      <guid>/plebiscito/</guid>
      <description>We describe how to use Beautiful Soup to scrape the official goverment website in order to get the results of the peace referendum  in Colombia.</description>
    </item>
    <item>
      <title>The Dirac operator on the 2-sphere</title>
      <link>/the-dirac-operator-on-the-2-sphere/</link>
      <pubDate>Thu, 29 Jun 2017 00:00:00 +0000</pubDate>
      <guid>/the-dirac-operator-on-the-2-sphere/</guid>
      <description>&lt;p&gt;The objective of this post is to explore &lt;a href=&#34;http://docs.mathjax.org/en/latest/index.html&#34;&gt;MathJax&lt;/a&gt;, a JavaScript display engine for LaTeX. Being my first post writen with this tool, I want to present a short but fun example: I will give a description of the explicit computation of the &lt;a href=&#34;https://en.wikipedia.org/wiki/Dirac_operator&#34;&gt;spin-Dirac&lt;/a&gt; operator (of the unique complex spinor bundle!) on the 2-sphere \(S^2\) equipped with the standar round metric. A more detailed treatment can be found in my expository &lt;a href=&#34;https://arxiv.org&#34;&gt;paper&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;center&gt;&#xA;&lt;img src=&#34;\images\sphere.png&#34; alt=&#34;png&#34; /&gt;&#xA;&lt;/center&gt;&#xA;&lt;hr /&gt;&#xA;&lt;div id=&#34;the-levi-civita-connection&#34; class=&#34;section level2&#34;&gt;&#xA;&lt;h2&gt;The Levi-Civita connection&lt;/h2&gt;&#xA;&lt;p&gt;Let us consider a 2-sphere of radius &lt;span class=&#34;math inline&#34;&gt;\(r&amp;gt;0\)&lt;/span&gt;,&lt;/p&gt;</description>
    </item>
    <item>
      <title>Python Exercise: Distance to Rectangle</title>
      <link>/rectangle/</link>
      <pubDate>Wed, 28 Jun 2017 00:00:00 +0000</pubDate>
      <guid>/rectangle/</guid>
      <description>In this first post we get started with a small python script to explore the basic capabilities of Pelican.</description>
    </item>
  </channel>
</rss>
